---
layout: post
author: Robin
title: iOS内存管理小结
tags: 开发知识 iOS
---

内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，但是ARC并不是万能的，有些框架中和某些使用到C语言的场景中还是需要开发者手动对内存进行管理。

## iOS 中的内存管理模型

对于**面向过程**的C语言而言，在内存管理的设计上也较为直接，内存的申请和释放都由开发者手动管理。这种管理方式虽然简单，但是大大的增加了编码的工作量，也增加了代码的复杂度。

在**面向对象**语言中，内存管理通常会由**模型机制**来完成，常见的内存管理模型机制有**垃圾回收机制**和**引用计数机制**两种，Objective-C语言采用的则是引用计数的内存管理模型。

内存的管理其实就是管理程序代码和相关数据对内存的消耗，在iOS中，内存通常被分为5个特定的功能性区域：

* **栈区**：存储局部变量，或自动变量，在作用域结束后内存会被回收；栈区也保存了函数调用的现场；
* **堆区**：存储OC对象，需要开发者手动申请和释放，通常使用malloc、realloc、alloc等函数控制的变量，均存储在堆上，堆在所有的线程，共享库和动态加载的模块中被共享使用；
* **BSS区**：即Block Started by Symbol，用来存储未初始化的全局变量和静态变量；
* **数据区**：用来存储已经初始化的全局变量、静态变量和常量；
* **代码区**：加载程序代码。

在5个内存区域中，除了堆区需要开发者手动进行内存的管理外，其他区域均由系统自动进行管理。

引用计数是Objective-C语言提供的内存管理技术，每一个Objective-C对象都有一个**retainCount**属性，该属性便是引用计数机制的根本。一个Objective-C对象是否应该被释放，取决于retainCount是否为0。

### 关于MRC

MRC内存管理有如下两个原则：

* 谁持有对象，谁负责释放，不是自己持有的不能释放；
* 当对象不再被需要时，需要主动释放。

在OC中，会对对象进行持有的方法有alloc、new、copy、mutableCopy、retain。其中retain是对当前对象进行持有，使得引用计数加1，其余四个是创建新的对象，创建后引用计数加1。

### 关于ARC

ARC是Xcode编译器的功能，ARC并没有改变MRC内存管理的两个原则，也并没有在运行时增加新的特性，ARC仅仅是在编译时帮助开发者将retain和release方法给补上。

ARC下，有几个关键的修饰符：**__strong、__weak、__unsafe_unretained、__autoreleasing**，被称为**所有权修饰符**，在开发中，开发者所使用的指针默认使用**__strong**修饰符。

__strong修饰符通常是对变量进行强引用，主要有三方面的作用：

1. 使用__strong修饰的变量如果是自己生成的，则会被添加进自动释放池，在作用域结束后，会被release一次；
2. 使用__strong修饰的变量如果不是自己生成的，则会被强引用，即会被持有使其引用计数加1，在离开作用域之后，会被release一次；
3. 使用__strong修饰的变量如果重新赋值或者置为nil，则变量会被release一次。

__weak修饰符通常用来对变量进行弱引用，最大的用途是避免ARC环境下的循环引用问题。**循环引用**问题是ARC中造成内存泄漏的主要问题。__weak修饰符主要有两个作用：

1. 被__weak修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会被添加到自动释放池，会在离开作用域是被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作；
2. 被__weak修饰的变量指针，变量如果失效，则指针会被自动置为nil，否则可能会造成`野指针`异常。

__unsafe_unretained修饰符是不全安的，该修饰符的作用也是对变量进行弱引用，和__weak不同的是，当变量失效后，其指针不会被自动置为nil。__unsafe_unretained修饰符的主要作用：

1. 被__unsafe_unretained修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会在离开作用域后release一次，如果不是自己生成的，则在离开作用域后，不进行release操作；
2. 被__unsafe_unretained修饰的变量，当变量失效后，被修饰指针不会被安全处理为nil，即旧地址依然保存。

__autoreleasing修饰符与自动释放池有关。

在使用ARC时，有以下几条原则：

* 不能使用retain、release、autorelease函数，不可访问retainCount属性
* 不能调用dealloc函数，可以覆写dealloc函数，但是在其视线中不可调用父类的dealloc函数
* 不能使用NSAutoreleasePool，可以使用@autoreleasepool代替
* 对象类型变量不能作为C语言的结构体

### 属性修饰符

**类是属性和方法的集合。属性用来存储类中的数据，方法用来描述类的行为。**

属性在声明时会默认添加修饰符。在MRC环境下，默认的属性修饰符为**atomic，readWrite，retain**，在ARC下，默认的属性修饰符为**atomic，readWrite，strong\assign**。

通常情况下，在声明属性时会使用@property，此时编译器或自动帮助声明和实现属性的Setter方法和Getter方法。

关于内存管理相关的属性修饰符有如下几种：

<table>
        <tr>
            <th>修饰符</th>
            <th>作用</th>
        </tr>
        <tr>
            <th>assign</th>
            <th>直接赋值，和引用计数无关，用来声明简单数据类型的属性，例如int</th>
        </tr>
        <tr>
            <th>retain</th>
            <th>对旧对象进行释放，并强引用新的对象，使其引用计数加1，用在MRC中</th>
        </tr>
        <tr>
            <th>strong</th>
            <th>对新对象进行强引用，释放旧对象，使其引用计数加1，作用与retain相似，用在ARC中</th>
        </tr>
        <tr>
            <th>copy</th>
            <th>在实现Setter方法时，采用copy函数，会生成新的对象，并被自己持有</th>
        </tr>
        <tr>
            <th>weak</th>
            <th>弱引用，不对所赋值的对象进行持有，但是是安全的，对对象不可用时，会被置为nil，用在ARC中</th>
        </tr>
        <tr>
            <th>unsafe_unreatined</th>
            <th>弱引用，和weak不同的是，如果引用的对象不可用，则当前指针不会被置为nil，会产生野指针</th>
        </tr>
    </table>

## 自动释放内存

在iOS中，对象的创建除了使用alloc、new等函数创建外，还可使用对象的对象方法来创建，但此时对象的创建方式并不符合“谁持有对象，谁负责释放”的原则，此类方式创建的对象在内存管理上，则将管理权移交给了自动释放池。

我们知道，release函数的作用是对当前对象进行一次引用计数减1，当引用计数为0时，才真实释放对象所使用的内存。而autorelease，其本质上是使release函数的调用进行延迟调用了。可以简单的把autorelease方法的对象成为自动释放对象，自动释放对象的内存管理是提交给自动释放池处理的。

### 自动释放池

@autoreleasepool{}标识就是自动释放池，当自动释放池操作结束后，其会向被添加进自动释放池的所有对象发送release消息。@autoreleasepool{}的写法是ARC下的下发，在MRC坏境下，需要创建自动释放池对象，然后进行使用。

```objc
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
// 添加进自动释放池的对象
[pool release];
```

另外，在iOS系统运行应用程序时，会自动创建一些线程，每个线程都默认拥有自己的自动释放池。还有，在每次执行时间循环时，都活将其自动释放池清空。因此，在大多数情况下，开发者不需要手动创建自动释放池，例外的是，系统的自动释放池会在每次时间循环结束后清空，如果代码中有大量的循环，会生成大量的自动释放对象，则可能会导致内存消耗瞬时增长。

## 杜绝内存泄漏

**内存泄漏的核心问题是循环引用。**

**循环引用：在OC设计中，对象会对其内部的属性进行持有，当一个对象的引用计数为0，将其内存回收时，这个对象会向其内的所有属性发送release消息，让其中的属性对象进行释放。如果对象内的某个属性再次对当前的对象进行了持有，则会产生循环引用。**

### Block与循环引用

Block是OC中一种十分强大的语法。使用Block，可以将代码块作为属性、参数以及变量来使用，并且可以灵活地执行这块代码。Block的实质是一段可执行的代码块，对于Block类型的属性和变量，可以对其进行赋值。但究其根本，Block的本质还是对象。

对于Block的使用，有一些有趣的地方，在Block中访问Block外的数据时没有问题的，无论是对象数据还是基本数据类型数据，但是如果要在Block中修改Block外的数据，可能会发生异常，可变字符串等外部数据的修改不会发生异常。

其实并不是Block对外部数据修改有什么特殊的设计，而是因为在Block中，任何外部数据都是不允许被修改的，可变类型数据能够被修改，是因为对象指针所指向的内存存放的只是对象数据的地址，并不是对象数据本身，只要地址不被修改，只修改对象的数据是没有问题的。

**在Block内部无法修改外部数据的根本原因在于，Block中访问外部变量时，都会对其进行拷贝和强引用，这里的拷贝是直接拷贝，如果在Block外部和内部分别打印对象，会看到对象的地址是不同的。**

如果要保证在Block内部可以自由修改外部的数据，OC提供了__block关键字，使用该关键字修饰的变量，可以在Block中直接访问原始变量，而没有拷贝。

```objc
self.myblock = ^BOOL(int param){
    NSLog(@"%@", self);
    return YES;
};
```
上述代码是Block中循环引用的经典例子。其中myblock和self之间产生的循环引用。要解决Block中的循环引用，只需要在Block中使用弱引用的指针即可，这样在Block的作用域结束后，其对外部变量的引用也会自然切换，避免循环引用。

### 代理与循环引用

代理是另一种可能会产生循环引用的场景。在iOS中，除了系统的一些原生的组件需要通过代理函数来进行回调外，开发者也经常使用**代理来进行传值、逻辑回调、组件配置**等。有时，开发者会使用代理来进行**反向传值**，而反向传值的时候需要在视图控制器中设置代理，如果代理属性采用了strong修饰符，则视图控制器对代理对象是强应用，而定义代理的类可能又是视图控制器的属性，造成了循环引用，造成内存泄漏，因此在使用代理模式的时候，设置代理属性一般采用如下修饰符：

```objc
@property (nonatomic, weak) id<CustomeDelegate> delegate;
```


### 定时器引起的内存泄漏

定时器通产个用来进行循环任务的执行，NSTimer是iOS中极易产生循环引用的一个类。通常在使用定时器时，会定义一个定时器对象如下：

```objc
@property (nonatomic, strong) NSTimer * timer;
```

再具体使用定时器时，如下：

```objc
self.timer = [NSTimer scheduledTimerWithTimeInterval: 1 target: self selector:@selector(timerRun) userinfo: nil repeat: YES];
```

当定时器对象所在的视图控制器被dismiss之后，视图控制器并没有执行dealloc函数，原因在于定时器对象实际上持有了视图控制器，只有当定时器失效后，其才会释放所持有的视图控制器。因此，在视图控制器返回前，开发者可以手动调用invalidate方法使得定时器失效，已避免循环引用。

> iOS 10 SDK 中已经提供了避免循环引用的NSTimer 新 API。

## “僵尸”对象

首先，**僵尸对象和内存泄漏无任何关系。**但是产生僵尸对象也属于内存管理问题。当一个对象被释放后，如果其指针没有置空，则这个指针就变成了野指针，此时该对象被称为僵尸对象。

### 僵尸对象的捕获

在OC中，内存的使用包含如下几个阶段：

* 请求创建对象，向系统申请一块内存空间，在申请完成后，这块内存空间不能在做他用；
* 对象被释放，此时这块内存空间变为闲置，可以被再次申请使用；
* 在此块内存重新被申请使用之前，这块内存中的数据依然存在；
* 此时如果依然有指针指向这块内存，则此指针为野指针；
* 当野指针对这块内存进行访问时，如果这块内存已经被重新分配，则会出现系统问题，如果没有被分配，则不会出现系统问题。

在MRC下，当一个对象被release后，再去访问这个对象的时候，就会出现异常，出现僵尸对象。而在ARC下,Xcode也提供了捕获僵尸对象的选项，供开发者使用。**Zombie Objects选项**

### 处理僵尸对象

一般在开发中，僵尸对象一旦出现，大多数情况是代码逻辑的问题，但是如果做到万无一失，避免由于僵尸对象带来应用程序的崩溃呢？

在OC中，向空指针发送任何消息都是无效的。因此，访问到僵尸对象的根本问题是野指针的问题。在ARC中，使用__weak和__strong修饰的变量指针，在对象释放后被自动置为nil，这就大大减少了野指针的问题。另外一种方式就是使用OC的消息机制来规避所有的僵尸对象问题。

## CoreFoundation框架中的内存管理

CoreFoundation框架是由C语言实现的一组编程接口，与Foundation框架提供类似的基础功能，不同的是Foundation框架是由OC语言实现的，CoreFoundation也提供了字符串、数组、集合、颜色、时间和URL等对象。

**CoreFoundation框架中依然采用引用计数的方式进行内存管理，但并不支持ARC。**

在CoreFoundation框架中，有几条内存管理法则：

1. 自己创建的对象要自己负责释放；
2. 如果使用别人创建的对象，要保证其可用，则需要对对象进行持有；
3. 如果对对象进行了持有，则当不在需要此对象时，要进行释放。

在CoreFoundation框架中，使用带有Create、Copy此类字段的函数获取的对象会被认为是自己创建的对象，要负责这些对象的释放。当使用滴啊有Get这样的字段的函数获取对象时，默认并不对此对象进行持有，可以手动调用CFRetain()函数进行持有。

## 总结

* OC是面向对象的语言，但是对象仅仅是引用层面的一种抽象，抛开其华丽的外衣，底层依然是最为朴素的结构体和指针。
* OC语言采用了引用计数的内存管理模型，对内存进行管理；
* 除了用户自建的内存管理池意外，系统在每个线程都维护了一个系统级别的自动释放池；
* OC语言的类型检查都是编译时的特性；
* OC语言的数据传递是运行时决定的。