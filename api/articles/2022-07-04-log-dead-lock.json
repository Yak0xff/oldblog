{"title":"2022-07-04  关于死锁的简单记录","uid":"e0ae854e6f0229d985990b4529079d67","slug":"2022-07-04-log-dead-lock","date":"2022-07-04T14:21:38.000Z","updated":"2023-05-22T03:17:40.071Z","comments":true,"path":"api/articles/2022-07-04-log-dead-lock.json","keywords":null,"cover":[],"content":"<ul>\n<li><strong>死锁</strong> 指的是在多线程环境中，两个以上的线程在执行过程中，因争夺资源而造成一种相互等待的现象，如果无外力作用下，它们都将无法推进下去。</li>\n</ul>\n<p>举个简单例子：</p>\n<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n<p><img src=\"/images/logs/2022-07-04_log.png\" alt=\"死锁图例\"></p>\n<ul>\n<li><p><strong>死锁的条件：</strong></p>\n</li>\n<li><p><strong>互斥条件：</strong>线程对资源的访问是排他性的，如果一个线程占用了某个资源，那么其他线程等待，直到锁被释放。</p>\n</li>\n<li><p><strong>不可剥夺条件：</strong>线程在已经获得资源的情况下，未使用完之前，不能被其他线程剥夺，只能在使用完之后自己释放。</p>\n</li>\n<li><p>**保持和请求条件： **线程T1至少已经保持了一个资源R1的占用，同时又提出对另一个资源R2的请求，但是R2 又被其他线程T2占用，所以线程T1必须等待，但又对自己保持对R1 不释放，而T2又必须要得到R1的资源才能继续执行。</p>\n</li>\n<li><p><strong>环路等待条件：</strong>在死锁发生时，必然存在一个“线程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。</p>\n</li>\n<li><p><strong>避免线程死锁：</strong></p>\n</li>\n</ul>\n<p>避免死锁的方案可以从造成死锁的四个条件入手，破坏导致死锁必要条件中的任意一个就可以预防死锁：</p>\n<ul>\n<li><strong>破坏互斥条件：</strong>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的(临界资源需要互斥访问)。</li>\n<li><strong>破坏请求与保持条件：</strong>不再分批申请资源，一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件：</strong>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件：</strong>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。对于前面的例子如果线程1，线程2都是先申请资源1，再申请资源2就不会导致死锁了。</li>\n</ul>\n<p><strong>死锁的例子：</strong></p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">NSObject *resource1 &#x3D; [NSObject new];\nNSObject *resource2 &#x3D; [NSObject new];\n\ndispatch_queue_t queue1 &#x3D; dispatch_queue_create(&quot;thread1&quot;, DISPATCH_QUEUE_CONCURRENT);\ndispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;thread2&quot;, DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_async(queue1, ^&#123;\n    @synchronized (resource1) &#123;\n        IDLLogInfo(@&quot;queue1获取到资源1&quot;);\n        sleep(10);\n        IDLLogInfo(@&quot;queue1尝试获取资源2&quot;);\n        @synchronized (resource2) &#123;\n             IDLLogInfo(@&quot;queue1获取到资源2&quot;);\n         &#125;\n    &#125;\n&#125;);\n    \ndispatch_async(queue2, ^&#123;\n  @synchronized (resource2) &#123;\n      IDLLogInfo(@&quot;queue2获取到资源2&quot;);\n      sleep(20);\n       IDLLogInfo(@&quot;queue2尝试获取资源1&quot;);\n       @synchronized (resource1) &#123;\n            IDLLogInfo(@&quot;queue2获取到资源1&quot;);\n       &#125;\n   &#125;\n&#125;);</code></pre>\n\n","text":" 死锁 指的是在多线程环境中，两个以上的线程在执行过程中，因争夺资源而造成一种相互等待的现象，如果无外力作用下，它们都将无法推进下去。 举个简单例子： 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Logs","slug":"Logs","count":3,"path":"api/categories/Logs.json"}],"tags":[],"toc":"","author":{"name":"Yak-0xff","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位不满现状，就爱瞎折腾的技术人 <br /> 🤔 <b>勿以事小而不为</b>","socials":{"github":"https://github.com/zycslog","twitter":"https://twitter.com/zh_robin","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3104676569682525","customs":{}}},"mapped":true,"prev_post":{"title":"2022-07-17  重构那些事","uid":"9f08952be24e03501c17b0dc2ee6bf37","slug":"2022-07-17-log-refactor","date":"2022-07-17T20:30:38.000Z","updated":"2023-05-22T03:17:40.071Z","comments":true,"path":"api/articles/2022-07-17-log-refactor.json","keywords":null,"cover":null,"text":"WHAT：什么是重构？ Martin Fowler：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。 大型重构 对象：对系统、模块、代码结构、类与类之间的关系等的重构 方法：有分层垂直拆分、模块化水平拆分、解耦、抽象UI组件、抽象...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Logs","slug":"Logs","count":3,"path":"api/categories/Logs.json"}],"tags":[],"author":{"name":"Yak-0xff","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位不满现状，就爱瞎折腾的技术人 <br /> 🤔 <b>勿以事小而不为</b>","socials":{"github":"https://github.com/zycslog","twitter":"https://twitter.com/zh_robin","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3104676569682525","customs":{}}}},"next_post":{}}