{"title":"\\#13\\ 字典树（Tries Tree）","uid":"7c0350b0f98d8a7fc26f52b6c73852fb","slug":"2020-01-06-Data-Structures-&-Algorithms-in-Swift-13","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2020-01-06-Data-Structures-&-Algorithms-in-Swift-13.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/13/cover.jpg","content":"<p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n<p>例如利用Tries表示一个英语单词，可以表示如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png\"></p>\n<p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">class EnglishDictionary &#123;\n    private var words: [String]\n    \n    func words(matching prefix: String) -&gt; [String] &#123;\n        return words.filter &#123; $0.hasPrefix(prefix) &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p>\n<p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p>\n<p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p>\n<p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png\"></p>\n<p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p>\n<p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png\"></p>\n<p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png\"></p>\n<h2 id=\"结构实现\"><a href=\"#结构实现\" class=\"headerlink\" title=\"结构实现\"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p>\n<h3 id=\"TrieNode\"><a href=\"#TrieNode\" class=\"headerlink\" title=\"TrieNode\"></a>TrieNode</h3><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class TrieNode&lt;Key: Hashable&gt; &#123;\n    public var key: Key?\n    public weak var parent: TrieNode?\n    public var children: [Key: TrieNode] &#x3D; [:]\n    public var isTerminating &#x3D; false\n    \n    public init(key: Key?, parent: TrieNode?) &#123;\n        self.key &#x3D; key\n        self.parent &#x3D; parent\n    &#125;\n&#125;</code></pre>\n\n<p>Tries的节点结构和其他树型数据结构有明显的不同。</p>\n<ul>\n<li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li>\n<li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li>\n<li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li>\n<li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li>\n</ul>\n<h3 id=\"Trie\"><a href=\"#Trie\" class=\"headerlink\" title=\"Trie\"></a>Trie</h3><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class Trie&lt;CollectionType: Collection&gt; where CollectionType.Element: Hashable&#123;\n    \n    public typealias Node &#x3D; TrieNode&lt;CollectionType.Element&gt;\n    private let root &#x3D; Node(key: nil, parent: nil)\n    \n    public init() &#123;&#125;\n&#125;</code></pre>\n<p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p>\n<p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p>\n<h2 id=\"操作算法实现\"><a href=\"#操作算法实现\" class=\"headerlink\" title=\"操作算法实现\"></a>操作算法实现</h2><h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func insert(_ collection: CollectionType) &#123;\n    var current &#x3D; root\n        \n    for element in collection &#123;\n        if current.children[element] &#x3D;&#x3D; nil &#123;\n            current.children[element] &#x3D; Node(key: element, parent: current)\n        &#125;\n        current &#x3D; current.children[element]!\n    &#125;\n        \n    current.isTerminating &#x3D; true\n&#125;</code></pre>\n\n<ul>\n<li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li>\n<li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li>\n<li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li>\n</ul>\n<p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p>\n<h3 id=\"Contains\"><a href=\"#Contains\" class=\"headerlink\" title=\"Contains\"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Trie &#123;\n    public func contains(_ collection: CollectionType) -&gt; Bool &#123;\n        var current &#x3D; root\n        \n        for element in collection &#123;\n            guard let child &#x3D; current.children[element] else &#123;\n                return false\n            &#125;\n            \n            current &#x3D; child\n        &#125;\n        return current.isTerminating\n    &#125;\n&#125;</code></pre>\n\n<p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p>\n<p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;insert and contains&quot;) &#123;\n    let trie &#x3D; Trie&lt;String&gt;()\n    trie.insert(&quot;cute&quot;)\n    trie.insert(&quot;cut&quot;)\n    if trie.contains(&quot;cute&quot;) &#123;\n        print(&quot;cute is in the trie&quot;)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of insert and contains---\ncute is in the trie\n*&#x2F;</code></pre>\n\n\n<h3 id=\"Remove\"><a href=\"#Remove\" class=\"headerlink\" title=\"Remove\"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Trie &#123;\n    public func remove(_ collection: CollectionType) &#123;\n        var current &#x3D; root\n        for element in collection &#123;\n            guard let child &#x3D; current.children[element] else &#123;\n                return\n            &#125;\n            current &#x3D; child\n        &#125;\n        \n        guard current.isTerminating else &#123;\n            return\n        &#125;\n        current.isTerminating &#x3D; false\n        while let parent &#x3D; current.parent, current.children.isEmpty &amp;&amp; !current.isTerminating &#123;\n            parent.children[current.key!] &#x3D; nil\n            current &#x3D; parent\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li>\n<li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li>\n<li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li>\n</ul>\n<p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;remove&quot;) &#123;\n    let trie &#x3D; Trie&lt;String&gt;()\n    trie.insert(&quot;cut&quot;)\n    trie.insert(&quot;cute&quot;)\n    \n    print(&quot;\\n*** Before removeing ***&quot;)\n    assert(trie.contains(&quot;cut&quot;))\n    print(&quot;\\&quot;cut\\&quot; is in the trie&quot;)\n    assert(trie.contains(&quot;cute&quot;))\n    print(&quot;\\&quot;cute\\&quot; is in the trie&quot;)\n    \n    print(&quot;\\n*** After removing cut ***&quot;)\n    trie.remove(&quot;cut&quot;)\n    assert(!trie.contains(&quot;cut&quot;))\n    assert(trie.contains(&quot;cute&quot;))\n    print(&quot;\\&quot;cute\\&quot; is still in the trie&quot;)\n&#125;\n\n&#x2F;*\n---Example of remove---\n\n*** Before removeing ***\n&quot;cut&quot; is in the trie\n&quot;cute&quot; is in the trie\n\n*** After removing cut ***\n&quot;cute&quot; is still in the trie\n*&#x2F;</code></pre>\n\n<h3 id=\"Prefix-matching\"><a href=\"#Prefix-matching\" class=\"headerlink\" title=\"Prefix matching\"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Trie where CollectionType: RangeReplaceableCollection &#123;\n    \n&#125;</code></pre>\n\n<p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func collections(startingWith prefix: CollectionType) -&gt; [CollectionType] &#123;\n    var current &#x3D; root\n    for element in prefix &#123;\n        guard let child &#x3D; current.children[element] else &#123;\n            return []\n        &#125;\n        current &#x3D; child\n    &#125;\n    \n    return collections(startingWith: prefix, after: current)\n&#125;</code></pre>\n\n<ul>\n<li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li>\n<li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li>\n</ul>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func collections(startingWith prefix: CollectionType, after node: Node) -&gt; [CollectionType] &#123;\n    \n    var results: [CollectionType] &#x3D; []\n    \n    if node.isTerminating &#123;\n        results.append(prefix)\n    &#125;\n    \n    for child in node.children.values &#123;\n        var prefix &#x3D; prefix\n        prefix.append(child.key!)\n        results.append(contentsOf: collections(startingWith: prefix, after: child))\n    &#125;\n    return results\n&#125;</code></pre>\n\n<ul>\n<li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li>\n<li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li>\n</ul>\n<p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p>\n<p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;prefix matching&quot;) &#123;\n    let trie &#x3D; Trie&lt;String&gt;()\n    trie.insert(&quot;car&quot;)\n    trie.insert(&quot;card&quot;)\n    trie.insert(&quot;care&quot;)\n    trie.insert(&quot;cared&quot;)\n    trie.insert(&quot;cars&quot;)\n    trie.insert(&quot;carbs&quot;)\n    trie.insert(&quot;carapace&quot;)\n    trie.insert(&quot;cargo&quot;)\n    \n    print(&quot;\\nCollections starting with \\&quot;car\\&quot;&quot;)\n    let prefixedWithCar &#x3D; trie.collections(startingWith: &quot;car&quot;)\n    print(prefixedWithCar)\n    \n    print(&quot;\\nCollections starting with \\&quot;care\\&quot;&quot;)\n    let prefixedWithCare &#x3D; trie.collections(startingWith: &quot;care&quot;)\n    print(prefixedWithCare)\n&#125;\n\n&#x2F;*\n---Example of prefix matching---\n\nCollections starting with &quot;car&quot;\n[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]\n\nCollections starting with &quot;care&quot;\n[&quot;care&quot;, &quot;cared&quot;]\n*&#x2F;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>Trie树在前缀匹配上有着卓越的性能表现；</li>\n<li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li>\n</ul>\n","text":"Tries 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">结构实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TrieNode\"><span class=\"toc-text\">TrieNode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Trie\"><span class=\"toc-text\">Trie</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">操作算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Insert\"><span class=\"toc-text\">Insert</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Contains\"><span class=\"toc-text\">Contains</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Remove\"><span class=\"toc-text\">Remove</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Prefix-matching\"><span class=\"toc-text\">Prefix matching</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#12\\ 自平衡二叉搜索树（AVL Trees）","uid":"4085c41c06b2e3ba45ef163b731b2c76","slug":"2019-12-27-Data-Structures-&-Algorithms-in-Swift-12","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2019-12-27-Data-Structures-&-Algorithms-in-Swift-12.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/12/cover.png","text":"在上文中，已经了解二叉搜索树的O(log n)性能特征，但是当二叉搜索树节点删除中，可能会出现不平衡的树，并降低树的性能到O(n)。这一文的内容将学习另一种改进了的二叉搜索树 — 自平衡二叉搜索树。 1962年，Georgy Adelson-Velsky和Evgenii Land...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#14\\ 二分查找（Binary Search）","uid":"193dbb4158d425c4c3d00532baa1c670","slug":"2020-01-07-Data-Structures-&-Algorithms-in-Swift-14","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2020-01-07-Data-Structures-&-Algorithms-in-Swift-14.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/14/cover.jpg","text":"二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足： 集合必须是在恒定的时间内执行索引操作，意味着集合必须是RandomAccessCollection类型的； 集...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}