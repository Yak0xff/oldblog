{"title":"\\#17\\ 排序算法O(n^2)","uid":"8ac62db54bf242691e8bc332c52f0b5b","slug":"2020-01-15-Data-Structures-&-Algorithms-in-Swift-17","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2020-01-15-Data-Structures-&-Algorithms-in-Swift-17.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/17/cover.jpg","content":"<p>**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。</p>\n<p>在本文中，将学习饿三种不同的、O(n^2)时间复杂度的排序算法：</p>\n<ul>\n<li>冒泡排序</li>\n<li>选择排序</li>\n<li>插入排序</li>\n</ul>\n<p>这些算法均是<strong>基于比较</strong>的方法，他们依赖比较的运算，比如小于或等于运算符等，对数据进行排序。比较操作的调用次数是衡量此类算法技术总体性能的一般方法。</p>\n<h2 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是相对简单的一种排序方法，在排序的过程中，重复比较两个数据的大小，并进行数据交换。其中较大的数值会类似气泡上升一样上升到集合的尾部。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/example.png\"></p>\n<p>例如上图所示的四张扑克，其顺序为*[9， 4， 10， 3]*，现在需要对其从小到大进行排序，需要如下几个步骤：</p>\n<ul>\n<li>从集合最前端开始，比较扑克牌9和扑克牌4，由于9比4大，因此需要进行位置交换，交换后，顺序变为*[4， 9， 10， 3]*；</li>\n<li>完成了第一步后，比较的锚点移动到集合的下一个索引处，即此时的扑克牌9，比较9和10，符合小的在前，大的在后，顺序不变；</li>\n<li>继续移动到下一个索引，扑克牌10，比较10和3，不符合从小到大的原则，进行位置交换，交换后，集合变为*[4， 9， 3， 10]*。</li>\n</ul>\n<p>集合遍历第一遍后，往往很难使得集合达到预期的目标，但是对于上述集合来说，最大的扑克牌10，已经冒泡移动到了集合的最末端。</p>\n<p>接下来进行第二遍遍历，此时比较扑克牌4和9:</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/example_step.png\"></p>\n<p>只有当集合不用进行再进行交换的时候，整个集合才算所排序完成。最差的情况下，堆集合的遍历需要<em>n - 1</em>次，其中 <em>n</em> 为集合元素的个数。</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func bubbleSort&lt;Element&gt;(_ array: inout [Element]) where Element: Comparable &#123;\n    guard array.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for end in (1 ..&lt; array.count).reversed() &#123;\n        var swapped &#x3D; false\n        \n        for current in 0 ..&lt; end &#123;\n            if array[current] &gt; array[current + 1] &#123;\n                array.swapAt(current, current + 1)\n                swapped &#x3D; true\n            &#125;\n        &#125;\n        if !swapped &#123;\n            return\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li>对集合进行元素个数检查，如果元素的个数小于2，则不需要进行排序；</li>\n<li>进行外层循环，首次循环之后，最大的元素将会移至集合的末尾，下次循环的时候，总是会比上一次少一个元素，因此，每次循环基本上都会少一次比较；</li>\n<li>进行元素间的比较和交换。比较当前元素和下一个元素的大小，如果当前元素大于下一个元素，则进行位置的交换；</li>\n<li>如果再无元素需要交换，则说明集合已经排序完成，排序退出。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;bubble sort&quot;) &#123;\n    var array &#x3D; [9, 4, 10, 3]\n    print(&quot;Original: \\(array)&quot;)\n    bubbleSort(&amp;array)\n    print(&quot;Bubble sorted: \\(array)&quot;)\n&#125;\n\n&#x2F;*\n---Example of bubble sort---\nOriginal: [9, 4, 10, 3]\nBubble sorted: [3, 4, 9, 10]\n*&#x2F;</code></pre>\n\n<p>冒泡排序最好的时间复杂度为O(n)，最差时间复杂度为O(n^2)。</p>\n<h2 id=\"选择排序（Selection-sort）\"><a href=\"#选择排序（Selection-sort）\" class=\"headerlink\" title=\"选择排序（Selection sort）\"></a>选择排序（Selection sort）</h2><p>选择排序遵循冒泡排序的基本思想，但是优化了元素位置交换的数量，选择排序仅在每次传递结束之后才进行元素的交换。</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>假设有如下数量的扑克牌：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/example.png\"></p>\n<p>每轮传递之后，选择排序将找到最小的未排序的元素，并对其进行位置交换：</p>\n<ol>\n<li>首先，发现扑克3是最小的，因此和扑克9交换位置；</li>\n<li>下一个最小的扑克是4，其已经在正确地位置；</li>\n<li>最后，最小的未扑克9，和扑克10交换。</li>\n</ol>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/selection-sort-02.png\"></p>\n<h3 id=\"算法实现-1\"><a href=\"#算法实现-1\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func selectionSort&lt;Element&gt;(_ array: inout [Element]) where Element: Comparable &#123;\n    guard array.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for current in 0 ..&lt; (array.count - 1) &#123;\n        var lowest &#x3D; current\n        \n        for other in (current + 1) ..&lt; array.count &#123;\n            if array[lowest] &gt; array[other] &#123;\n                lowest &#x3D; other\n            &#125;\n        &#125;\n        if lowest !&#x3D; current &#123;\n            array.swapAt(lowest, current)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li>遍历除了集合最后一个元素之外的其他元素，因为如果其他的元素都在正确地位置了，那么最后一个元素也是正确位置了；</li>\n<li>再次遍历除当前索引之前的其他所有元素，寻找子集合中最小值的元素；</li>\n<li>如果当前元素的索引并不是最小元素对应的索引，则进行元素位置的交换。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;selection sort&quot;) &#123;\n    var array &#x3D; [9, 4, 10, 3]\n    print(&quot;Original: \\(array)&quot;)\n    selectionSort(&amp;array)\n    print(&quot;Selection sorted: \\(array)&quot;)\n&#125;\n\n&#x2F;*\n---Example of selection sort---\nOriginal: [9, 4, 10, 3]\nSelection sorted: [3, 4, 9, 10]\n*&#x2F;</code></pre>\n\n<p>类似冒泡排序，选择排序的最好、最坏和平均时间复杂度为O(n^2)，虽然有点让人沮丧，但是相比冒泡排序而言，选择排序的确表现的更好一些。</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序是更加有用的排序算法。像冒泡排序和选择排序，插入排序的平均时间复杂度依然为O(n^2)，但是插入排序的性能不同。越多的数据需要进行排序，选择排序会带来事半功倍的效果。在集合已经排序好的情况下，插入排序能达到最好时间复杂度O(n)。在Swift标准库中的排序算法使用的是混合排序的方式，当未排序的区间元素个数小于20个元素的时候，会采用插入排序的方式。</p>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>同上，加入有如下的扑克牌：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/example.png\"></p>\n<p>插入排序将会从左至右遍历扑克一次，每张扑克均向左移动，直到其所在位置正确位置：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/17/insertion-sort-02.png\"></p>\n<ol>\n<li>在遍历时，最左边的扑克可以忽略，因为在其前面再无其他扑克牌；</li>\n<li>接下来，比较扑克9和扑克4，因为扑克4较小，因此和扑克9进行位置交换；</li>\n<li>扑克10此时不需要移动，因为再其前面的扑克为9，说明扑克10在正确地位置上；</li>\n<li>最后，扑克3前面的所有扑克均比扑克3大，因此一次交换扑克3到最首位置。</li>\n</ol>\n<p>插入排序最佳的时间复杂度为O(n)，其发生在进行排序的集合元素预先是排序好的，这样在进行插入排序的时候无序进行任何左移操作。</p>\n<h3 id=\"算法实现-2\"><a href=\"#算法实现-2\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func insertionSort&lt;Element&gt;(_ array: inout [Element]) where Element: Comparable &#123;\n    guard array.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for current in 1 ..&lt; array.count &#123;\n        for shifting in (1 ... current).reversed() &#123;\n            if array[shifting] &lt; array[shifting - 1] &#123;\n                array.swapAt(shifting, shifting - 1)\n            &#125;else &#123;\n                break\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li>插入排序需要遍历集合中的每一个元素，因此第一个for循环从左至右遍历集合，这里忽略了首个位置的元素；</li>\n<li>从当前索引向前遍历元素，比较当前索引元素和前一个索引元素，如果位置不正确则进行位置交换；</li>\n<li>一直交换，直到所有索引位置的元素均在正确地位置为止。如果位置正确，则跳出当前循环，进行下一个索引元素的检查。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;insertion sort&quot;) &#123;\n    var array &#x3D; [9, 4, 10, 3]\n    print(&quot;Original: \\(array)&quot;)\n    insertionSort(&amp;array)\n    print(&quot;Insertion sorted: \\(array)&quot;)\n&#125;\n\n&#x2F;*\n---Example of insertion sort---\nOriginal: [9, 4, 10, 3]\nInsertion sorted: [3, 4, 9, 10]\n*&#x2F;</code></pre>\n\n<h2 id=\"算法泛化\"><a href=\"#算法泛化\" class=\"headerlink\" title=\"算法泛化\"></a>算法泛化</h2><p>在本内容中，将对现有的排序算法进行优化，因为现有的算法接受的集合仅仅为<em>Array</em>，对于其他的集合类型并不适用，因此将对算法进行升级，有增强算法的泛化能力，具体有如下三方面：</p>\n<ol>\n<li>对于插入排序而言，需要对集合进行前向遍历和元素交换，因此接受的参数集合应该是双向集合类型<em>BidirectionalCollection</em>；</li>\n<li>冒泡排序和选择排序仅仅对集合进行从前向后的遍历，因此集合参数仅仅需要符合集合类型<em>Collection</em>；</li>\n<li>无论哪一种情况下，集合必须是<em>MutableCollection</em>可变集合类型，因为需要在遍历过程中进行元素的交换；</li>\n</ol>\n<p><strong>优化后的冒泡排序</strong></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func bubbleSort&lt;T&gt;(_ collection: inout T) where T: MutableCollection, T.Element: Comparable &#123;\n    guard collection.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for end in collection.indices.reversed() &#123;\n        var swapped &#x3D; false\n        var current &#x3D; collection.startIndex\n        while current &gt; end &#123;\n            let next &#x3D; collection.index(after: current)\n            if collection[current] &gt; collection[next] &#123;\n                collection.swapAt(current, next)\n                swapped &#x3D; true\n            &#125;\n            current &#x3D; next\n        &#125;\n        if !swapped &#123;\n            return\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>优化后的选择排序</strong></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func selectionSort&lt;T&gt;(_ collection: inout T) where T: MutableCollection, T.Element: Comparable &#123;\n    guard collection.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for current in collection.indices &#123;\n        var lowest &#x3D; current\n        var other &#x3D; collection.index(after: current)\n        while other &lt; collection.endIndex &#123;\n            if collection[lowest] &gt; collection[other] &#123;\n                lowest &#x3D; other\n            &#125;\n            other &#x3D; collection.index(after: other)\n        &#125;\n        if lowest !&#x3D; current &#123;\n            collection.swapAt(lowest, current)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>优化后的插入排序</strong></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func insertionSort&lt;T&gt;(_ collection: inout T) where T: BidirectionalCollection &amp; MutableCollection, T.Element: Comparable &#123;\n    guard collection.count &gt;&#x3D; 2 else &#123;\n        return\n    &#125;\n    \n    for current in collection.indices &#123;\n        var shifting &#x3D; current\n        while shifting &gt; collection.startIndex &#123;\n            let previous &#x3D; collection.index(before: shifting)\n            if collection[shifting] &lt; collection[previous] &#123;\n                collection.swapAt(shifting, previous)\n            &#125; else &#123;\n                break\n            &#125;\n            shifting &#x3D; previous\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>n²算法通常名声不太那么好，在性能消耗方面总是会带来更大消耗，但是在合理的数据量下，此类算法也可解决一些排序问题；</li>\n<li>插入排序是最好的排序算法之一，在进行排序之前，需要了解数据是否已经是排序的。</li>\n</ul>\n","text":"**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。 在本文中，将学习饿三种不同的、O(n^2)时间...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89\"><span class=\"toc-text\">冒泡排序（Bubble Sort）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-sort%EF%BC%89\"><span class=\"toc-text\">选择排序（Selection sort）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1\"><span class=\"toc-text\">算法实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\">算法实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%96\"><span class=\"toc-text\">算法泛化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#16\\ 优先级队列","uid":"5d749126a5c6ef9bea973d557d834975","slug":"2020-01-12-Data-Structures-&-Algorithms-in-Swift-16","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2020-01-12-Data-Structures-&-Algorithms-in-Swift-16.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/16/cover.png","text":"队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是： 最大优先级队列：队列中最前面的元素具有最高优先级； 最小优先级队列：队列中最前面的元素具有最低优先级。 当需要在给定的元素...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#18\\ 归并排序（Merge Sort）","uid":"05deaa37bb6b9b668ab83d05b4918b64","slug":"2020-01-30-Data-Structures-&-Algorithms-in-Swift-18","date":"2023-05-13T14:52:09.994Z","updated":"2023-05-13T14:52:09.994Z","comments":true,"path":"api/articles/2020-01-30-Data-Structures-&-Algorithms-in-Swift-18.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/18/cover.jpg","text":"归并排序[Merge Sort]是最有效的排序算法之一，它的时间复杂度为O(n log n)，是所有通用排序算法中速度最快的一种。归并排序背后的思想是分而治之，即将一个大问题分解成多个更小、更易于解决的问题，然后将各个小问题的结果合并为最终结果。归并排序的终极秘诀是先拆分后合并。...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}