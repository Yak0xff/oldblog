{"title":"\\#9\\ 一般树与树节点遍历","uid":"ad7db3b90885866da085b02a06020b3f","slug":"2019-12-23-Data-Structures-&-Algorithms-in-Swift-09","date":"2023-05-24T09:24:36.375Z","updated":"2023-05-24T09:24:36.375Z","comments":true,"path":"api/articles/2019-12-23-Data-Structures-&-Algorithms-in-Swift-09.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/9/cover.png","content":"<p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p>\n<ul>\n<li>等级关系的描述</li>\n<li>分类数据的管理</li>\n<li>分类查找操作</li>\n</ul>\n<p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p>\n<h3 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h3><p>类似链表，树也是由节点构成的。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/node.png\"></p>\n<p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p>\n<h3 id=\"父节点和子节点\"><a href=\"#父节点和子节点\" class=\"headerlink\" title=\"父节点和子节点\"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p>\n<p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png\"></p>\n<h3 id=\"根节点\"><a href=\"#根节点\" class=\"headerlink\" title=\"根节点\"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/root.png\"></p>\n<h3 id=\"叶子节点\"><a href=\"#叶子节点\" class=\"headerlink\" title=\"叶子节点\"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png\"></p>\n<h2 id=\"Swift树结构实现\"><a href=\"#Swift树结构实现\" class=\"headerlink\" title=\"Swift树结构实现\"></a>Swift树结构实现</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class TreeNode&lt;T&gt; &#123;\n    public var value: T\n    public var children: [TreeNode] &#x3D; []\n    \n    public init(_ value: T) &#123;\n        self.value &#x3D; value\n    &#125;\n&#125;</code></pre>\n\n<p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p>\n<p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; 为节点添加新的子节点\npublic func add(_ child: TreeNode) &#123;\n    children.append(child)\n&#125;</code></pre>\n\n<p>Time to give it a whirl.</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;Create a tree&quot;) &#123;\n    let beverages &#x3D; TreeNode(&quot;Beverages&quot;)\n    let hot &#x3D; TreeNode(&quot;Hot&quot;)\n    let cold &#x3D; TreeNode(&quot;Cold&quot;)\n    \n    beverages.add(hot)\n    beverages.add(cold)\n    \n    print(beverages.value)\n    print(beverages.children[0].value)\n    print(beverages.children[1].value)\n&#125;\n\n&#x2F;*\n---Example of Create a tree---\nBeverages\nHot\nCold\n*&#x2F;</code></pre>\n\n<p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png\"></p>\n<h2 id=\"遍历算法\"><a href=\"#遍历算法\" class=\"headerlink\" title=\"遍历算法\"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png\"></p>\n<p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png\"></p>\n<p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p>\n<h3 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension TreeNode &#123;\n    public func forEachDepthFirst(visit: (TreeNode) -&gt; Void) &#123;\n        visit(self)\n        children.forEach &#123;\n            $0.forEachDepthFirst(visit: visit)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func makeBeverageTree() -&gt; TreeNode&lt;String&gt; &#123;\n    let tree &#x3D; TreeNode(&quot;Beverages&quot;)\n    let hot &#x3D; TreeNode(&quot;hot&quot;)\n    let cold &#x3D; TreeNode(&quot;cold&quot;)\n    \n    let tea &#x3D; TreeNode(&quot;tea&quot;)\n    let coffee &#x3D; TreeNode(&quot;coffee&quot;)\n    let chocolate &#x3D; TreeNode(&quot;cocoa&quot;)\n    \n    let blackTea &#x3D; TreeNode(&quot;black&quot;)\n    let greenTea &#x3D; TreeNode(&quot;green&quot;)\n    let chaiTea &#x3D; TreeNode(&quot;chai&quot;)\n    \n    let soda &#x3D; TreeNode(&quot;sida&quot;)\n    let milk &#x3D; TreeNode(&quot;milk&quot;)\n    \n    let gingerAle &#x3D; TreeNode(&quot;ginger ale&quot;)\n    let bitterLemon &#x3D; TreeNode(&quot;bitter lemon&quot;)\n    \n    tree.add(hot)\n    tree.add(cold)\n    \n    hot.add(tea)\n    hot.add(coffee)\n    hot.add(chocolate)\n    \n    cold.add(soda)\n    cold.add(milk)\n    \n    tea.add(blackTea)\n    tea.add(greenTea)\n    tea.add(chaiTea)\n    \n    soda.add(gingerAle)\n    soda.add(bitterLemon)\n    \n    return tree\n&#125;</code></pre>\n\n<p>该树的形态如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png\"></p>\n<p>接下来在这棵树上测试深度优先遍历。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;depth-first traversal&quot;) &#123;\n    let tree &#x3D; makeBeverageTree()\n    tree.forEachDepthFirst &#123;\n        print($0.value)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of depth-first traversal---\nBeverages\nhot\ntea\nblack\ngreen\nchai\ncoffee\ncocoa\ncold\nsida\nginger ale\nbitter lemon\nmilk\n*&#x2F;</code></pre>\n\n<p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p>\n<h3 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension TreeNode &#123;\n    public func forEachLevelOrder(visit: (TreeNode) -&gt; Void) &#123;\n        visit(self)\n        var queue &#x3D; Array&lt;TreeNode&gt;()\n        children.forEach &#123;\n            queue.append($0)\n        &#125;\n        \n        while let node &#x3D; queue.isEmpty ? nil : queue.removeFirst() &#123;\n            visit(node)\n            node.children.forEach &#123;\n                queue.append($0)\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;level-order traversal&quot;) &#123;\n    let tree &#x3D; makeBeverageTree()\n    tree.forEachLevelOrder &#123;\n        print($0.value)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of level-order traversal---\nBeverages\nhot\ncold\ntea\ncoffee\ncocoa\nsida\nmilk\nblack\ngreen\nchai\nginger ale\nbitter lemon\n*&#x2F;</code></pre>\n\n<h3 id=\"节点搜索\"><a href=\"#节点搜索\" class=\"headerlink\" title=\"节点搜索\"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension TreeNode where T: Equatable &#123;\n    public func search(_ value: T) -&gt; TreeNode? &#123;\n        var result: TreeNode?\n        forEachLevelOrder &#123; node in\n            if node.value &#x3D;&#x3D; value &#123;\n                result &#x3D; node\n            &#125;\n        &#125;\n        return result\n    &#125;\n&#125;</code></pre>\n\n<p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;searching for a node&quot;) &#123;\n    let tree &#x3D; makeBeverageTree()\n    \n    if let searchResult1 &#x3D; tree.search(&quot;ginger ale&quot;) &#123;\n        print(&quot;Found node: \\(searchResult1.value)&quot;)\n    &#125;\n    \n    if let searchResult2 &#x3D; tree.search(&quot;WKD Blue&quot;) &#123;\n        print(searchResult2.value)\n    &#125; else &#123;\n      print(&quot;Couldn&#39;t find WKD Blue&quot;)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of searching for a node---\nFound node: ginger ale\nCouldn&#39;t find WKD Blue\n*&#x2F;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li>\n<li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li>\n<li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li>\n</ul>\n<h2 id=\"Challenge\"><a href=\"#Challenge\" class=\"headerlink\" title=\"Challenge\"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png\"></p>\n<p>打印的结果应该是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">15 \n1 17 20 \n1 5 0 2 5 7</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func printEachLevel&lt;T&gt;(for tree: TreeNode&lt;T&gt;) &#123;\n    var queue &#x3D; Array&lt;TreeNode&lt;T&gt;&gt;()\n    var nodesLeftInCurrentLevel &#x3D; 0\n    queue.append(tree)\n    \n    while !queue.isEmpty &#123;\n        nodesLeftInCurrentLevel &#x3D; queue.count\n        while nodesLeftInCurrentLevel &gt; 0 &#123;\n            guard let node &#x3D; queue.isEmpty ? nil : queue.removeFirst()  else &#123; break &#125;\n            print(&quot;\\(node.value)&quot;, terminator: &quot; &quot;)\n            node.children.forEach &#123; queue.append($0) &#125;\n            nodesLeftInCurrentLevel -&#x3D; 1\n        &#125;\n        print()\n    &#125;\n&#125;</code></pre>","text":"在计算机编程的世界中，树是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如： 等级关系的描述 分类数据的管理 分类查找操作 在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。 术语关于...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">术语</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E8%8A%82%E7%82%B9%E5%92%8C%E5%AD%90%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">父节点和子节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">根节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">叶子节点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Swift%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Swift树结构实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">遍历算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">深度优先遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">广度优先遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">节点搜索</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge\"><span class=\"toc-text\">Challenge</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#8\\ 队列的Swift实现与操作定义","uid":"69dccdbf9286082e902aaae1dff82001","slug":"2019-12-10-Data-Structures-&-Algorithms-in-Swift-08","date":"2023-05-24T09:24:36.375Z","updated":"2023-05-24T09:24:36.375Z","comments":true,"path":"api/articles/2019-12-10-Data-Structures-&-Algorithms-in-Swift-08.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/8/cover.jpg","text":"在生活中，人人都熟悉排队等待。无论你是在排队购买喜欢的电影的电影票，还是排队等待打印一份文件等等，这些都是队列（Queue）数据结构。在上文\\#7\\ Stack &amp; Stack Simple Challenges中已经提到过队列和栈属于基本的数据结构类型，但是其在应用层面...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#10\\ 二叉树及其有序、前序和后序遍历","uid":"0e0f6f0242f4e4a48493fd0fe5fe0ab7","slug":"2019-12-25-Data-Structures-&-Algorithms-in-Swift-10","date":"2023-05-24T09:24:36.375Z","updated":"2023-05-24T09:24:36.375Z","comments":true,"path":"api/articles/2019-12-25-Data-Structures-&-Algorithms-in-Swift-10.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/10/cover.jpg","text":"在上一文中认识了一般树结构，其每一个节点可能会有多个子节点。二叉树也是树型结构，只不过其每一个节点最多只有两个节点，通常称为左节点和右节点。 二叉树的Swift实现首先定义二叉树的基本属性，如下： public class BinaryNode&lt;Element&gt; &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}