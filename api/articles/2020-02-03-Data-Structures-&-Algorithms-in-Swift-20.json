{"title":"\\#20\\ 堆排序（Heap Sort）","uid":"b14270b802509aef1b418b7534f574dc","slug":"2020-02-03-Data-Structures-&-Algorithms-in-Swift-20","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2020-02-03-Data-Structures-&-Algorithms-in-Swift-20.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/20/cover.jpg","content":"<p>**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看<a href=\"https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-15/\">\\#15\\ 堆数据结构（The Heap Data Structure）</a>中的介绍。</p>\n<p>堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质：</p>\n<ol>\n<li>在最大堆中，所有的父节点均大于其孩子节点；</li>\n<li>在最小堆中，所有的父节点均小于其孩子节点。</li>\n</ol>\n<p>最大堆和最小堆的图示如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/max-min-heap.png\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>对于给定的未排序的数组，从小到大进行排序，堆排序都必须首先将该数组转换为最大堆结构。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-1.png\"></p>\n<p>对上述数组通过筛选所有父节点进行转换，此时使用sift-down方式，最终转换后的结果如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-2.png\"></p>\n<p>对应的数组为：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-3.png\"></p>\n<p>由于单次sift-down操作的时间复杂度为O(log n)，因此构建一个堆的整体时间复杂度为O(n log n)。</p>\n<p>堆排序是将数组元素进行升序排序。因为在最大堆中，最大的元素通常位于根节点，因此可以<strong>使用索引0的元素和索引n-1的元素进行直接交换</strong>。这样交换后，数组最后的元素便位于正确地位置，但是此时堆已经不符合堆的规则了。下一步对新的根节点元素进行sift-down操作，使得堆成立。（此时进行sift-down的时候，需要将排除部分已排序好的元素）</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-4.png\"></p>\n<p>对元素5进行sift-down之后，新的根节点为原始堆中第二大的元素21，此时同样和末尾元素6进行交换，交换后继续对新的根节点6进行sift-down操作，再次使得堆成立。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-5.png\"></p>\n<p>上述过程其实形成了一种模式，堆排序简单直接，每次交换首末两个元素，较大的元素依次被交换到数组的后面，多次交换完成后，数组变成了从小到大的顺序，也完成了堆排序。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/20/eg-6.png\"></p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><p>堆排序的实现是基于堆的数据结构基础上的，是对堆结构的一种功能扩展。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Heap &#123;\n    \n    mutating func siftSown(from index: Int, upTo size: Int) &#123;\n           var parent &#x3D; index\n           while true &#123;\n               let left &#x3D; leftChildIndex(ofParentAt: parent)\n               let right &#x3D; rightChildIndex(ofParentAt: parent)\n               var candidate &#x3D; parent\n               \n               if left &lt; size &amp;&amp; sort(elements[left], elements[candidate]) &#123;\n                   candidate &#x3D; left\n               &#125;\n               if right &lt; size &amp;&amp; sort(elements[right], elements[candidate]) &#123;\n                   candidate &#x3D; right\n               &#125;\n               if candidate &#x3D;&#x3D; parent &#123;\n                   return\n               &#125;\n               elements.swapAt(parent, candidate)\n               parent &#x3D; candidate\n           &#125;\n       &#125;\n    \n    func sorted() -&gt; [Element] &#123;\n        var heap &#x3D; Heap(sort: sort, elements: elements)\n        for index in heap.elements.indices.reversed() &#123;\n            heap.elements.swapAt(0, index)\n            heap.siftSown(from: 0, upTo: index)\n        &#125;\n        return heap.elements\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要对原来Heap结构的sift-down方法进行改造，增加参数size以标记当前集合的大小。</p></blockquote>\n<p>堆排序算法工作流程如下：</p>\n<ol>\n<li>首先对原有堆进行一个拷贝。因为在堆排序堆元素集合进行排序后，原有的堆结构将不再成立，为了保持堆结构成立，这里使用其拷贝进行排序；</li>\n<li>从集合末尾元素开始，对集合进行遍历；</li>\n<li>交换首末位置的元素，此次交换后，最大的元素将位于集合的末尾；</li>\n<li>交换元素位置后，堆结构已经不成立了，因此需要使用sift-down方法对集合重新调整，已重生合法的堆结构，完成后，新的根节点将是原集合中第二大的元素。重复第三步即可。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;heap sort&quot;) &#123;\n    let heap &#x3D; Heap(sort: &gt;, elements: [6, 12, 2, 26, 8, 18, 21, 9, 5])\n    print(heap.sorted())\n&#125;\n\n&#x2F;*\n---Example of heap sort---\n[2, 5, 6, 8, 9, 12, 18, 21, 26]\n*&#x2F;</code></pre>\n\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>堆排序的最佳、最差和平均性能都是O(n log n)。因为必须遍历整个列表一次，并且每次交换元素时，都必须执行向下筛选sift-down操作，这是一个O(log n)操作。</p>\n<p>堆排序也不是一种稳定的排序，因为它取决于元素如何布局和放入堆中。例如，如果您正在根据一副纸牌的等级对其进行堆排序，您可能会看到它们的套件相对于原始纸牌的顺序发生了变化。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>堆排序利用最大堆数据结构对数组中的元素进行排序。</li>\n</ul>\n","text":"**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看\\#15\\ 堆数据结构（The Heap Data Structure）中的介绍。 堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质： 在最...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#19\\ 基数排序（Radix Sort）","uid":"1eff6ae9330e74043f153497674d46df","slug":"2020-02-01-Data-Structures-&-Algorithms-in-Swift-19","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2020-02-01-Data-Structures-&-Algorithms-in-Swift-19.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/19/cover.jpg","text":"**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。 为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。 示例为了进行基数排序的工作方式，假设需要对如下的集合进行排序： var array &#...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"iOS内存管理小结","uid":"efbbbd2e93d0b6b1478e69b9a9de5940","slug":"2020-06-17-iOS-memory-manage-tips","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2020-06-17-iOS-memory-manage-tips.json","keywords":null,"cover":null,"text":"内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}