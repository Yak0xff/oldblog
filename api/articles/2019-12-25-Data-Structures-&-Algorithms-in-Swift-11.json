{"title":"\\#11\\ 二叉搜索树","uid":"1c072eaf9d0ebbcfebf6203a3cb43879","slug":"2019-12-25-Data-Structures-&-Algorithms-in-Swift-11","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-25-Data-Structures-&-Algorithms-in-Swift-11.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/11/cover.jpg","content":"<p>二叉搜索树又称为二叉查找树（BST），是一种支持快速查找、插入和删除操作的树结构，例如下方的决策树，其中选择一方而放弃另一方的所有可能性，从而将问题减半。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/bst-decision-tree-demo.png\"></p>\n<p>在决策树中，一旦做出了决定并选择了某个分支，便不能回头，在选择的分支上一直查找直到叶子节点，得到最终决定。二叉搜索树在上一文中的二叉树的基础上增加了以下两个规则：</p>\n<ol>\n<li>左节点的值必须小于父节点的值；</li>\n<li>同样的，右节点的值必须大于等于其父节点的值。</li>\n</ol>\n<p>二叉搜索树使用这两个规则可避免执行不必要的检查，其查找、插入和删除的平均时间复杂度为O(log n)，比线性结构快的多。</p>\n<h2 id=\"Array-vs-BST\"><a href=\"#Array-vs-BST\" class=\"headerlink\" title=\"Array vs. BST\"></a>Array vs. BST</h2><p>例如有如下的两种结构的集合：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/array-vs-bst.png\"></p>\n<p>上面的结构为数组，下方的为二叉搜索树结构。</p>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><p>对于未排序的数组来说，搜索只能从开头到结尾，例如搜索元素105。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/array-search-105.png\"></p>\n<p>这也是为什么*array.contains(:)*操作为O(n)的原因。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/bst-search-105.png\"></p>\n<p>使用二叉搜索树的数据结构，搜索同样的元素105，简单且高效的多。因为搜索算法每次访问节点的时候，都会遵循如下两个原则：</p>\n<ol>\n<li>如果目标搜索值小于当前节点的值，那么目标搜索值一定在当前节点的左树中；</li>\n<li>如果目标搜索值大于当前节点的值，那么目标搜索值一定在当前节点的右树中。</li>\n</ol>\n<p>通过BST的这些搜索原则，可以避免一些数据项检查，减半搜索空间，这也是BST中搜索算法的时间复杂度为O(log n)的原因。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>对于数组来说，如果要插入一个元素，需要将插入位置之后的所有元素向后移动一个位置，这也是为什么对于数组的插入算法，时间复杂度为O(n)的原因。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/array-insertion.png\"></p>\n<p>而对于二叉搜索树来说，插入一个新的元素，相对舒服的多。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/bst-insertion.png\"></p>\n<p>由于二叉搜索树的规则，小于当前节点元素值的节点一定在当前节点的左树或左节点，因此插入一个新的元素的时候，可以减少一半的检查时间。例如上图中，在现有的二叉搜索树中插入新的元素1。二叉搜索树的插入算法，时间复杂度应该为O(log n)。</p>\n<h3 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h3><p>和插入类似，数组的元素移除同样需要移动删除目标元素之后的所有元素的位置，因此其时间复杂度依然是O(n)。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/array-removal.png\"></p>\n<p>对于二叉搜索树来说，会由两种情况，当删除的节点是叶子节点的时候，相对较为简单，但是如果待删除的节点有子节点的时候，相对要进行一些复杂的管理工作。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/bst-removal.png\"></p>\n<h2 id=\"结构与算法实现\"><a href=\"#结构与算法实现\" class=\"headerlink\" title=\"结构与算法实现\"></a>结构与算法实现</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public struct BinarySearchTree&lt;Element: Comparable&gt; &#123;\n    public private(set) var root: BinaryNode&lt;Element&gt;?\n    public init() &#123;&#125;\n&#125;\n\nextension BinarySearchTree: CustomStringConvertible &#123;\n    public var description: String &#123;\n        guard let root &#x3D; root else &#123;\n            return &quot;Empty tree&quot;\n        &#125;\n        return String(describing: root)\n    &#125;\n&#125;</code></pre>\n\n<p>二叉搜索树的本质是二叉树，因此在二叉搜索树的内部，定义的节点类型为BinaryNode，并且二叉搜索树中的元素时可比较的。</p>\n<h3 id=\"插入算法\"><a href=\"#插入算法\" class=\"headerlink\" title=\"插入算法\"></a>插入算法</h3><p>二叉树的基本准则是：</p>\n<ol>\n<li>左节点的值必须小于父节点的值；</li>\n<li>同样的，右节点的值必须大于等于其父节点的值。</li>\n</ol>\n<p>依据这两个准则，即可实现二叉搜索树的插入算法：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension BinarySearchTree &#123;\n    public mutating func insert(_ value: Element) &#123;\n        root &#x3D; insert(from: root, value: value)\n    &#125;\n    \n    private func insert(from node: BinaryNode&lt;Element&gt;?, value: Element) -&gt; BinaryNode&lt;Element&gt; &#123;\n        &#x2F;&#x2F; 如果是空的树，则直接使用当前值构建一个节点返回\n        guard let node &#x3D; node else &#123;\n            return BinaryNode(value: value)\n        &#125;\n        &#x2F;&#x2F; 插入到左树\n        if value &lt; node.value &#123;\n            node.leftChild &#x3D; insert(from: node.leftChild, value: value)\n        &#125; else &#123;\n            &#x2F;&#x2F; 插入到右树\n            node.rightChild &#x3D; insert(from: node.rightChild, value: value)\n        &#125;\n        return node\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;building a BST&quot;) &#123;\n    var bst &#x3D; BinarySearchTree&lt;Int&gt;()\n    for i in 0 ..&lt; 5 &#123;\n        bst.insert(i)\n    &#125;\n    print(bst)\n&#125;\n\n&#x2F;*\n---Example of building a BST---\n   ┌──4\n  ┌──3\n  │ └──nil \n ┌──2\n │ └──nil \n┌──1\n│ └──nil \n0\n└──nil \n*&#x2F;</code></pre>\n\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/unbalanced-bst.png\"></p>\n<p>然而，对于上述构建的BST，貌似是不平衡的，二叉树的节点均在根节点的右树上，而理想的状态应该是上图中右侧的部分。如果此时插入新的元素5，则会出现如下情况：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/unbalanced-bst-insertion.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>解决方案是构建自平衡树的结构，自平衡树这里不进行详述。</p></blockquote>\n<p>为了防止树结构的不平衡，这里仅仅使用最为笨重的方式构建一个平衡的二叉树。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var exampleTree: BinarySearchTree&lt;Int&gt; &#123;\n    var bst &#x3D; BinarySearchTree&lt;Int&gt;()\n    bst.insert(3)\n    bst.insert(1)\n    bst.insert(4)\n    bst.insert(0)\n    bst.insert(2)\n    bst.insert(5)\n    return bst\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;building a balanced BST&quot;) &#123;\n    print(exampleTree)\n&#125;\n\n&#x2F;*\n---Example of building a balanced BST---\n ┌──5\n┌──4\n│ └──nil \n3\n│ ┌──2\n└──1\n └──0\n*&#x2F;</code></pre>\n\n<h3 id=\"元素搜索\"><a href=\"#元素搜索\" class=\"headerlink\" title=\"元素搜索\"></a>元素搜索</h3><p>二叉搜索树元素的搜索需要遍历二叉树的各个节点，因此可以使用上一文中实现的二叉树相关遍历算法 — 有序、前序和后序。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension BinarySearchTree &#123;\n    public func contains(_ value: Element) -&gt; Bool &#123;\n        guard let root &#x3D; root else &#123;\n            return false\n        &#125;\n        var found &#x3D; false\n        root.traverseInOrder &#123;\n            if $0 &#x3D;&#x3D; value &#123;\n                found &#x3D; true\n            &#125;\n        &#125;\n        return found\n    &#125;\n&#125;</code></pre>\n\n<p>例如搜索上述二叉搜索树中是否包含元素5：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;finding a node&quot;) &#123;\n    if exampleTree.contains(5) &#123;\n        print(&quot;Found 5!&quot;)\n    &#125; else &#123;\n      print(&quot;Couldn&#39;t find 5&quot;)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of finding a node---\nFound 5!\n*&#x2F;</code></pre>\n\n<p>这里的元素搜索算法使用了有序遍历的方法，因此其时间复杂度也为O(n)。但是该复杂度的搜索算法存在可优化的空间，由于二叉搜索树有左节点小于父节点，右节点大于父节点的特性，因此在元素搜索的时候，可以利用该属性减少搜索检查的范围，进一步优化搜索耗时等。</p>\n<p>优化元素的搜索算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func containsOpt(_ value: Element) -&gt; Bool &#123;\n    var current &#x3D; root\n    while let node &#x3D; current &#123;\n        if node.value &#x3D;&#x3D; value &#123;\n            return true\n        &#125;\n        \n        if value &lt; node.value &#123;\n            current &#x3D; node.leftChild\n        &#125; else &#123;\n            current &#x3D; node.rightChild\n        &#125;\n    &#125;\n    return false\n&#125;</code></pre>\n\n<p>优化的算法时间复杂度为O(log n)。</p>\n<h3 id=\"移除元素\"><a href=\"#移除元素\" class=\"headerlink\" title=\"移除元素\"></a>移除元素</h3><p>二叉搜索树元素的移除相对元素的搜索和插入复杂一些，有如下三种场景需要考虑：</p>\n<p><strong>Case 1：叶子节点</strong></p>\n<p>对于待删除的元素所在的节点为叶子节点时，是最为简单直接的场景，直接分类该节点和其父节点的链接即可。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-leaf-node.png\"></p>\n<p><strong>Case 2：有一个子节点的节点</strong></p>\n<p>当待删除的元素所在的节点拥有一个子节点的时候，不仅仅要删除该节点，还需要将该节点的字节点和树的其余节点进行重新链接，一般情况下，会重新和删除节点的原始父节点进行链接。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-one-node.png\"></p>\n<p><strong>Case 3：有两个子节点的节点</strong></p>\n<p>当待删除节点拥有两个子节点的时候，删除操作相对较为复杂一点。例如下图二叉搜索树，想要删除的元素为25：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-1.png\"></p>\n<p>如果只是简单的删除节点25，如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-2.png\"></p>\n<p>此时虽然删除掉了节点25，但是带来了另一个问题。当删除掉节点25之后，会出现两个需要重建链接的节点12和37，此时原节点25的父节点却只有一个子节点的空间，如果如上图那样建立链接的话，会导致该二叉搜索树不成立。为了解决此问题，需要对节点的链接进行交换，使得删除节点后的二叉搜索树依然成立。</p>\n<p>方法就是，删除拥有两个节点的节点之后，使用其右侧子树中最小的节点替换删除的节点，根据二叉搜索树的特点，最小的节点即为右侧子树中最左的节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-3.png\"></p>\n<p>这样进行节点交换之后，二叉搜索树依然有效，因为新节点是右子树中的最小节点，所以右子树中的所有节点仍将大于或等于新节点。并且由于新节点来自右子树，因此左子树中的所有节点都小于新节点。</p>\n<p><strong>算法实现</strong></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private extension BinaryNode &#123;\n    var min: BinaryNode &#123;\n        return leftChild?.min ?? self\n    &#125;\n&#125;\n\nextension BinarySearchTree &#123;\n    public mutating func remove(_ value: Element) &#123;\n        root &#x3D; remove(node: root, value: value)\n    &#125;\n    \n    private func remove(node: BinaryNode&lt;Element&gt;?, value: Element) -&gt; BinaryNode&lt;Element&gt;? &#123;\n        guard let node &#x3D; node else &#123;\n            return nil\n        &#125;\n        \n        if value &#x3D;&#x3D; node.value &#123;\n            if node.leftChild &#x3D;&#x3D; nil &amp;&amp; node.rightChild &#x3D;&#x3D; nil &#123;\n                return nil\n            &#125;\n            if node.leftChild &#x3D;&#x3D; nil &#123;\n                return node.rightChild\n            &#125;\n            if node.rightChild &#x3D;&#x3D; nil &#123;\n                return node.leftChild\n            &#125;\n            node.value &#x3D; node.rightChild!.min.value\n            node.rightChild &#x3D; remove(node: node.rightChild, value: node.value)\n        &#125; else if value &lt; node.value &#123;\n            node.leftChild &#x3D; remove(node: node.leftChild, value: value)\n        &#125; else &#123;\n            node.rightChild &#x3D; remove(node: node.rightChild, value: value)\n        &#125;\n        return node\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;removing a node&quot;) &#123;\n    var tree &#x3D; exampleTree\n    print(&quot;Tree before removal:&quot;)\n    print(tree)\n    tree.remove(3)\n    print(&quot;Tree after removing root:&quot;)\n    print(tree)\n&#125;\n\n&#x2F;*\n---Example of removing a node---\nTree before removal:\n ┌──5\n┌──4\n│ └──nil \n3\n│ ┌──2\n└──1\n └──0\n\nTree after removing root:\n┌──5\n4\n│ ┌──2\n└──1\n └──0\n*&#x2F;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>二叉搜索树是一种存储排序数据的数据结构；</li>\n<li>二叉搜索树的插入、移除和查找算法的平均时间复杂度为O(log n)；</li>\n<li>当树不平衡的时候，时间复杂度会降低到O(n)。</li>\n</ul>\n","text":"二叉搜索树又称为二叉查找树（BST），是一种支持快速查找、插入和删除操作的树结构，例如下方的决策树，其中选择一方而放弃另一方的所有可能性，从而将问题减半。 在决策树中，一旦做出了决定并选择了某个分支，便不能回头，在选择的分支上一直查找直到叶子节点，得到最终决定。二叉搜索树在上一文...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Array-vs-BST\"><span class=\"toc-text\">Array vs. BST</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">搜索</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">插入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4\"><span class=\"toc-text\">移除</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">结构与算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">插入算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%B4%A0%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">元素搜索</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">移除元素</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#10\\ 二叉树及其有序、前序和后序遍历","uid":"0e0f6f0242f4e4a48493fd0fe5fe0ab7","slug":"2019-12-25-Data-Structures-&-Algorithms-in-Swift-10","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-25-Data-Structures-&-Algorithms-in-Swift-10.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/10/cover.jpg","text":"在上一文中认识了一般树结构，其每一个节点可能会有多个子节点。二叉树也是树型结构，只不过其每一个节点最多只有两个节点，通常称为左节点和右节点。 二叉树的Swift实现首先定义二叉树的基本属性，如下： public class BinaryNode&lt;Element&gt; &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#12\\ 自平衡二叉搜索树（AVL Trees）","uid":"4085c41c06b2e3ba45ef163b731b2c76","slug":"2019-12-27-Data-Structures-&-Algorithms-in-Swift-12","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-27-Data-Structures-&-Algorithms-in-Swift-12.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/12/cover.png","text":"在上文中，已经了解二叉搜索树的O(log n)性能特征，但是当二叉搜索树节点删除中，可能会出现不平衡的树，并降低树的性能到O(n)。这一文的内容将学习另一种改进了的二叉搜索树 — 自平衡二叉搜索树。 1962年，Georgy Adelson-Velsky和Evgenii Land...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}