{"title":"\\#10\\ 二叉树及其有序、前序和后序遍历","uid":"0e0f6f0242f4e4a48493fd0fe5fe0ab7","slug":"2019-12-25-Data-Structures-&-Algorithms-in-Swift-10","date":"2023-06-02T06:31:47.188Z","updated":"2023-06-02T06:31:47.188Z","comments":true,"path":"api/articles/2019-12-25-Data-Structures-&-Algorithms-in-Swift-10.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/10/cover.jpg","content":"<p>在上一文中认识了一般树结构，其每一个节点可能会有多个子节点。二叉树也是树型结构，只不过其每一个节点最多只有两个节点，通常称为<strong>左节点</strong>和<strong>右节点</strong>。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/10/binary-tree.png\"></p>\n<h2 id=\"二叉树的Swift实现\"><a href=\"#二叉树的Swift实现\" class=\"headerlink\" title=\"二叉树的Swift实现\"></a>二叉树的Swift实现</h2><p>首先定义二叉树的基本属性，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class BinaryNode&lt;Element&gt; &#123;\n    public var value: Element\n    public var leftChild: BinaryNode?\n    public var rightChild: BinaryNode?\n    \n    public init(_ value: Element) &#123;\n        self.value &#x3D; value\n    &#125;\n&#125;</code></pre>\n\n<p>有了二叉树的基本属性之后，就可以定义一颗二叉树了，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var tree: BinaryNode&lt;Int&gt; &#x3D; &#123;\n    let zero &#x3D; BinaryNode(value: 0)\n    let one &#x3D; BinaryNode(value: 1)\n    let five &#x3D; BinaryNode(value: 5)\n    let seven &#x3D; BinaryNode(value: 7)\n    let eight &#x3D; BinaryNode(value: 8)\n    let nine &#x3D; BinaryNode(value: 9)\n    \n    seven.leftChild &#x3D; one\n    one.leftChild &#x3D; zero\n    one.rightChild &#x3D; five\n    seven.rightChild &#x3D; nine\n    nine.leftChild &#x3D; eight\n    \n    return seven\n&#125;()</code></pre>\n\n<p>该二叉树的形态即如下图：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/10/binary-tree-demo.png\"></p>\n<h2 id=\"二叉树图\"><a href=\"#二叉树图\" class=\"headerlink\" title=\"二叉树图\"></a>二叉树图</h2><p>数据结构的图像化能够帮助进一步理解数据结构，为了能够更加清晰的查看二叉树的树形结构，这里我们构造一个打印函数，以在Console中打印出二叉树的树形结构图。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension BinaryNode: CustomStringConvertible &#123;\n    public var description: String &#123;\n        return diagram(for: self)\n    &#125;\n    \n    private func diagram(for node: BinaryNode?,\n                         _ top: String &#x3D; &quot;&quot;,\n                         _ root: String &#x3D; &quot;&quot;,\n                         _ bottom: String &#x3D; &quot;&quot;) -&gt; String &#123;\n        guard let node &#x3D; node else &#123;\n            return root + &quot;nil \\n&quot;\n        &#125;\n        if node.leftChild &#x3D;&#x3D; nil &amp;&amp; node.rightChild &#x3D;&#x3D; nil &#123;\n            return root + &quot;\\(node.value)\\n&quot;\n        &#125;\n        return diagram(for: node.rightChild,\n                       top + &quot; &quot;,\n                       top + &quot;┌──&quot;,\n                       top + &quot;│ &quot;) + root + &quot;\\(node.value)\\n&quot; + diagram(for: node.leftChild,\n                                                                          bottom + &quot;│ &quot;,\n                                                                          bottom + &quot;└──&quot;,\n                                                                          bottom + &quot; &quot;)\n    &#125;\n&#125;</code></pre>\n\n<p>然后对前面构建的二叉树进行打印，输出如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">---Example of tree diagram---\n ┌──nil \n┌──9\n│ └──8\n7\n│ ┌──5\n└──1\n └──0</code></pre>\n\n<h2 id=\"遍历算法\"><a href=\"#遍历算法\" class=\"headerlink\" title=\"遍历算法\"></a>遍历算法</h2><p>在一般树中学习了深度优先和广度优先两种树型结构的遍历算法，经过小小的改动后，这两种遍历算法同样适用于二叉树的遍历。但是在二叉树结构中，更加关注的是另外三种遍历算法：有序、前序和后序遍历。</p>\n<h3 id=\"有序遍历\"><a href=\"#有序遍历\" class=\"headerlink\" title=\"有序遍历\"></a>有序遍历</h3><p>有序遍历按照如下的顺序遍历节点：</p>\n<ol>\n<li>如果当前节点有左节点，则递归访问该节点的子节点；</li>\n<li>然后访问当前节点</li>\n<li>如果当前节点有有节点，则继续递归遍历该节点的子节点。</li>\n</ol>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/10/in-order.png\"></p>\n<p>算法实现如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension BinaryNode &#123;\n    public func traverseInOrder(visit: (Element) -&gt; Void) &#123;\n        leftChild?.traverseInOrder(visit: visit)\n        visit(value)\n        rightChild?.traverseInOrder(visit: visit)\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;in-order traversal&quot;) &#123;\n    tree.traverseInOrder &#123;\n        print($0)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of in-order traversal---\n0\n1\n5\n7\n8\n9\n*&#x2F;</code></pre>\n\n<h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><p>前序遍历总是先访问当前节点，然后递归遍历左节点和有节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/10/pre-order.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func traversePreOrder(visit: (Element) -&gt; Void) &#123;\n    visit(value)\n    leftChild?.traversePreOrder(visit: visit)\n    rightChild?.traversePreOrder(visit: visit)\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;pre-order traversal&quot;) &#123;\n    tree.traversePreOrder &#123;\n        print($0)\n    &#125;\n&#125;\n&#x2F;*\n---Example of ore-order traversal---\n7\n1\n0\n5\n9\n8\n*&#x2F;</code></pre>\n\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>后序遍历总是先递归访问当前节点的左节点和右节点，然后在访问当前节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/10/post-order.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func traversePostOrder(visit: (Element) -&gt; Void) &#123;\n    leftChild?.traversePostOrder(visit: visit)\n    rightChild?.traversePostOrder(visit: visit)\n    visit(value)\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;post-order traversal&quot;) &#123;\n    tree.traversePostOrder &#123;\n        print($0)\n    &#125;\n&#125;\n&#x2F;*\n---Example of post-order traversal---\n0\n5\n1\n8\n9\n7\n*&#x2F;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>二叉树数据结构是其他树形数据结构的基础，很多类型的树例如二叉搜索树、AVL树等，都以二叉树为基础，并在其上增加插入和删除等操作行为；</li>\n<li>有序、前序和后序并不仅仅针对二叉树非常重要，在其他的树形结构中，这些遍历算法依然有效且重要。</li>\n</ul>\n","text":"在上一文中认识了一般树结构，其每一个节点可能会有多个子节点。二叉树也是树型结构，只不过其每一个节点最多只有两个节点，通常称为左节点和右节点。 二叉树的Swift实现首先定义二叉树的基本属性，如下： public class BinaryNode&lt;Element&gt; &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Swift%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">二叉树的Swift实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE\"><span class=\"toc-text\">二叉树图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">遍历算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">有序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">前序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">后序遍历</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"浅谈iOS架构模式","uid":"7587d0e7690fa9850e8d9b7745fb8f05","slug":"2019-09-29-ios-architecture-patterns","date":"2023-06-02T06:31:47.188Z","updated":"2023-06-02T06:31:47.188Z","comments":true,"path":"api/articles/2019-09-29-ios-architecture-patterns.json","keywords":null,"cover":"/images/iOSArchitecturePatterns/cover.jpeg","text":"每一个软件开发者在开始学习软件开发的时候，可能都不清楚软件的架构设计是什么样的，仅仅是依靠前人的方式进行代码开发的，至少本人是这样的。慢慢熟悉了软件开发后，对于软件代码如何更加合理的进行组织，以前的开发为什么是那样进行组织的便有了有些理解。其实这一切都是软件的架构模式。 对于iO...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"基于MFCC的语音数据特征提取概述","uid":"c98e5d32ae2d193866c4e1eb0feb55b3","slug":"2018-07-24-speech-recognation-mfcc","date":"2023-06-02T06:31:47.184Z","updated":"2023-06-02T06:31:47.184Z","comments":true,"path":"api/articles/2018-07-24-speech-recognation-mfcc.json","keywords":null,"cover":"/images/speech-recognition/audio_draw.png","text":"1. 概述语音是人类之间沟通交流的最直接也是最快捷方便的一种手段，而实现人类与计算机之间畅通无阻的语音交流，一直是人类追求的一个梦想。 伴随着移动智能设备的普及，各家移动设备的厂家也开始在自家的设备上集成了语音识别系统，像Apple Siri、Microsoft Cortana、...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":10,"path":"api/categories/机器学习.json"}],"tags":[{"name":"机器学习 MFCC","slug":"机器学习-MFCC","count":1,"path":"api/tags/机器学习-MFCC.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}