{"title":"如何进行 Git 仓库瘦身","uid":"f0b7ed12bc36c7022d00f8d1ca004b00","slug":"2022-05-20-how-to-reduce-git","date":"2023-05-18T06:26:15.536Z","updated":"2023-05-18T06:26:15.536Z","comments":true,"path":"api/articles/2022-05-20-how-to-reduce-git.json","keywords":null,"cover":"https://raw.githubusercontent.com/zycslog/assets-pro/main/yancy-min-842ofHC6MaI-unsplash.jpg","content":"<p>对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题：</p>\n<ul>\n<li>理解从 Git 的历史记录中删除文件</li>\n<li>使用 BFG 重写历史记录</li>\n<li>可选，使用 git filter-branch 重写历史记录</li>\n<li>垃圾回收</li>\n</ul>\n<p>请格外小心…..</p>\n<p>本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 <a href=\"http://stackoverflow.com/questions/3959924/whats-the-difference-between-git-clone-mirror-and-git-clone-bare\">–mirror</a> 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了您的仓库的关键元素，那么你可以通过备份的仓库来恢复。</p>\n<p>请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是一个不错的主意。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。</p>\n<h3 id=\"理解从-Git-的历史记录中删除文件\"><a href=\"#理解从-Git-的历史记录中删除文件\" class=\"headerlink\" title=\"理解从  Git  的历史记录中删除文件\"></a><strong>理解从</strong>  <strong>Git</strong>  <strong>的历史记录中删除文件</strong></h3><p>回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：</p>\n<ul>\n<li>从你的项目的当前的文件树中删除该文件;</li>\n<li>从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;</li>\n<li>删除指向旧的提交历史记录的所有 <a href=\"http://git-scm.com/docs/git-reflog\">reflog</a> 历史记录;</li>\n<li>重新整理仓库，使用 <a href=\"http://git-scm.com/docs/git-gc\">git gc</a> 对现在没有使用的数据进行垃圾回收。</li>\n</ul>\n<span id=\"more\"></span>\n\n<p>Git 的 &quot;gc&quot;（垃圾回收）将通过你的任何一个分支或者标签来删除仓库中所有的实际没用的或者以某种方式引用的数据。为了使其发挥作用，我们需要重写包含不需要的文件的所有 Git 仓库历史记录，仓库将不再引用它—— git gc 将会丢弃所有没用的数据。</p>\n<p>重写存储库历史是一个棘手的事情，因为每个提交都依赖它的父提交，所以任何一个很小的改变都会改变它的每一个随后的提交的提交 ID。有两个自动化的工具可以做到这：</p>\n<ol>\n<li><a href=\"http://rtyley.github.io/bfg-repo-cleaner/\">BFG Repo Cleaner</a> 快速、简单且易于使用，需要 Java 6 或者更高版本的运行环境。</li>\n<li><a href=\"http://git-scm.com/docs/git-filter-branch\">git filter-branch</a> 功能强大、配置麻烦，用于大于仓库时速度较慢，是核心 Git 套件的一部分。</li>\n</ol>\n<p>切记，当你重写历史记录后，无论你是使用 BFG 还是使用 filter-branch，你都需要删除指向旧的历史记录的 reflog 条目，最后运行垃圾回收器来删除旧的数据。</p>\n<h3 id=\"使用-BFG-重写历史记录\"><a href=\"#使用-BFG-重写历史记录\" class=\"headerlink\" title=\"使用  BFG  重写历史记录\"></a><strong>使用</strong>  <strong>BFG</strong>  <strong>重写历史记录</strong></h3><p><a href=\"http://rtyley.github.io/bfg-repo-cleaner/\">BFG</a> 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：–strip-blobs-bigger-than</p>\n<ol>\n<li>$ java -jar bfg.jar –strip-blobs-than 100M</li>\n</ol>\n<p>大小超过 100MB 的任何文件（不包含在你最近的提交中的文件——因为 BFG <a href=\"http://rtyley.github.io/bfg-repo-cleaner/#protected-commits\">默认会保护你的最新提交的内容</a>）将会从你的 Git 仓库的历史记录中删除。如果你想用名字来指明具体的文件，你也可以这样做：</p>\n<ol>\n<li>$ java -jar bfg.jar –delete-files *.mp4</li>\n</ol>\n<p>BFG 的速度要比 git filter-branch 快 <a href=\"https://www.youtube.com/watch?v=Ir4IHzPhJuI\">10-1000 倍</a>，而且通常更容易使用——查看完整的<a href=\"http://rtyley.github.io/bfg-repo-cleaner/#usage\">使用说明</a>和<a href=\"http://rtyley.github.io/bfg-repo-cleaner/#examples\">示例</a>获取更多细节。</p>\n<h3 id=\"或者，使用-git-filter-branch-来重写历史记录\"><a href=\"#或者，使用-git-filter-branch-来重写历史记录\" class=\"headerlink\" title=\"或者，使用  git filter-branch  来重写历史记录\"></a><strong>或者，使用</strong>  <strong>git filter-branch</strong>  <strong>来重写历史记录</strong></h3><p>filter-branch 命令可以对 Git 仓库的历史记录重写，就像 BFG 一样，但是过程更慢和更手动化。如果你不知道这些大文件在哪里，那么你第一步就需要找到它们：</p>\n<h4 id=\"手动查看你-Git-仓库中的大文件\"><a href=\"#手动查看你-Git-仓库中的大文件\" class=\"headerlink\" title=\"手动查看你  Git  仓库中的大文件\"></a><strong>手动查看你</strong>  <strong>Git</strong>  <strong>仓库中的大文件</strong></h4><p><a href=\"https://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/\">Antony Stubbs</a> 写了一个可以很好地完成这个功能的 BASH 脚本。该脚本可以检查你的包文件的内容并列出大文件。在你开始删除文件之前，请执行以下操作获取并安装此脚本：</p>\n<p>1、 <a href=\"https://confluence.atlassian.com/bitbucket/files/321848291/321979854/1/1360604134990/git_find_big.sh\">下载脚本</a>到你的本地的系统。</p>\n<p>2、 将它放在一个可以访问你的 Git 仓库的易于找到的位置。</p>\n<p>3、 让脚本成为可执行文件：</p>\n<ol>\n<li>$ chmod 777 git_find_big.sh</li>\n</ol>\n<p>4、 克隆仓库到你本地系统。</p>\n<p>5、 改变当前目录到你的仓库根目录。</p>\n<p>6、 手动运行 Git 垃圾回收器：</p>\n<ol>\n<li>git gc –auto</li>\n</ol>\n<p>7、 找出 .git 文件夹的大小</p>\n<ol>\n<li>$ du -hs .git&#x2F;objects</li>\n<li>45M .git&#x2F;objects</li>\n</ol>\n<p>注意文件大小，以便随后参考。</p>\n<p>8、 运行 git_find_big.sh 脚本来列出你的仓库中的大文件。</p>\n<ol>\n<li>$ git_find_big.sh</li>\n<li>All sizes are in kB&#39;s. The pack column is the size of the object, compressed, inside the pack file.</li>\n<li>size pack SHA                                       location</li>\n<li>592   580   e3117f48bc305dd1f5ae0df3419a0ce2d9617336 media&#x2F;img&#x2F;emojis.jar</li>\n<li>550   169   b594a7f59ba7ba9daebb20447a87ea4357874f43 media&#x2F;js&#x2F;aui&#x2F;aui-dependencies.jar</li>\n<li>518   514   22f7f9a84905aaec019dae9ea1279a9450277130 media&#x2F;images&#x2F;screenshots&#x2F;issue-tracker-wiki.jar</li>\n<li>337   92   1fd8ac97c9fecf74ba6246eacef8288e89b4bff5 media&#x2F;js&#x2F;lib&#x2F;bundle.js</li>\n<li>240   239   e0c26d9959bd583e5ef32b6206fc8abe5fea8624 media&#x2F;img&#x2F;featuretour&#x2F;heroshot.png</li>\n</ol>\n<p>大文件都是 JAR 文件，包的大小列是最相关的。aui-dependencies.jar 被压缩到 169kb，但是 emojis.jar 只压缩到 500kb。emojis.jar 就是一个待删除的对象。</p>\n<h4 id=\"运行-filter-branch\"><a href=\"#运行-filter-branch\" class=\"headerlink\" title=\"运行  filter-branch\"></a><strong>运行</strong>  <strong>filter-branch</strong></h4><p>你可以给这个命令传递一个用于重写 Git 索引的过滤器。例如，一个过滤器可以可以将每个检索的提交删除。这个用法如下：</p>\n<ol>\n<li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch  _pathname_ &#39; commitHASH</li>\n</ol>\n<p>–index-filter 选项可以修改仓库的索引，–cached 选项从索引中而不是磁盘来删除文件。这样会更快，因为你不需要在运行这个过滤器前检查每个修订版本。git rm 中的 ignore-unmatch 选项可以防止在尝试移走不存在的文件 pathname 的时候命令失败。通过指定一个提交 HASH 值，你可以从每个以这个 HASH 值开始的提交中删除pathname。要从开始处删除，你可以省略这个参数或者指定为 HEAD。</p>\n<p>如果你的大文件在不同的分支，你将需要通过名字来删除每个文件。如果大文件都在一个单独的分支，你可以直接删除这个分支本身。</p>\n<h4 id=\"选项-1-：通过文件名删除文件\"><a href=\"#选项-1-：通过文件名删除文件\" class=\"headerlink\" title=\"选项  1** ：通过文件名删除文件**\"></a><strong>选项</strong>  <strong>1</strong>** ：通过文件名删除文件**</h4><p>使用下面的步骤来删除大文件：</p>\n<p>1、 使用下面的命令来删除你找到的第一个大文件：</p>\n<ol>\n<li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch filename&#39; HEAD</li>\n</ol>\n<p>2、 重复步骤 1 找到剩下的每个大文件。</p>\n<p>3、 在你的仓库里更新引用。 filter-branch 会为你原先的引用创建一个 refs&#x2F;original&#x2F; 下的备份。一旦你确信已经删除了正确的文件，你可以运行下面的命令来删除备份文件，同时可以让垃圾回收器回收大的对象：</p>\n<ol>\n<li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch filename&#39; HEAD</li>\n</ol>\n<h4 id=\"选项-2-：直接删除分支\"><a href=\"#选项-2-：直接删除分支\" class=\"headerlink\" title=\"选项  2** ：直接删除分支**\"></a><strong>选项</strong>  <strong>2</strong>** ：直接删除分支**</h4><p>如果你所有的大文件都在一个单独的分支上，你可以直接删除这个分支。删除这个分支会自动删除所有的引用。</p>\n<p>1、 删除分支。</p>\n<ol>\n<li>$ git branch -D PROJ567bugfix</li>\n</ol>\n<p>2、 从后面的分支中删除所有的 reflog 引用。</p>\n<h3 id=\"对不用的数据垃圾回收\"><a href=\"#对不用的数据垃圾回收\" class=\"headerlink\" title=\"对不用的数据垃圾回收\"></a><strong>对不用的数据垃圾回收</strong></h3><p>1、 删除从现在到后面的所有 reflog 引用（除非你明确地只在一个分支上操作）。</p>\n<ol>\n<li>$ git reflog expire –expire&#x3D;now –all</li>\n</ol>\n<p>2、 通过运行垃圾回收器和删除旧的对象重新打包仓库。</p>\n<ol>\n<li>$ git gc –prune&#x3D;now</li>\n</ol>\n<p>3、 把你所有的修改推送回仓库。</p>\n<ol>\n<li>$ git push –all –force</li>\n</ol>\n<p>4、 确保你所有的标签也是当前最新的:</p>\n<ol>\n<li>$ git push –tags –force</li>\n</ol>\n","text":"对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题： 理解从 Git 的历史记录中删除文件 使用 BFG 重写历史记录 可选，使用 git ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识","slug":"开发知识","count":3,"path":"api/tags/开发知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E4%BB%8E-Git-%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">理解从  Git  的历史记录中删除文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-BFG-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">使用  BFG  重写历史记录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%96%E8%80%85%EF%BC%8C%E4%BD%BF%E7%94%A8-git-filter-branch-%E6%9D%A5%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">或者，使用  git filter-branch  来重写历史记录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E6%9F%A5%E7%9C%8B%E4%BD%A0-Git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">手动查看你  Git  仓库中的大文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C-filter-branch\"><span class=\"toc-text\">运行  filter-branch</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E9%A1%B9-1-%EF%BC%9A%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E5%90%8D%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">选项  1** ：通过文件名删除文件**</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E9%A1%B9-2-%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF\"><span class=\"toc-text\">选项  2** ：直接删除分支**</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%B8%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">对不用的数据垃圾回收</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"《实现模式》读书小记","uid":"e82075038d4d045b9b352d5ca62ff95f","slug":"2022-05-01-iOS-implementation-patterns-tips","date":"2023-05-18T06:26:15.536Z","updated":"2023-05-18T06:26:15.536Z","comments":true,"path":"api/articles/2022-05-01-iOS-implementation-patterns-tips.json","keywords":null,"cover":"/images/cover/2022-05-01-iOS-implementation-patterns-tips.jpg","text":"《实现模式》一书作者Kent Beck，软件开发方法学的泰山北斗，是最早研究软件开发模式和重构方法论的先导者之一，是敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人。该书是一本关于如何撰写代码的书。本书中的模式，是基于 Kent 对现存代码的阅读以及他自己的编程习惯而形成...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"读书小记","slug":"读书小记","count":2,"path":"api/categories/读书小记.json"}],"tags":[{"name":"读书小记","slug":"读书小记","count":2,"path":"api/tags/读书小记.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"再议Objective-C 2.0 中的 Runtime","uid":"93feab5362ca8ea100621030ee9dd628","slug":"2022-05-25-runtime-again","date":"2023-05-18T06:26:15.536Z","updated":"2023-05-18T06:26:15.536Z","comments":true,"path":"api/articles/2022-05-25-runtime-again.json","keywords":null,"cover":"/images/cover/2022-05-25-runtime-again.jpg","text":"绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码: struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识","slug":"开发知识","count":3,"path":"api/tags/开发知识.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}