{"title":"\\#4\\ 单向链表的Swift实现","uid":"433ae949273168d0f60f97343029174d","slug":"2019-12-03-Data-Structures-&-Algorithms-in-Swift-04","date":"2023-05-24T14:00:53.651Z","updated":"2023-05-24T14:00:53.651Z","comments":true,"path":"api/articles/2019-12-03-Data-Structures-&-Algorithms-in-Swift-04.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/4/cover.jpg","content":"<p><strong>链表</strong>是一种线性的、单向的数据结构，不同于数组连续的内存存储，链表中的元素在内存是独立的对象。链表具有以下理论优势：</p>\n<ul>\n<li>元素插入和从列表头部删除元素的时间恒定；</li>\n<li>具有可靠的性能特性。</li>\n</ul>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/a-linked-list.png\"></p>\n<p>如上图所示，链表的结构是一个<strong>节点</strong>结构。节点具有两个功能：</p>\n<ol>\n<li>保存值；</li>\n<li>保存下一个节点的指针。<strong>nil</strong>节点表示链表的结尾。</li>\n</ol>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/linked-list-node.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>链表分为<strong>单向链表</strong>和<strong>双向链表</strong>，双向链表的每个阶段，还具有指向前一个节点的指针。</p></blockquote>\n<p>在本文中，将学习链表的Swift实现，以及关于链表的一些通用的操作。将了解每个操作的时间复杂性，并实现一个整洁的小 Swift 功能，称为<strong>写入时复制</strong>。</p>\n<h2 id=\"节点（Node）\"><a href=\"#节点（Node）\" class=\"headerlink\" title=\"节点（Node）\"></a>节点（Node）</h2><p>首先我们需要定义<strong>节点</strong>的数据结构，使用Xcode的新建Playground，并在<strong>Sources</strong>目录下新建<strong>Node.swift</strong>文件。根据对节点功能的了解，在Node的结构中，应该有至少两个数据属性，一个用来存储，一个用于指向，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public class Node&lt;Value&gt; &#123;\n    public var value: Value\n    public var next: Node?\n    \n    public init(value: Value, next: Node? &#x3D; nil) &#123;\n        self.value &#x3D; value\n        self.next &#x3D; next\n    &#125;\n&#125;\n\nextension Node: CustomStringConvertible &#123;\n    public var description: String &#123;\n        guard let next &#x3D; next else &#123;\n            return &quot;\\(value)&quot;\n        &#125;\n        return &quot;\\(value) -&gt;&quot; + String(describing: next) + &quot; &quot;\n    &#125;\n&#125;</code></pre>\n\n<p>以上便定义好了一个单向链表的节点结构。为了能够在测试方便，可以添加如下工具函数：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>新建helper.swift文件，编写工具类函数：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func example(of description: String, action: () -&gt; Void) &#123;\n print(&quot;---Example of \\(description)---&quot;)\n action()\n print()\n&gt;&#125;</code></pre></blockquote>\n<p>此时，回到主Playground，定义一个链表结构的示例，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;creating and linking nodes&quot;) &#123;\n    let node1 &#x3D; Node(value: 1)\n    let node2 &#x3D; Node(value: 2)\n    let node3 &#x3D; Node(value: 3)\n    \n    node1.next &#x3D; node2\n    node2.next &#x3D; node3\n    \n    print(node1)\n&#125;\n\n&#x2F;&#x2F; ---Example of creating and linking nodes---\n&#x2F;&#x2F; 1 -&gt;2 -&gt;3 </code></pre>\n\n<p>示例所定义的链表结构，图示如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/demo-linked-list-1.png\"></p>\n<p>一个单向链表，包含了三个值分别为1、2、3的节点。这样的链表定义似乎已经完成了，但是当节点的数量上升后，我们就需要每个节点都进行赋值和指针指向的定义，显然这样的方式即笨重且不灵活。就实用性而言，目前的结构还需要进行优化，缓解此问题的常用方法是构建一个专门管理Node节点对象的链表结构，如下：</p>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p><strong>Sources</strong>目录下新建<strong>LinkedList.swift</strong>文件。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public struct LinkedList&lt;Value&gt; &#123;\n    public var head: Node&lt;Value&gt;?\n    public var tail: Node&lt;Value&gt;?\n    \n    public init() &#123;&#125;\n    \n    public var isEmpty: Bool &#123;\n        return head &#x3D;&#x3D; nil\n    &#125;\n&#125;\n\n\nextension LinkedList: CustomStringConvertible &#123;\n    public var description: String &#123;\n        guard let head &#x3D; head else &#123;\n            return &quot;Empty Linked List&quot;\n        &#125;\n        return String(describing: head)\n    &#125;\n&#125;</code></pre>\n\n<p>该结构下的链表具有<strong>头</strong>和<strong>尾</strong>概念，分别指向链表的第一个节点和末尾节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/head-tail.png\"></p>\n<h2 id=\"向链表中添加值\"><a href=\"#向链表中添加值\" class=\"headerlink\" title=\"向链表中添加值\"></a>向链表中添加值</h2><p>有了节点管理形式的链表后，需要为该链表<strong>添加</strong>头结点，<strong>追加</strong>末尾节点，以及<strong>插入</strong>节点，因此需要定义三个通用的方法：</p>\n<ul>\n<li><strong>push</strong>：在链表的头部添加值；</li>\n<li><strong>append</strong>：在链表的末尾添加值；</li>\n<li>**insert(after:)**：在链表的特定节点后添加值。</li>\n</ul>\n<h3 id=\"push操作\"><a href=\"#push操作\" class=\"headerlink\" title=\"push操作\"></a>push操作</h3><p>在链表的头部位置添加值，也就是<strong>头插法</strong>，其时间复杂度为**O(1)**。其实现较为简单，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public mutating func push(_ value: Value) &#123;\n    head &#x3D; Node(value: value, next:head)\n    if tail &#x3D;&#x3D; nil &#123;\n        tail &#x3D; head\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>struct</strong> 和 <strong>enum</strong> 的值在内部是不能修改的, 如果要修改需要在方法前面添加 <strong>mutating</strong> 修饰符</p></blockquote>\n<p>对于一个空的链表来说，头节点也是尾节点，采用头插法插入值后，每次插入的值都会放在链表的头部。</p>\n<p>回到主Playground，进行链表的<strong>push</strong>操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;push&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(list)\n&#125;\n\n&#x2F;&#x2F; ---Example of push---\n&#x2F;&#x2F; 1 -&gt;2 -&gt;3 </code></pre>\n\n<h3 id=\"append操作\"><a href=\"#append操作\" class=\"headerlink\" title=\"append操作\"></a>append操作</h3><p>在链表的尾部位置添加值，也就是<strong>尾插法</strong>，其时间复杂度**O(1)**。实现如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public mutating func append(_ value: Value) &#123;\n    &#x2F;&#x2F; 如果链表尾空，使用push操作新建节点，更新链表的头节点和尾节点。\n    guard !isEmpty else &#123;\n        push(value)\n        return\n    &#125;\n    &#x2F;&#x2F; 创建一个新节点，赋值为尾部节点的下一个节点，将节点连接起来。\n    tail!.next &#x3D; Node(value: value)\n    &#x2F;&#x2F; 因为是尾部拼接节点，所以新的节点将成为尾部节点\n    tail &#x3D; tail!.next\n&#125;</code></pre>\n\n<p>回到主Playground，进行链表的<strong>append</strong>操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;append&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.append(1)\n    list.append(2)\n    list.append(3)\n    \n    print(list)\n&#125;\n\n&#x2F;&#x2F; ---Example of append---\n&#x2F;&#x2F; 1 -&gt;2 -&gt;3 </code></pre>\n\n<h3 id=\"insert-after-操作\"><a href=\"#insert-after-操作\" class=\"headerlink\" title=\"insert(after:) 操作\"></a>insert(after:) 操作</h3><p><strong>插入</strong>操作是指在链表的特定节点位置，插入一个新的节点。该操作需要两个步骤完成：</p>\n<ol>\n<li>查找特定节点</li>\n<li>插入新的节点</li>\n</ol>\n<p>首先需要根据给定的索引，查找特定的节点：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func node(at index: Int) -&gt; Node&lt;Value&gt;? &#123;\n    &#x2F;&#x2F; 由于只能从头部遍历链表，因此先创建当前节点和索引的引用\n    var currentNode &#x3D; head\n    var currentIndex &#x3D; 0\n    &#x2F;&#x2F; 使用while循环，将引用向下移动到列表中，直到达到所需的索引。 空列表或越界索引将导致nil返回值。\n    while currentNode !&#x3D; nil &amp;&amp; currentIndex &lt; index &#123;\n        currentNode &#x3D; currentNode!.next\n        currentIndex +&#x3D; 1\n    &#125;\n        \n    return currentNode\n&#125;</code></pre>\n\n<p>这里需要说明的是，我们针对的是<strong>单向链表</strong>，链表节点的访问只能从头节点依次向后访问，在实现节点的查找时，必须使用迭代的方式进行节点遍历。</p>\n<p>找到了特定索引的节点后，接下来就是插入一个新的节点了。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">@discardableResult\npublic mutating func insert(_ value: Value, after node: Node&lt;Value&gt;) -&gt; Node&lt;Value&gt; &#123;\n    &#x2F;&#x2F; 如果要插入新节点的位置是尾节点，则直接使用append操作，添加新的尾节点\n    guard tail !&#x3D;&#x3D; node else &#123;\n        append(value)\n        return tail!\n    &#125;\n        \n    &#x2F;&#x2F; 否则新建节点，并赋值为查找节点的下一个节点，将节点进行连接\n    node.next &#x3D; Node(value: value, next: node.next)\n        \n    return node.next!\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>@discardableResult</strong>指的是接口的调用者忽略此方法的返回值，而编译器不会向上和向下跳过警告。</p></blockquote>\n<p>完成逻辑编写后，回到主Playground，进行链表的**insert(after:)**操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;inserting at a particular index&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Before inserting: \\(list)&quot;)\n    \n    let middleNode &#x3D; list.node(at: 1)!\n    for _ in 1 ... 3 &#123;\n        list.insert(-1, after: middleNode)\n    &#125;\n    print(&quot;After inserting: \\(list)&quot;)\n&#125;\n\n&#x2F;&#x2F; ---Example of inserting at a particular index---\n&#x2F;&#x2F; Before inserting: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; After inserting: 1 -&gt;2 -&gt;-1 -&gt;-1 -&gt;-1 -&gt;3 </code></pre>\n\n<h3 id=\"性能分析-—-时间复杂度\"><a href=\"#性能分析-—-时间复杂度\" class=\"headerlink\" title=\"性能分析 — 时间复杂度\"></a>性能分析 — 时间复杂度</h3><p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/performance-analysis.png\"></p>\n<h2 id=\"从链表中删除值\"><a href=\"#从链表中删除值\" class=\"headerlink\" title=\"从链表中删除值\"></a>从链表中删除值</h2><p>对应向链表中添加值，从链表中删除值同样对应三个主要的方法：</p>\n<ol>\n<li><strong>pop</strong>：从链表头部删除值；</li>\n<li><strong>removeLast</strong>：从链表尾部删除值；</li>\n<li>**remove(after:)**：删除指定位置的节点值。</li>\n</ol>\n<h3 id=\"pop-操作\"><a href=\"#pop-操作\" class=\"headerlink\" title=\"pop 操作\"></a>pop 操作</h3><p>从链表的头部直接删除值的操作和给链表头部添加值的操作<strong>push</strong>有点类似，其算法也相对简单，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">@discardableResult\npublic mutating func pop() -&gt; Value &#123;\n    defer &#123;\n        head &#x3D; head?.next\n        if isEmpty &#123;\n            tail &#x3D; nil\n        &#125;\n    &#125;\n    return head?.value\n&#125;</code></pre>\n\n<p><strong>pop</strong>方法的返回值是被删除的节点的值。该结果是一个<strong>可选值</strong>，因为链表有可能是一个空链表。</p>\n<p>将原链表的头节点向前移动一个位置即可，在<strong>ARC</strong>模式下，系统内存会在头部节点无任何引用的时候，自动清理原链表的头节点资源。如果移动头节点后，链表是一个空链表，需要将尾部节点重新置空。</p>\n<p>回到主Playground，尝试进行链表的<strong>pop</strong>操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;pop&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Before popping list: \\(list)&quot;)\n    let poppedValue &#x3D; list.pop()\n    print(&quot;After popping list: \\(list)&quot;)\n    print(&quot;Popped value: &quot; + String(describing: poppedValue))\n&#125;\n\n&#x2F;&#x2F; ---Example of pop---\n&#x2F;&#x2F; Before popping list: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; After popping list: 2 -&gt;3 \n&#x2F;&#x2F; Popped value: Optional(1)</code></pre>\n\n<h3 id=\"removeLast-操作\"><a href=\"#removeLast-操作\" class=\"headerlink\" title=\"removeLast 操作\"></a>removeLast 操作</h3><p>删除链表的尾部节点相对比较复杂，算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">@discardableResult\npublic mutating func removeLast() -&gt; Value? &#123;\n    &#x2F;&#x2F; 如果链表的头节点为nil，无节点移除，故返回nil\n    &#x2F;&#x2F; 这里也可以直接使用isEmpty进行判断\n    guard let head &#x3D; head else &#123;\n        return nil\n    &#125;\n    &#x2F;&#x2F; 如果链表仅有一个节点，头节点也是末尾节点，因此直接使用pop()操作即可\n    guard head.next !&#x3D; nil else &#123;\n        return pop()\n    &#125;\n    &#x2F;&#x2F; 创建节点的引用\n    var prev &#x3D; head\n    var current &#x3D; head\n    &#x2F;&#x2F; 遍历链表节点，直到当前节点的下一个节点为nil，则表明当前节点已经是末尾节点了\n    while let next &#x3D; current.next &#123;\n        prev &#x3D; current\n        current &#x3D; next\n    &#125;\n    &#x2F;&#x2F; 将当前节点的前一个节点的next指针值为nil，并更新末尾节点\n    prev.next &#x3D; nil\n    tail &#x3D; prev\n    &#x2F;&#x2F; 返回被删除的值\n    return current.value\n&#125;</code></pre>\n\n\n<p>回到主Playground，尝试进行链表的<strong>removeLast</strong>操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;removing the last node&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    \n    print(&quot;Before remove last node: \\(list)&quot;)\n    let removedValue &#x3D; list.removeLast()\n    print(&quot;After remove last node: \\(list)&quot;)\n    print(&quot;Removed value: &quot; + String(describing: removedValue))\n&#125;\n\n&#x2F;&#x2F; ---Example of removing the last node---\n&#x2F;&#x2F; Before remove last node: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; After remove last node: 1 -&gt;2 \n&#x2F;&#x2F; Removed value: Optional(3)</code></pre>\n\n<p><strong>removeLast</strong>操作需要遍历整个链表，因此其时间复杂度为**O(n)**。</p>\n<h3 id=\"remove-after-操作\"><a href=\"#remove-after-操作\" class=\"headerlink\" title=\"remove(after:) 操作\"></a>remove(after:) 操作</h3><p>**remove(after:)<strong>操作类似</strong>insert(after:)**，首先需要找到特定位置的节点，然后执行删除操作。算法过程如下图：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/remove-at.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">@discardableResult\npublic mutating func remove(after node: Node&lt;Value&gt;) -&gt; Value? &#123;\n    defer &#123;\n        if node.next &#x3D;&#x3D;&#x3D; tail &#123;\n            tail &#x3D; node\n        &#125;\n        node.next &#x3D; node.next?.next\n    &#125;\n    return node.next?.value\n&#125;</code></pre>\n\n<p>节点的引用清理放在<strong>defer</strong>区块内，当删除的节点无任何引用的时候，系统内存会自动清理其占用资源。</p>\n<p>回到主Playground，尝试进行链表的**remove(after:)**操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;removing a node after a particular node&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    \n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Before removing at particular index: \\(list)&quot;)\n    let index &#x3D; 1\n    let node &#x3D; list.node(at: index - 1)!\n    let removedValue &#x3D; list.remove(after: node)\n    print(&quot;After removing at index \\(index): \\(list)&quot;)\n    print(&quot;Removed value: &quot; + String(describing: removedValue))\n&#125;\n\n&#x2F;&#x2F; ---Example of removing a node after a particular node---\n&#x2F;&#x2F; Before removing at particular index: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; After removing at index 1: 1 -&gt;3 \n&#x2F;&#x2F; Removed value: Optional(2)</code></pre>\n\n<h3 id=\"性能分析-—-时间复杂度-1\"><a href=\"#性能分析-—-时间复杂度-1\" class=\"headerlink\" title=\"性能分析 — 时间复杂度\"></a>性能分析 — 时间复杂度</h3><p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/4/remove-performance-analysis.png\"></p>\n<h2 id=\"阶段性总结\"><a href=\"#阶段性总结\" class=\"headerlink\" title=\"阶段性总结\"></a>阶段性总结</h2><p>支持关于LinkedList的定义和基本操作就完成了，对于链表而言，单向链表只是一个开始，这里没有涉及到双向链表。</p>\n<ul>\n<li>链表是有一个个节点链接而成的，每个节点具有保存值和下一个节点索引的属性；</li>\n<li>链表中节点值的添加涉及头尾和指定位置，在指定位置插入需要两步操作，首先找到给定位置的节点，然后删除其后的一个节点并重建链接；</li>\n<li>链表中节点值的删除同样涉及头尾和指定位置；</li>\n<li>在进行链表的操作时，需要时刻记住在必须的时机更新链表的节点指向指针，保证链表的链接性。</li>\n</ul>\n","text":"链表是一种线性的、单向的数据结构，不同于数组连续的内存存储，链表中的元素在内存是独立的对象。链表具有以下理论优势： 元素插入和从列表头部删除元素的时间恒定； 具有可靠的性能特性。 如上图所示，链表的结构是一个节点结构。节点具有两个功能： 保存值； 保存下一个节点的指针。nil节点...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89\"><span class=\"toc-text\">节点（Node）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%80%BC\"><span class=\"toc-text\">向链表中添加值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#push%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">push操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#append%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">append操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#insert-after-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">insert(after:) 操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E2%80%94-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">性能分析 — 时间复杂度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%BC\"><span class=\"toc-text\">从链表中删除值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pop-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">pop 操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#removeLast-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">removeLast 操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#remove-after-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">remove(after:) 操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E2%80%94-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1\"><span class=\"toc-text\">性能分析 — 时间复杂度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">阶段性总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#3\\ 关于时间复杂度和大O符号","uid":"ed1a650be4c536b8ed544197809a0599","slug":"2019-12-02-Data-Structures-&-Algorithms-in-Swift-03","date":"2023-05-24T14:00:53.651Z","updated":"2023-05-24T14:00:53.651Z","comments":true,"path":"api/articles/2019-12-02-Data-Structures-&-Algorithms-in-Swift-03.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/3/cover.jpg","text":"算法复杂度的衡量问题在软件开发的诞生早起就已经被提出来，并且有多个方面具体的问题。例如，从系统的架构来看，可伸缩性的架构设计和算法实现，应用程序是如何在数据特征增加的情况下被合理有效地激活的；从数据库的角度来看，数据库的处理能力是否能够应对越来越多的数据和用户行为等。 对于算法而...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#5\\ Linked List && Swift Collection Protocol","uid":"e7521306a70b406b8e5f7047760055b6","slug":"2019-12-04-Data-Structures-&-Algorithms-in-Swift-05","date":"2023-05-24T14:00:53.651Z","updated":"2023-05-24T14:00:53.651Z","comments":true,"path":"api/articles/2019-12-04-Data-Structures-&-Algorithms-in-Swift-05.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/5/cover.jpg","text":"在Swift标准库（Swift standard library）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}