{"title":"\\#14\\ 二分查找（Binary Search）","uid":"193dbb4158d425c4c3d00532baa1c670","slug":"2020-01-07-Data-Structures-&-Algorithms-in-Swift-14","date":"2023-05-14T05:45:19.936Z","updated":"2023-05-14T05:45:19.936Z","comments":true,"path":"api/articles/2020-01-07-Data-Structures-&-Algorithms-in-Swift-14.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/14/cover.jpg","content":"<p>二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足：</p>\n<ul>\n<li>集合必须是在恒定的时间内执行索引操作，意味着集合必须是<strong>RandomAccessCollection</strong>类型的；</li>\n<li>集合必须是<strong>sorted</strong>的。</li>\n</ul>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>在Swift标准库中的Array结构中，通过*index(of:)*来实现线性的元素搜索，也就是意味着Array中的元素搜索需要遍历整个数组。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在Swift 5中<em>index(of:)</em> 已经废弃，取而代之的为*firstIndex(of:)*。</p></blockquote>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/14/array-linear-search.png\"></p>\n<p>而二分查找则是在已排序的数组上，以不同的处理方式进行元素的搜索。例如下图所示，在已排序的数组中搜索元素31：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-31.png\"></p>\n<p>和一般的数组元素查找不同的是，二分查找按照如下的步骤进行元素的搜索：</p>\n<p><strong>Step 1：找到中间位置的索引</strong></p>\n<p>二分查找第一步，便是找到集合中间位置，这一步非常直接，通过集合的元素总数进行计算获得：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/14/step-1-find-middle-index.png\"></p>\n<p><strong>Step 2：检查中间索引位置的元素</strong></p>\n<p>下一步则是检查中间位置的元素，如果和预检索的元素匹配，则直接返回索引，如果不相符，则继续第三步，继续检索元素。</p>\n<p><strong>Step 3：递归进行二分查找</strong></p>\n<p>最后一步是递归调用二分查找，但是这时，仅仅需要检索的是集合中间索引左侧或者右侧，而非整个集合。当中间位置的元素小于预检索的元素时，则检索中间位置右侧，反之，检索中间位置左侧。</p>\n<p>二分查找每一步的检索之后，都会减少一半的检索范围，这样大大的减小了检索的时间耗时，提高检索效率。</p>\n<p>在上述例子中，为了检索元素31，由于中间位置的元素为22，小于预检索的元素31，因此将继续检索中间位置元素22的右侧元素：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-22-right.png\"></p>\n<p>二分查找从大的方面来说，每一次的元素检索只需要三步，直到无法将集合再次进行左右划分或者找到元素为止。</p>\n<p>二分查找的时间复杂度为O(log n)。</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><p>首先定义二分查找使用范围，以及集合元素的可比较性：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public extension RandomAccessCollection where Element: Comparable &#123;\n    func binarySearch(for value: Element, in range: Range&lt;Index&gt;? &#x3D; nil) -&gt; Index? &#123;\n        \n    &#125;\n&#125;</code></pre>\n\n\n<ul>\n<li>由于二分查找仅仅适用于集合类型<strong>RandomAccessCollection</strong>，并且其中的元素需要可比较的特性，因此针对该类型进行扩展并设定元素可比较性，并添加二分查找方法的定义；</li>\n<li>二分查找在运行过程中需要递归调用，因此在函数定义中要执行每一次递归的范围，参数<strong>range</strong>是可选类型，在首次进行二分查找的时候，不需要传入<strong>range</strong>，故其默认值为<strong>nil</strong>。</li>\n</ul>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public extension RandomAccessCollection where Element: Comparable &#123;\n    func binarySearch(for value: Element, in range: Range&lt;Index&gt;? &#x3D; nil) -&gt; Index?&#123;\n        \n        let range &#x3D; range ?? startIndex ..&lt; endIndex\n\n        guard range.lowerBound &lt; range.upperBound else &#123;\n            return nil\n        &#125;\n        \n        let size &#x3D; distance(from: range.lowerBound, to: range.upperBound)\n        let middle &#x3D; index(range.lowerBound, offsetBy: size &#x2F; 2)\n        \n        if self[middle] &#x3D;&#x3D; value &#123;\n            return middle\n        &#125; else if self[middle] &gt; value &#123;\n            return binarySearch(for: value, in: range.lowerBound ..&lt; middle)\n        &#125; else &#123;\n            return binarySearch(for: value, in: middle ..&lt; range.upperBound)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>首先检查<em>range</em>是否为<em>nil</em>，如果为<em>nil</em>，则获取集合完整的索引范围<em>startIndex ..&lt; endIndex</em>；</li>\n<li>检查集合是否为空，这里的检查方式是通过集合的最小边界和最大边界进行判断集合是否至少有一个元素，否则直接返回<em>nil</em>；</li>\n<li>通过集合的最小边界和最大边界，获取集合的长度，之后使用*index(offsetBy:)*方法获取集合中间位置的索引；</li>\n<li>如果中间位置的元素就是我们要查找的元素，则直接返回中间位置索引；</li>\n<li>如果中间位置的元素大于预查找的元素，则说明预查找元素在集合中间位置的左侧，递归调用*binarySearch(for:range:)*方法，继续查找；</li>\n<li>如果中间位置的元素小于预查找的元素，则说明预查找的元素在集合中间位置的右侧，递归调用*binarySearch(for:range:)*方法，继续查找。</li>\n</ul>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;binary search&quot;) &#123;\n    let array &#x3D; [1, 5, 15, 17, 19, 22, 24, 31, 105, 150]\n    \n    let search31 &#x3D; array.firstIndex(of: 31)\n    let binarySearch31 &#x3D; array.binarySearch(for: 31)\n    \n    print(&quot;index(of:): \\(String(describing: search31))&quot;)\n    print(&quot;binarySearch(of:): \\(String(describing: binarySearch31))&quot;)\n&#125;\n\n&#x2F;*\n---Example of binary search---\nindex(of:): Optional(7)\nbinarySearch(of:): Optional(7)\n*&#x2F;</code></pre>\n\n<p>二分查找是一种强大的算法，每当某些场景下，集合的元素时已排序的情况下，都可以考虑使用二分查找的方法。另外，如果遇到的问题似乎进行元素搜索需要O(n^2)的时间复杂度，可以考虑先对集合进行前期的排序，然后采用二分查找的方法将时间复杂度降低到O(n log n)的程度。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>二分查找仅仅对已排序的集合有效；</li>\n<li>有时候，对集合进行排序后，再使用二分查找是有益的；</li>\n<li>对于集合本身，其<em>sorted</em>方法的时间复杂度为O(n)，而二分查找的时间复杂度为O(log n)，对于大型数据集合来说，二分查找的可伸缩性更好。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二分查找思想典型的应用场景就是在Bug原因的追查上面，当面对一个无从知晓其最终的引发点的时候，可以尝试使用二分查找的思想，分段校验代码的执行结果，逐步缩小Bug追查的范围，提高Bug原因的追查效率等。</p></blockquote>\n","text":"二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足： 集合必须是在恒定的时间内执行索引操作，意味着集合必须是RandomAccessCollection类型的； 集...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#13\\ 字典树（Tries Tree）","uid":"7c0350b0f98d8a7fc26f52b6c73852fb","slug":"2020-01-06-Data-Structures-&-Algorithms-in-Swift-13","date":"2023-05-14T05:45:19.936Z","updated":"2023-05-14T05:45:19.936Z","comments":true,"path":"api/articles/2020-01-06-Data-Structures-&-Algorithms-in-Swift-13.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/13/cover.jpg","text":"Tries 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#15\\ 堆数据结构（The Heap Data Structure）","uid":"4a00ba60db357b4d5652c54beb6b2091","slug":"2020-01-10-Data-Structures-&-Algorithms-in-Swift-15","date":"2023-05-14T05:45:19.936Z","updated":"2023-05-14T05:45:19.936Z","comments":true,"path":"api/articles/2020-01-10-Data-Structures-&-Algorithms-in-Swift-15.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/15/cover.jpg","text":"想必抓娃娃机如今没有人不知道其实什么了，抓娃娃机的爪子总是那么的难以控制，总是看起来容易的机会却难以如愿。抓抓机的爪子其实就工作在一个堆数据结构之上，爪子每次抓的几乎都是那边一堆玩具最上面的那一个，只有这样机会才会更大一些。 在本文中将学习关于堆（Heap）的基础知识，包含如何创...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}