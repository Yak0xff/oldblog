{"title":"再议Objective-C 2.0 中的 Runtime","uid":"93feab5362ca8ea100621030ee9dd628","slug":"2022-05-25-runtime-again","date":"2023-05-14T05:45:19.940Z","updated":"2023-05-14T05:45:19.940Z","comments":true,"path":"api/articles/2022-05-25-runtime-again.json","keywords":null,"cover":"/images/cover/2022-05-25-runtime-again.jpg","content":"<p>绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct objc_class &#123;\n    Class isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n&#125; OBJC2_UNAVAILABLE;</code></pre>\n\n<p>可以看到其中保存了类的实例变量，方法列表等信息。</p>\n<p>不知道有多少读者思考过 <code>OBJC2_UNAVAILABLE</code> 意味着什么。其实早在 2006 年，苹果在 WWDC 大会上就发布了 <a href=\"https://en.wikipedia.org/wiki/Objective-C#Objective-C_2.0\">Objective-C 2.0</a>，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。</p>\n<p>这意味着上述代码，以及任何带有 <code>OBJC2_UNAVAILABLE</code> 标记的内容，都已经在 2006 年就永远的告别了我们，只停留在历史的文档中。</p>\n<h2 id=\"Category-的原理\"><a href=\"#Category-的原理\" class=\"headerlink\" title=\"Category 的原理\"></a>Category 的原理</h2><p>虽然上述代码已经过时，但仍具备一定的参考意义，比如 <code>methodLists</code> 作为一个二级指针，其中每个元素都是一个数组，数组中的每个元素则是一个方法。</p>\n<p>接下来就介绍一下 category 的工作原理，在美团的技术博客 <a href=\"http://tech.meituan.com/DiveIntoCategory.html\">深入理解Objective-C：Category</a> 中已经有了非常详细的解释，然而可能由于时间问题，其中的不少内容已经过时，我根据目前最新的版本(objc-680) 做一些简单的分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>首先 runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">void _objc_init(void)\n└──const char *map_2_images(...)\n    └──const char *map_images_nolock(...)\n        └──void _read_images(header_info **hList, uint32_t hCount)</code></pre>\n\n<p>以上四个方法可以理解为 runtime 的初始化过程，我们暂且不深究。在 <code>_read_images</code> 方法中有如下代码:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">if (cat-&gt;classMethods  ||  cat-&gt;protocols  \n    &#x2F;* ||  cat-&gt;classProperties *&#x2F;) &#123;\n    addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);\n    if (cls-&gt;ISA()-&gt;isRealized()) &#123;\n        remethodizeClass(cls-&gt;ISA());\n    &#125;\n&#125;</code></pre>\n\n<p>根据注释可见苹果曾经计划利用 category 来添加属性。在 <code>addUnattachedCategoryForClass</code> 方法中会找到当前类的所有 category，然后在 <code>remethodizeClass</code> 真正的去做处理。不过到目前为止还没有接触到相关的 category 处理，我们继续沿着调用栈向下走:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">void _read_images(header_info **hList, uint32_t hCount)\n└──static void remethodizeClass(Class cls)\n    └──static void attachCategories(Class cls, category_list *cats, bool flush_caches)</code></pre>\n\n<p>这里的 <code>attachCategories</code> 就是处理 category 的核心所在，不过在阅读这段代码之前，我们有必要先熟悉一下相关的数据结构。</p>\n<h3 id=\"Category-相关的数据结构\"><a href=\"#Category-相关的数据结构\" class=\"headerlink\" title=\"Category 相关的数据结构\"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义，我只列出了其中成员变量:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct category_t &#123;\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n&#125;;</code></pre>\n\n<p>可见一个 category 持有了一个 <code>method_list_t</code> 类型的数组，<code>method_list_t</code> 又继承自 <code>entsize_list_tt</code>，这是一种泛型容器:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, 0x3&gt; &#123;\n    &#x2F;&#x2F; 成员变量和方法\n&#125;;\n\ntemplate &lt;typename Element, typename List, uint32_t FlagMask&gt;\nstruct entsize_list_tt &#123;\n    uint32_t entsizeAndFlags;\n    uint32_t count;\n    Element first;\n&#125;;</code></pre>\n\n<p>这里的 <code>entsize_list_tt</code> 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。 <code>Element</code> 表示元素类型，<code>List</code> 用于指定容器类型，最后一个参数为标记位。</p>\n<p>虽然这段代码实现比较复杂，但仍可了解到 <code>method_list_t</code> 是一个存储 <code>method_t</code> 类型元素的容器。<code>method_t</code> 结构体的定义如下:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct method_t &#123;\n    SEL name;\n    const char *types;\n    IMP imp;\n&#125;;</code></pre>\n\n<p>最后，我们还有一个结构体 <code>category_list</code> 用来存储所有的 category，它的定义如下:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct locstamped_category_list_t &#123;\n    uint32_t count;\n    locstamped_category_t list[0];\n&#125;;\nstruct locstamped_category_t &#123;\n    category_t *cat;\n    struct header_info *hi;\n&#125;;\ntypedef locstamped_category_list_t category_list;</code></pre>\n\n<p>除了标记存储的 category 的数量外，<code>locstamped_category_list_t</code> 结构体还声明了一个长度为零的数组，这其实是 C99 中的一种写法，允许我们在运行期动态的申请内存。</p>\n<p>以上就是相关的数据结构，只要了解到这个程度就可以继续读源码了。</p>\n<h3 id=\"处理-Category\"><a href=\"#处理-Category\" class=\"headerlink\" title=\"处理 Category\"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 <code>attachCategories</code> 的简化版代码:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123;\n    if (!cats) return;\n    bool isMeta &#x3D; cls-&gt;isMetaClass();\n\n    method_list_t **mlists &#x3D; (method_list_t **)malloc(cats-&gt;count * sizeof(*mlists));\n    &#x2F;&#x2F; Count backwards through cats to get newest categories first\n    int mcount &#x3D; 0;\n    int i &#x3D; cats-&gt;count;\n    while (i--) &#123;\n        auto&amp; entry &#x3D; cats-&gt;list[i];\n\n        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);\n        if (mlist) &#123;\n            mlists[mcount++] &#x3D; mlist;\n        &#125;\n    &#125;\n\n    auto rw &#x3D; cls-&gt;data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw-&gt;methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);\n&#125;</code></pre>\n\n<p>首先，通过 while 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。</p>\n<p>换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。这句话比较绕，但你可以把 <code>mlists</code> 理解为文章开头所说，旧版本的 <code>objc_method_list **methodLists</code>。</p>\n<p>在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">auto rw &#x3D; cls-&gt;data();\nrw-&gt;methods.attachLists(mlists, mcount);</code></pre>\n\n<p>这两行代码读不懂是必然的，因为在 Objective-C 2.0 时代，对象的内存布局已经发生了一些变化。我们需要先了解对象的布局模型才能理解这段代码。</p>\n<h2 id=\"Objective-C-2-0-对象布局模型\"><a href=\"#Objective-C-2-0-对象布局模型\" class=\"headerlink\" title=\"Objective-C 2.0 对象布局模型\"></a>Objective-C 2.0 对象布局模型</h2><h3 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h3><p>相信读到这里的大部分读者都学习过文章开头所说的对象布局模型，因此在这一部分，我们采用类比的方法，来看看 Objective-C 2.0 下发生了哪些改变。</p>\n<p>首先，<code>Class</code> 和 <code>id</code> 指针的定义并没有发生改变，他们一个指向类对应的结构体，一个指向对象对应的结构体:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">&#x2F;&#x2F; objc.h\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;</code></pre>\n\n<p>比较有意思的一点是，<code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct objc_object &#123;\n    Class isa  OBJC_ISA_AVAILABILITY;\n&#125;;\n\nstruct objc_class : objc_object &#123;\n    Class superclass;\n    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable\n    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags\n\n    class_rw_t *data() &#123; \n        return bits.data();\n    &#125;\n&#125;;</code></pre>\n\n<p>这一点也很容易理解，早在 Objective-C 1.0 时代，我们就知道一个对象的结构体只有 <code>isa</code> 指针，指向它所属的类。而类的结构体也有 <code>isa</code> 指针指向它的元类。因此让类结构体继承自对象结构体就很容易理解了。 </p>\n<p>可见 Objective-C 1.0 的布局模型中，<code>cache</code> 和 <code>super_class</code> 被原封不动的移过来了，而剩下的属性则似乎消失不见。取而代之的是一个 <code>bits</code> 属性，以及 <code>data()</code> 方法，这个方法调用的其实是 <code>bits</code> 属性的 <code>data()</code> 方法，并返回了一个 <code>class_rw_t</code> 类型的结构体指针。 </p>\n<h3 id=\"class-data-bits-t\"><a href=\"#class-data-bits-t\" class=\"headerlink\" title=\"class_data_bits_t\"></a>class_data_bits_t</h3><p>以下是简化版 <code>class_data_bits_t</code> 结构体的定义:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct class_data_bits_t &#123;\n    uintptr_t bits;\npublic:\n    class_rw_t* data() &#123;\n        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);\n    &#125;\n&#125;</code></pre>\n\n<p>可见这个结构体只有一个 64 位的 <code>bits</code> 成员，存储了一个指向 <code>class_rw_t</code> 结构体的指针和三个标志位。它实际上由三部分组成。首先由于 Mac OS X 只使用 47 位内存地址，所以前 17 位空余出来，提供给 <code>retain/release 和</code> <code>alloc/dealloc</code> 方法使用，做一些优化。其次，由于内存对齐，指针地址的后三位都是 0，因此可以用来做标志位:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">&#x2F;&#x2F; class is a Swift class\n#define FAST_IS_SWIFT           (1UL&lt;&lt;0)\n&#x2F;&#x2F; class or superclass has default retain&#x2F;release&#x2F;autorelease&#x2F;retainCount&#x2F;\n&#x2F;&#x2F;   _tryRetain&#x2F;_isDeallocating&#x2F;retainWeakReference&#x2F;allowsWeakReference\n#define FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)\n&#x2F;&#x2F; class&#39;s instances requires raw isa\n#define FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)\n&#x2F;&#x2F; data pointer\n#define FAST_DATA_MASK          0x00007ffffffffff8UL</code></pre>\n\n<p>如果计算一下就会发现，<code>FAST_DATA_MASK</code> 这个 16 进制常量的二进制表示恰好后三位为0，且长度为47位: <code>11111111111111111111111111111111111111111111000</code>，我们通过这个掩码做按位与运算即可取出正确的指针地址。</p>\n<p>引用 Draveness 在 <a href=\"https://draveness.me/method-struct/\">深入解析 ObjC 中方法的结构</a> 中的图片做一个总结:</p>\n<p><img src=\"/images/runtime-again/bit.png\" alt=\"bits 示意图\"></p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">struct class_rw_t &#123;\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n&#125;</code></pre>\n\n<p>注意到有一个名字很类似的结构体 <code>class_ro_t</code>，这里的 ‘rw’ 和 ro’ 分别表示 ‘readwrite’ 和 ‘readonly’。因为  <code>class_ro_t</code> 存储了一些由编译器生成的常量。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>These are emitted by the compiler and are part of the ABI. </p></blockquote>\n<p>正是由于 <code>class_ro_t</code> 中的两个属性 <code>instanceStart</code> 和 <code>instanceSize</code> 的存在，保证了 Objective-C2.0 的 ABI 稳定性。因为即使父类增加方法，子类也可以在运行时重新计算 ivar 的偏移量，从而避免重新编译。</p>\n<p>关于 ABI 稳定性的问题，本文不做赘述，读者可以参考 <a href=\"http://www.jianshu.com/p/3b219ab86b09\">Non Fragile ivars</a>。</p>\n<p>如果阅读 <code>class_ro_t</code> 结构体的定义就会发现，旧版本实现中类结构体中的大部分成员变量现在都定义在 <code>class_ro_t</code> 和 <code>class_rw_t</code> 这两个结构体中了。感兴趣的读者可以自行对比，本文不再赘述。</p>\n<p><code>class_rw_t</code> 结构体中还有一个 <code>methods</code> 成员变量，它的类型是 <code>method_array_t</code>，继承自 <code>list_array_tt</code>。</p>\n<p><code>list_array_tt</code> 是一个泛型结构体，用于存储一些元数据，而它实际上是元数据的二维数组:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">template &lt;typename Element, typename List&gt;&#123;\n    struct array_t &#123;\n        uint32_t count;\n        List* lists[0];\n    &#125;;\n&#125;\nclass method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; </code></pre>\n\n<p>其中 <code>Element</code> 表示元数据的类型，比如 <code>method_t</code>，而 <code>List</code> 则表示用于存储元数据的一维数组，比如 <code>method_list_t</code>。</p>\n<p><code>list_array_tt</code> 有三种状态:</p>\n<ol>\n<li>自身为空，可以类比为 <code>[[]]</code></li>\n<li>它只有一个指针，指向一个元数据的集合，可以类比为 <code>[[1, 2]]</code></li>\n<li>它有多个指针，指向多个元数据的集合，可以类比为 <code>[[1, 2], [3, 4]]</code></li>\n</ol>\n<p>当一个类刚创建时，它可能处于状态 1 或 2，但如果使用 <code>class_addMethod</code> 或者 category 来添加方法，就会进入状态 3，而且一旦进入状态 3 就再也不可能回到其他状态，即使新增的方法后来又被移除掉。</p>\n<h2 id=\"方法合并\"><a href=\"#方法合并\" class=\"headerlink\" title=\"方法合并\"></a>方法合并</h2><p>掌握了这些 runtime 的基础只是以后就可以继续钻研剩下的 category 的代码了:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">auto rw &#x3D; cls-&gt;data();\nrw-&gt;methods.attachLists(mlists, mcount);</code></pre>\n\n<p>这是刚刚卡住的地方，现在来看，<code>rw</code> 是一个 <code>class_rw_t</code> 类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;\n    if (addedCount &#x3D;&#x3D; 0) return;\n    uint32_t oldCount &#x3D; array()-&gt;count;\n    uint32_t newCount &#x3D; oldCount + addedCount;\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()-&gt;count &#x3D; newCount;\n    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0]));\n    memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));\n&#125;</code></pre>\n\n<p>这段代码很简单，其实就是先调用 <code>realloc()</code> 函数将原来的空间拓展，然后把原来的数组复制到后面，最后再把新数组复制到前面。</p>\n<p>在实际代码中，比上面略复杂一些。因为为了提高性能，苹果做了一些优化，比如当 List 处于第二种状态(只有一个指针，指向一个元数据的集合)时，其实并不需要在原地扩容空间，而是只要重新申请一块内存，并将最后一个位置留给原来的集合即可。</p>\n<p>这样只多花费了很少的内存空间，也就是原来二维数组占用的内存空间，但是 <code>malloc()</code> 的性能优势会更加明显，这其实是一个空间换时间的权衡问题。</p>\n<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。而我们简单的看一下 runtime 在查找方法时的逻辑:</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123;\n    for (auto mlists &#x3D; cls-&gt;data()-&gt;methods.beginLists(), \n              end &#x3D; cls-&gt;data()-&gt;methods.endLists(); \n         mlists !&#x3D; end;\n         ++mlists) &#123;\n        method_t *m &#x3D; search_method_list(*mlists, sel);\n        if (m) return m;\n    &#125;\n\n    return nil;\n&#125;\n\nstatic method_t *search_method_list(const method_list_t *mlist, SEL sel) &#123;\n    for (auto&amp; meth : *mlist) &#123;\n        if (meth.name &#x3D;&#x3D; sel) return &amp;meth;\n    &#125;\n&#125;</code></pre>\n\n<p>可见搜索的过程是按照从前向后的顺序进行的，一旦找到了就会停止循环。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>读完本文后，你应该对以下内容有比较深刻的理解，排名不分先后:</p>\n<ol>\n<li>定义在 runtime.h 中的数据结构，如果有 <code>OBJC2_UNAVAILABLE</code> 标记则表示已经废弃。</li>\n<li>Objective-C 2.0 中，类结构体的结构层次: <code>objc_class</code> -&gt; <code>class_data_bits_t</code> -&gt; <code>class_rw_t</code> -&gt; <code>method_array_t</code>。</li>\n<li><code>class_ro_t</code> 结构体的作用，与 <code>class_rw_t</code> 的区别，以及和 ABI 稳定性的关系。</li>\n<li>category 解析过程的调用栈以及基本的流程。</li>\n<li><code>method_array_t</code> 为什么要设计成一种类似于二维数组的数据结构，以及它的三种状态之间的关系。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://tech.meituan.com/DiveIntoCategory.html\">深入理解Objective-C：Category</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md\">从源代码看 ObjC 中消息的发送</a></li>\n<li><a href=\"https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md\">深入解析 ObjC 中方法的结构</a></li>\n<li><a href=\"http://stackoverflow.com/questions/8847146/whats-is-methodlists-attribute-of-the-structure-objc-class-for\">Whats is methodLists attribute of the structure objc_class for?</a></li>\n<li><a href=\"http://www.cnblogs.com/jiazhh/articles/3309085.html\">Objc与C（C++）之亲缘关系（一） Class</a></li>\n<li><a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\">Objective-C Runtime</a></li>\n</ol>\n","text":"绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码: struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识","slug":"开发知识","count":3,"path":"api/tags/开发知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Category-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Category 的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Category-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Category 相关的数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86-Category\"><span class=\"toc-text\">处理 Category</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Objective-C-2-0-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">Objective-C 2.0 对象布局模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#objc-class\"><span class=\"toc-text\">objc_class</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#class-data-bits-t\"><span class=\"toc-text\">class_data_bits_t</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#class-rw-t\"><span class=\"toc-text\">class_rw_t</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">方法合并</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"如何进行 Git 仓库瘦身","uid":"f0b7ed12bc36c7022d00f8d1ca004b00","slug":"2022-05-20-how-to-reduce-git","date":"2023-05-14T05:45:19.940Z","updated":"2023-05-14T05:45:19.940Z","comments":true,"path":"api/articles/2022-05-20-how-to-reduce-git.json","keywords":null,"cover":"https://raw.githubusercontent.com/zycslog/assets-pro/main/yancy-min-842ofHC6MaI-unsplash.jpg","text":"对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题： 理解从 Git 的历史记录中删除文件 使用 BFG 重写历史记录 可选，使用 git ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识","slug":"开发知识","count":3,"path":"api/tags/开发知识.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"或许是频繁切换git分支的救星--git worktree","uid":"af1206b3336cbf2448dc968e084c5e69","slug":"2022-06-24-git-worktree","date":"2023-05-14T05:45:19.940Z","updated":"2023-05-14T05:45:19.940Z","comments":true,"path":"api/articles/2022-06-24-git-worktree.json","keywords":null,"cover":"/images/cover/2022-06-24-git-worktree.jpg","text":"在实际的开发过程中，你是否也需要经常来回切换分支，如果是，那么这篇文章介绍的方法或者正合适你。 频繁切换分支的情况 场景1：协助同事 第一种场景是你正在自己的分支feature-my上做着功能的开发，这时候你的同事给你发信息说，帮忙看一个问题，分支是：feature-abc,通常...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识","slug":"开发知识","count":3,"path":"api/tags/开发知识.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}