{"title":"Runtime剖析01 --- 基本数据结构：objc_object & objc_class","uid":"6fca2ac91a092d45af749e0779750e56","slug":"2020-06-23-iOS-runtime-basic-structure","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-06-23-iOS-runtime-basic-structure.json","keywords":null,"cover":[],"content":"<p>众所周知，Objective-C语言是一门动态性很强的语言，与C、C++等语言有着很大的不同。Objective-C语言的动态性基本上都是由Runtime机制进行支撑和实现的，Runtime的实现，融合了C、C++，以及汇编语言。</p>\n<h2 id=\"什么是Runtime？\"><a href=\"#什么是Runtime？\" class=\"headerlink\" title=\"什么是Runtime？\"></a>什么是Runtime？</h2><p>C、C++等静态语言中的各种数据结构都是在编译期已经决定了，不能被修改，而Objective-C作为动态性语言，在程序的运行期，可以动态修改一个类的结构，例如修改方法的实现，变量的绑定等等。</p>\n<p>Objective-C语言作为动态语言，将原本编译期决定的事情推迟到运行期，仅仅采用编译器是无法完成的，因此就需要运行期有一套自己的运行时系统，而这个系统就是Runtime，也是Runtime存在的意义，以及Objective-C语言运行框架的基石。</p>\n<p>在实际的开发中，与Runtime交互的情况大致有三种：</p>\n<ol>\n<li><strong>Objective-C源码：</strong>大多数情况下，开发者采用的都是直接使用Objective-C语言进行编码，而在Objective-C语言源码的背后，都是由Runtime进行底层支撑，Objective-C语言中所使用的数据类型，在Runtime中都有对应的C语言结构体，甚至汇编语言的实现等。</li>\n<li><strong>通过NSObject：</strong>在Cocoa中，大部分的类都继承自NSObject，而NSObject的定义是Runtime决定的。以及NSObject中的大多数方法，都是运行时动态决定的，背后其实是Runtime对应数据结构的支持。例如常用的<code>isKindOfClass</code>和<code>isMemberOfClass</code>检查类是否属于指定的Class的继承体系中；<code>responderToSelector</code> 检查对象是否能响应指定的消息；<code>conformsToProtocol</code> 检查对象是否遵循某个协议；<code>methodForSelector</code>返回指定方法实现的地址等。</li>\n<li><strong>直接调用Runtime API：</strong>Runtime是一个由一系列函数和数据机构组成，具有公共接口的动态共享库。很多函数的功能和Objective-C语言中的含有具有同等的功能。一般情况下不会直接访问Runtime的API，但是当有一些底层的需求需要实现时，例如为现有类动态添加属性等。<a href=\"https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc\">Objective-C Runtime Reference</a></li>\n</ol>\n<p><strong>Objective-C语言中的各种黑魔法，其实都是在Runtime的基础上，对底层数据机构的各类应用。</strong></p>\n<h2 id=\"NSObject解析\"><a href=\"#NSObject解析\" class=\"headerlink\" title=\"NSObject解析\"></a>NSObject解析</h2><p>在Objective-C中，几乎所有的类的基类，都是<strong>NSObject</strong>。因此要深入了解Objective-C类的相关结构，先从<strong>NSObject</strong>类开始。</p>\n<p>在iOS SDK中，对于NSObject类的定义如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">@interface NSObject &lt;NSObject&gt; &#123;\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;\n    Class isa  OBJC_ISA_AVAILABILITY;\n#pragma clang diagnostic pop\n&#125;</code></pre>\n\n<p><strong>NSObject</strong>类仅有一个实例变量<strong>isa</strong>，并且遵循<strong>NSObject</strong>协议。先说说<strong>NSObject</strong>协议，在该协议中，定义了NSObject类的一些通用方法，例如<code>performSelector：</code>、<code>isMemberOfClass</code>、<code>superclass</code>等等，使用协议去定义通用的一些方法，也让类的扩展更加的容易。</p>\n<p><strong>NSObject</strong>类的变量仅有<strong>Class isa</strong>，变量的类型<strong>Class</strong>定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct objc_class *Class;</code></pre>\n\n<p><strong>Class</strong>本质是指向<strong>objc_class结构体</strong>的指针，而<strong>objc_class结构体</strong>的定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct objc_class : objc_object &#123;\n    &#x2F;&#x2F; Class ISA;\n    Class superclass;\n    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable\n    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags\n\n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;</code></pre>\n\n<h2 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h2><p>可以看到<strong>objc_class</strong>继承自<strong>objc_object</strong>，即在Runtime中，class本质也是一个对象。在<strong>objc_class</strong>结构体的定义中，有三个成员变量：</p>\n<ul>\n<li><strong>Class superclass：</strong> 表示当前类的父类对象，类型同样是<strong>Class</strong>；</li>\n<li><strong>cache_t cache：</strong> Objective-C方法调用的优化结构体。对应的数据结构如下：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct cache_t &#123;\n\tstruct bucket_t *buckets();\n    mask_t mask();\n    mask_t occupied();\n    void incrementOccupied();\n    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);\n    void initializeToEmpty();\n\n    unsigned capacity();\n    bool isConstantEmptyCache();\n    bool canBeFreed();\n\n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;\n\nstruct bucket_t &#123;\n\texplicit_atomic&lt;uintptr_t&gt; _imp;\n    explicit_atomic&lt;SEL&gt; _sel;\npublic:\n\tinline SEL sel() const &#123; return _sel.load(memory_order::memory_order_relaxed); &#125;\n\n    inline IMP imp(Class cls) const &#123;\n        uintptr_t imp &#x3D; _imp.load(memory_order::memory_order_relaxed);\n        if (!imp) return nil;\n#if CACHE_IMP_ENCODING &#x3D;&#x3D; CACHE_IMP_ENCODING_PTRAUTH\n        SEL sel &#x3D; _sel.load(memory_order::memory_order_relaxed);\n        return (IMP)\n            ptrauth_auth_and_resign((const void *)imp,\n                                    ptrauth_key_process_dependent_code,\n                                    modifierForSEL(sel, cls),\n                                    ptrauth_key_function_pointer, 0);\n#elif CACHE_IMP_ENCODING &#x3D;&#x3D; CACHE_IMP_ENCODING_ISA_XOR\n        return (IMP)(imp ^ (uintptr_t)cls);\n#elif CACHE_IMP_ENCODING &#x3D;&#x3D; CACHE_IMP_ENCODING_NONE\n        return (IMP)imp;\n#else\n#error Unknown method cache IMP encoding.\n#endif\n    &#125;\n\n    template &lt;Atomicity, IMPEncoding&gt;\n    void set(SEL newSel, IMP newImp, Class cls);\n&#125;</code></pre>\n\n<p><strong>cache</strong>结构体的核心是类型为<strong>bucket_t</strong>的指针，指向以**_imp<strong>和</strong>_sel**对应的缓存点。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>uintptr_t</strong>数据类型定义为：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">#ifndef _UINTPTR_T\n#define _UINTPTR_T\ntypedef unsigned long           uintptr_t;\n#endif &#x2F;* _UINTPTR_T *&#x2F;</code></pre>\n\n<p>本质类型为无符号长整型数据类型，在runtime中，大多数基本数据类型均为无符号长整型，例如**void ***。</p></blockquote>\n<p>上文已经提到，<strong>cache</strong>的存在是为了优化方法的调用，在Runtime中方法的调用流程：</p>\n<ol>\n<li>当要调用一个方法时，首先去当前类的<strong>cache</strong>方法缓存中寻找，如果存在，则直接执行；</li>\n<li>如果<strong>cache</strong>中不存在，则会去当前类的方法列表中寻找，找到后执行并将该方法按照实现**_imp<strong>和方法签名</strong>_sel<strong>存放在</strong>cache**中，以便下次快速调用。</li>\n</ol>\n<ul>\n<li><strong>class_data_bits_t bits：</strong>该变量可以说是<strong>Class</strong>的核心成员变量，本质是一个可以被Mask的指针类型。根据不同的Mask，取出不同的值。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct class_data_bits_t &#123;\n    friend objc_class;\n\n    &#x2F;&#x2F; Values are the FAST_ flags above.\n    uintptr_t bits;\npublic:\n    class_rw_t* data() const &#123;\n        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);\n    &#125;\n    void setData(class_rw_t *newData)\n    &#123;\n        ASSERT(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));\n        &#x2F;&#x2F; Set during realization or construction only. No locking needed.\n        &#x2F;&#x2F; Use a store-release fence because there may be concurrent\n        &#x2F;&#x2F; readers of data and data&#39;s contents.\n        uintptr_t newBits &#x3D; (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;\n        atomic_thread_fence(memory_order_release);\n        bits &#x3D; newBits;\n    &#125;\n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;</code></pre>\n\n<p><strong>class_data_bits_t bits</strong>仅仅包含一个成员变量<strong>bits</strong>，该变量不仅包含指针，同时包含<strong>Class</strong>的各种异或flag，当需要取出信息时，需要用对应的<strong>FAST_<strong>前缀开头的flag掩码对</strong>bits</strong>进行按位与操作。</p>\n<p>例如，在获取信息的方法</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">class_rw_t* data() const &#123;\n    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);\n&#125;</code></pre>\n\n<p>中，通过对<strong>bits</strong>进行<strong>FAST_DATA_MASK</strong>的与操作，返回<strong>class_rw_t *<strong>。</strong>class_rw_t</strong>以及<strong>class_ro_t</strong>可以说是<strong>Class</strong>中的核心结构，其定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct class_rw_t &#123;\n    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\n    &#x2F;&#x2F; 方法列表\n    const method_array_t methods();\n    &#x2F;&#x2F; 属性列表\n    const property_array_t properties();\n    &#x2F;&#x2F; 协议列表\n    const protocol_array_t protocols();\n\n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;\n\nstruct class_ro_t &#123;\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n\n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;</code></pre>\n\n<p>在<strong>class_rw_t</strong>结构体中，方法列表<strong>method_array_t</strong>、属性列表<strong>property_array_t</strong>、协议列表<strong>protocol_array_t</strong>是可以被Runtime修改和扩展的。</p>\n<p>而在<strong>class_ro_t</strong>结构体中包含了类的名称<strong>name</strong>、方法列表<strong>method_list_t</strong>、属性列表<strong>property_list_t</strong>、协议列表<strong>protocol_list_t</strong>等类的基本信息，<strong>class_ro_t</strong>中的信息时不允许修改，并且不可扩展的。</p>\n<p><strong>objc_class  &lt;-   class_data_bits_t  -&gt;  FAST_DATA_MASK  &lt;-  class_rw_t   &lt;-  class_ro_t</strong></p>\n<h2 id=\"realizeClass\"><a href=\"#realizeClass\" class=\"headerlink\" title=\"realizeClass\"></a>realizeClass</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static Class realizeClassWithoutSwift(Class cls, Class previously)\n&#123;\n    &#x2F;&#x2F; 省略\n    ...\n\n    auto ro &#x3D; (const class_ro_t *)cls-&gt;data();\n    auto isMeta &#x3D; ro-&gt;flags &amp; RO_META;\n    if (ro-&gt;flags &amp; RO_FUTURE) &#123;\n        &#x2F;&#x2F; This was a future class. rw data is already allocated.\n        rw &#x3D; cls-&gt;data();\n        ro &#x3D; cls-&gt;data()-&gt;ro();\n        ASSERT(!isMeta);\n        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    &#125; else &#123;\n        &#x2F;&#x2F; Normal class. Allocate writeable class data.\n        rw &#x3D; objc::zalloc&lt;class_rw_t&gt;();\n        rw-&gt;set_ro(ro);\n        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING|isMeta;\n        cls-&gt;setData(rw);\n    &#125;\n\n    &#x2F;&#x2F; 省略\n    ...\n&#125;</code></pre>\n\n<p><strong>realizeClass</strong>是Runtime构造一个完整的类的入口，在没有调用<strong>realizeClass</strong>之前，类是不完整的。上述函数中，最开始返回的仅仅是<strong>class_ro_t</strong>类的基本信息，在进行<strong>realizeClass</strong>时，将类的Category中定义的各种扩展附加到类上，同时改写<strong>data()<strong>的返回值为</strong>class_rw_t</strong>类型。</p>\n<p>因此一个类的完整信息保存在结构<strong>class_rw_t</strong>中，<strong>class_ro_t</strong>结构仅仅保存类的基本信息。</p>\n<h2 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h2><p>上述<strong>objc_class</strong>继承自<strong>objc_object</strong>，也就是说在Objective-C中，类也是一个对象，而对象在runtime中被定义为<strong>objc_object结构体</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct objc_object &#123;\nprivate:\n    isa_t isa;\n\npublic:\n\n    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    &#x2F;&#x2F; rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA\n    Class rawISA();\n\n    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n    \n    &#x2F;&#x2F; 省略其他方法\n    ...\n&#125;</code></pre>\n\n<p><strong>objc_object结构体</strong>的定义相对较为简单，其中仅包含一个<strong>isa_t</strong>的联合体类型。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">union isa_t &#123;\n    isa_t() &#123; &#125;\n    isa_t(uintptr_t value) : bits(value) &#123; &#125;\n\n    Class cls;\n    uintptr_t bits;\n&#125;;</code></pre>\n\n<p><strong>isa_t</strong>是一个联合体，可以表示<strong>Class</strong>或者<strong>uintptr_t</strong>类型，在Objective-C 2.0 中大多数使用的是<strong>uintptr_t</strong>类型。其中<strong>bits</strong>是一个64位的数据，每一位或者几位都表示了关于当前对象的信息。</p>\n<h2 id=\"再探objc-object和objc-class\"><a href=\"#再探objc-object和objc-class\" class=\"headerlink\" title=\"再探objc_object和objc_class\"></a>再探objc_object和objc_class</h2><p><strong>objc_class</strong>继承自<strong>objc_object</strong>，说明在<strong>objc_class</strong>中也有一个<strong>isa</strong>属性，此时这个属性表示当前类属于哪个类，而这种说明类是属于哪个类的类，称之为<strong>元类（meta-class）</strong>。</p>\n<p>元类并不是类的父类，元类在Objective-C的消息转发机制中会由详解，此时，只需要直到，每一个类都有一个与之对应的元类。</p>\n<h2 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h2><p>在Objective-C 中，<strong>id</strong>类型经常会被使用到，它表示任意类型的类实例变量，在Runtime中，id的定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct objc_object *id;</code></pre>\n\n<p>其实id类型就是一个<strong>objc_object *<strong>，因为</strong>objc_object</strong>的<strong>isa</strong>的存在，所有Runtime是可以知道id类型对应的真实类型的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>**Void ***表示任意类型的指针。</p></blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文中，从开发者常用的<strong>NSObject</strong>出发，了解了Objective-C语言中类和对象所对应的数据结构<strong>objc_class</strong>和<strong>objc_object</strong>。可以使用一张图了解这三者之间的关系。</p>\n<p><img src=\"/images/runtime/1/nsobject-objc_class-objc_object-relationship.jpg\"></p>\n","text":"众所周知，Objective-C语言是一门动态性很强的语言，与C、C++等语言有着很大的不同。Objective-C语言的动态性基本上都是由Runtime机制进行支撑和实现的，Runtime的实现，融合了C、C++，以及汇编语言。 什么是Runtime？C、C++等静态语言中的各...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFRuntime%EF%BC%9F\"><span class=\"toc-text\">什么是Runtime？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NSObject%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">NSObject解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#objc-class\"><span class=\"toc-text\">objc_class</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#realizeClass\"><span class=\"toc-text\">realizeClass</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#objc-object\"><span class=\"toc-text\">objc_object</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%8D%E6%8E%A2objc-object%E5%92%8Cobjc-class\"><span class=\"toc-text\">再探objc_object和objc_class</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#id\"><span class=\"toc-text\">id</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"iOS内存管理小结","uid":"efbbbd2e93d0b6b1478e69b9a9de5940","slug":"2020-06-17-iOS-memory-manage-tips","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-06-17-iOS-memory-manage-tips.json","keywords":null,"cover":null,"text":"内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"Runtime剖析02 --- 消息与消息发送机制","uid":"3007adc9b3f366505974b3565c38f1eb","slug":"2020-06-24-iOS-runtime-message-forward","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-06-24-iOS-runtime-message-forward.json","keywords":null,"cover":[],"text":"在Objective-C中，消息发送指Runtime会根据SEL查找对应的IMP，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。 消息相关数据结构SELSEL称之为消息选择器，相当于一个key，在类的...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}