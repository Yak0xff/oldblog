{"title":"Runtime剖析02 --- 消息与消息发送机制","uid":"3007adc9b3f366505974b3565c38f1eb","slug":"2020-06-24-iOS-runtime-message-forward","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-06-24-iOS-runtime-message-forward.json","keywords":null,"cover":[],"content":"<p>在Objective-C中，消息发送指Runtime会根据<strong>SEL</strong>查找对应的<strong>IMP</strong>，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。</p>\n<h2 id=\"消息相关数据结构\"><a href=\"#消息相关数据结构\" class=\"headerlink\" title=\"消息相关数据结构\"></a>消息相关数据结构</h2><h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p><strong>SEL</strong>称之为消息选择器，相当于一个<strong>key</strong>，在类的消息列表中，可以根据这个<strong>key</strong>查找对应的消息实现<strong>IMP</strong>。</p>\n<p>在Runtime中，SEL的定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.\ntypedef struct objc_selector *SEL;</code></pre>\n\n<p>可以看到<strong>SEL</strong>其实是一个<strong>objc_selector *<strong>结构体指针，但是在苹果开源的runtime中并没有其定义，目前</strong>SEL</strong>仅是一个字符串。</p>\n<p>虽然<strong>SEL</strong>可以作为key对消息进行查找，但是当不同的类有着相同的<strong>SEL</strong>的时候，再进行消息实现查找时，可能无法确定消息实现真实的归属，因此在进行消息实现查找时，会结合消息发送的目标Class，才能找到具体的最终的<strong>IMP</strong>。</p>\n<h3 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h3><p>开篇已说，runtime会根据<strong>SEL</strong>查找对应的实现<strong>IMP</strong>。具体地说，runtime会在Class的方法列表中查找方法的实现，在方法列表中方法的实现是以<strong>method_t</strong>结构体的形式存储的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct method_t &#123;\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function&lt;const method_t&amp;,\n                                    const method_t&amp;, bool&gt;\n    &#123;\n        bool operator() (const method_t&amp; lhs,\n                         const method_t&amp; rhs)\n        &#123; return lhs.name &lt; rhs.name; &#125;\n    &#125;;\n&#125;;</code></pre>\n\n<p><strong>method_t</strong>结构体重包含了<strong>SEL</strong>的名称，以及指向对应试下的<strong>imp</strong>指针，另外<strong>types</strong>指的是方法的返回值和参数类型，其格式一般为<strong>v24@0:8@16</strong>，此种格式被称为<strong>Type Encodings</strong>，对应的解释说明详见<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\">Type Encodings</a>。</p>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p><strong>IMP</strong>本质上是一个函数指针，用于指向方法的具体实现，在runtime中，其定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;&#x2F; A pointer to the function of a method implementation. \n#if !OBJC_OLD_DISPATCH_PROTOTYPES\ntypedef void (*IMP)(void &#x2F;* id, SEL, ... *&#x2F; ); \n#else\ntypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); \n#endif</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>IMP</strong>是由编译器生成的，如果知道了<strong>IMP</strong>的地址，就可以绕过runtime的消息发送过程，直接调用函数实现。</p></blockquote>\n<p>在消息发送过程中，runtime会根据<strong>id</strong>和<strong>SEL</strong>来唯一确定<strong>IMP</strong>并进行调用。</p>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><p>在Objective-C中，函数的调用被称为<strong>消息发送</strong>。在进行代码编译时，代码会被修改为<strong>objc_msgSend</strong>的格式。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">OBJC_EXPORT id _Nullable\nobjc_msgSend(id _Nullable self, SEL _Nonnull op, ...)\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</code></pre>\n\n<p>**objc_msgSend()**形式即为Objective-C中的消息发送的入口，该函数的具体实现是由汇编语言实现的，其目的一是为了提高执行效率，二是因为该函数的返回值类型是可变的，汇编正好具有返回值类型多样性的特性。</p>\n<p>除了**objc_msgSend()**之外，编译器还会根据具体的情况，将消息转发改写为如下形式之一：</p>\n<ul>\n<li>objc_msgSend</li>\n<li>objc_msgSend_stret</li>\n<li>objc_msgSendSuper</li>\n<li>objc_msgSendSuper_stret</li>\n</ul>\n<p>当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">OBJC_EXPORT id _Nullable\nobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</code></pre>\n\n<p>在<strong>objc_msgSendSuper</strong>函数的参数中，第一个参数不再是当前类的指针，而变为<strong>objc_super *<strong>结构体指针，</strong>objc_super</strong>结构体包含两个数据，<strong>receiver</strong>指调用super方法的对象，即消息接收者，而<strong>super_class</strong>表示当前子类的父类对象。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct objc_super &#123;\n    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.\n    __unsafe_unretained _Nonnull id receiver;\n    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. \n    __unsafe_unretained _Nonnull Class super_class;\n&#125;;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>带有**_stret**的函数，表示方法返回的是结构体类型。</p></blockquote>\n<h2 id=\"objc-msgSend\"><a href=\"#objc-msgSend\" class=\"headerlink\" title=\"objc_msgSend\"></a>objc_msgSend</h2><pre class=\"line-numbers language-armasm\" data-language=\"armasm\"><code class=\"language-armasm\">\tENTRY _objc_msgSend\n\tUNWIND _objc_msgSend, NoFrame\n\n\tcmp\tp0, #0\t\t\t&#x2F;&#x2F; nil check and tagged pointer check\n#if SUPPORT_TAGGED_POINTERS\n\tb.le\tLNilOrTagged\t\t&#x2F;&#x2F;  (MSB tagged pointer looks negative)\n#else\n\tb.eq\tLReturnZero\n#endif\n\tldr\tp13, [x0]\t\t&#x2F;&#x2F; p13 &#x3D; isa\n\tGetClassFromIsa_p16 p13\t\t&#x2F;&#x2F; p16 &#x3D; class\nLGetIsaDone:\n\t&#x2F;&#x2F; calls imp or objc_msgSend_uncached\n\tCacheLookup NORMAL, _objc_msgSend\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n\tb.eq\tLReturnZero\t\t&#x2F;&#x2F; nil check\n&#x2F;&#x2F; 省略其他</code></pre>\n\n<ol>\n<li>进入<strong>objc_msgSend</strong>后，首先通过<strong>cmp\tp0, #0</strong>检查函数参数<strong>receiver</strong>是否为<strong>nil</strong>，如果为<strong>nil</strong>，则进入<strong>LReturnZero</strong>，返回0；</li>\n<li>如果不为<strong>nil</strong>，则将<strong>receiver</strong>的<strong>isa</strong>存储在<strong>p13</strong>寄存器；</li>\n<li>在寄存器<strong>p13</strong>中，取出<strong>isa</strong>对应的<strong>Class</strong>，存储到<strong>p16</strong>寄存器；</li>\n<li><strong>Class</strong>获取完成后，调用<strong>CacheLookup NORMAL</strong>函数，查找<strong>Class</strong>的方法缓存列表，如果命中，则调用**_objc_msgSend<strong>，如果未命中，则调用</strong>objc_msgSend_uncached**。</li>\n</ol>\n<p><strong>objc_msgSend_uncached</strong>也是汇编语言实现，作用是为方法缓存列表中未查找到方法缓存时，在<strong>Class</strong>的方法列表中进行查找。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">STATIC_ENTRY __objc_msgSend_uncached\n\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\n\t&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION\n\t&#x2F;&#x2F; Out-of-band p16 is the class to search\n\t\n\tMethodTableLookup\n\tTailCallFunctionPointer x17\n\n\tEND_ENTRY __objc_msgSend_uncached</code></pre>\n\n<p><strong>objc_msgSend_uncached</strong>内部调用了<strong>MethodTableLookup</strong>，<strong>MethodTableLookup</strong>是一个汇编实现的宏定义，其内部调用了C语言函数<strong>lookUpImpOrForward</strong>。</p>\n<h2 id=\"lookUpImpOrForward\"><a href=\"#lookUpImpOrForward\" class=\"headerlink\" title=\"lookUpImpOrForward\"></a>lookUpImpOrForward</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">extern IMP lookUpImpOrForward(id obj, SEL, Class cls, int behavior);</code></pre>\n\n<p><strong>lookUpImpOrForward</strong>函数的目的是根据<strong>Class</strong>和<strong>SEL</strong>，在当前类或者当前类的父类中找到方法对应的<strong>IMP</strong>，同时，缓存找到的对应<strong>IMP</strong>到当前类的方法缓存列表中。如果没有找到对应的<strong>IMP</strong>，则会进入到消息转发流程。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n&#123;\n    const IMP forward_imp &#x3D; (IMP)_objc_msgForward_impcache;\n    IMP imp &#x3D; nil;\n    Class curClass;\n\n    runtimeLock.assertUnlocked();\n\n    &#x2F;&#x2F; Optimistic cache lookup\n    &#x2F;&#x2F; 首先在根据class和sel在方法缓存中查找imp\n    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;\n        imp &#x3D; cache_getImp(cls, sel);\n        &#x2F;&#x2F; 如果查找到，则直接进入到done_nolock\n        if (imp) goto done_nolock;\n    &#125;\n\n    &#x2F;&#x2F; runtimeLock is held during isRealized and isInitialized checking\n    &#x2F;&#x2F; to prevent races against concurrent realization.\n\n    &#x2F;&#x2F; runtimeLock is held during method search to make\n    &#x2F;&#x2F; method-lookup + cache-fill atomic with respect to method addition.\n    &#x2F;&#x2F; Otherwise, a category could be added but ignored indefinitely because\n    &#x2F;&#x2F; the cache was re-filled with the old value after the cache flush on\n    &#x2F;&#x2F; behalf of the category.\n\n    runtimeLock.lock();\n\n    &#x2F;&#x2F; We don&#39;t want people to be able to craft a binary blob that looks like\n    &#x2F;&#x2F; a class but really isn&#39;t one and do a CFI attack.\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; To make these harder we want to make sure this is a class that was\n    &#x2F;&#x2F; either built into the binary or legitimately registered through\n    &#x2F;&#x2F; objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; TODO: this check is quite costly during process startup.\n    checkIsKnownClass(cls);\n\n    &#x2F;&#x2F; 如果class还未realize，先进行realize\n    if (slowpath(!cls-&gt;isRealized())) &#123;\n        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again\n    &#125;\n\t&#x2F;&#x2F; 如果class还未initialize，先进行initialize\n    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;\n        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);\n        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again\n\n        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and \n        &#x2F;&#x2F; then the messenger will send +initialize again after this \n        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called \n        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172\n    &#125;\n\n    runtimeLock.assertLocked();\n    curClass &#x3D; cls;\n\n    &#x2F;&#x2F; The code used to lookpu the class&#39;s cache again right after\n    &#x2F;&#x2F; we take the lock but for the vast majority of the cases\n    &#x2F;&#x2F; evidence shows this is a miss most of the time, hence a time loss.\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; The only codepath calling into this without having performed some\n    &#x2F;&#x2F; kind of cache lookup is class_getInstanceMethod().\n    &#x2F;&#x2F; 在当前class中没有找到imp，则依次向上查找super class的方法列表\n    for (unsigned attempts &#x3D; unreasonableClassCount();;) &#123;\n        &#x2F;&#x2F; curClass method list.\n        &#x2F;&#x2F; 首先获取当前类的方法体\n        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);\n        if (meth) &#123;\n            imp &#x3D; meth-&gt;imp;\n            goto done;\n        &#125;\n        &#x2F;&#x2F; 通过继承链，向上查找IMP\n        if (slowpath((curClass &#x3D; curClass-&gt;superclass) &#x3D;&#x3D; nil)) &#123;\n            &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help.\n            &#x2F;&#x2F; Use forwarding.\n            imp &#x3D; forward_imp;\n            break;\n        &#125;\n\n        &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.\n        if (slowpath(--attempts &#x3D;&#x3D; 0)) &#123;\n            _objc_fatal(&quot;Memory corruption in class list.&quot;);\n        &#125;\n\n        &#x2F;&#x2F; Superclass cache.\n        &#x2F;&#x2F; 父类缓存\n        imp &#x3D; cache_getImp(curClass, sel);\n        if (slowpath(imp &#x3D;&#x3D; forward_imp)) &#123;\n            &#x2F;&#x2F; Found a forward:: entry in a superclass.\n            &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method\n            &#x2F;&#x2F; resolver for this class first.\n            break;\n        &#125;\n        &#x2F;&#x2F; 找到父类的IMP，并缓存\n        if (fastpath(imp)) &#123;\n            &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.\n            goto done;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; No implementation found. Try method resolver once.\n    &#x2F;&#x2F; 没有查找到IMP，进入动态方法解析流程\n    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;\n        behavior ^&#x3D; LOOKUP_RESOLVER;\n        return resolveMethod_locked(inst, sel, cls, behavior);\n    &#125;\n\n done:\n \t&#x2F;&#x2F; 记录并缓存IMP\n    log_and_fill_cache(cls, imp, sel, inst, curClass);\n    runtimeLock.unlock();\n done_nolock:\n \t&#x2F;&#x2F; 未找到对应的IMP，返回nil\n    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp &#x3D;&#x3D; forward_imp)) &#123;\n        return nil;\n    &#125;\n    return imp;\n&#125;</code></pre>\n\n<p><strong>lookUpImpOrForward</strong>工作流程：</p>\n<ol>\n<li>尝试在当前receiver对应class的cache中查找imp，如果查找到，则调用；</li>\n<li>如果在cache中为查找到imp，则在class的方法列表中查找imp；</li>\n<li>尝试在class的所有super class中查找imp。（首先在super class的cache中查找，如果为找到，则在super class的方法列表中查找）；</li>\n<li>如果还未找到imp，则尝试进行动态方法解析SEL；</li>\n<li>动态解析失败，则尝试进入消息转发流程，让其他class处理SEL。</li>\n</ol>\n<p>在查找class的方法列表中是否有SEL对应的IMP时，调用的是**getMethodNoSuper_nolock()**：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static method_t *\ngetMethodNoSuper_nolock(Class cls, SEL sel)\n&#123;\n    runtimeLock.assertLocked();\n\n    ASSERT(cls-&gt;isRealized());\n    &#x2F;&#x2F; fixme nil cls? \n    &#x2F;&#x2F; fixme nil sel?\n\n    auto const methods &#x3D; cls-&gt;data()-&gt;methods();\n    for (auto mlists &#x3D; methods.beginLists(),\n              end &#x3D; methods.endLists();\n         mlists !&#x3D; end;\n         ++mlists)\n    &#123;\n        &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;46904873&gt; getMethodNoSuper_nolock is the hottest\n        &#x2F;&#x2F; caller of search_method_list, inlining it turns\n        &#x2F;&#x2F; getMethodNoSuper_nolock into a frame-less function and eliminates\n        &#x2F;&#x2F; any store from this codepath.\n        method_t *m &#x3D; search_method_list_inline(*mlists, sel);\n        if (m) return m;\n    &#125;\n\n    return nil;\n&#125;</code></pre>\n\n<p>首先取出class的方法列表<strong>method_array_t</strong>，然后调用<strong>search_method_list_inline()<strong>，根据SEL查找对应的</strong>method_t</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">ALWAYS_INLINE static method_t *\nsearch_method_list_inline(const method_list_t *mlist, SEL sel)\n&#123;\n    int methodListIsFixedUp &#x3D; mlist-&gt;isFixedUp();\n    int methodListHasExpectedSize &#x3D; mlist-&gt;entsize() &#x3D;&#x3D; sizeof(method_t);\n    \n    if (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;\n        return findMethodInSortedMethodList(sel, mlist);\n    &#125; else &#123;\n        &#x2F;&#x2F; Linear search of unsorted method list\n        for (auto&amp; meth : *mlist) &#123;\n            if (meth.name &#x3D;&#x3D; sel) return &amp;meth;\n        &#125;\n    &#125;\n    return nil;\n&#125;</code></pre>\n\n<p>在方法查找的时候，会分为两种方式：</p>\n<ol>\n<li>如果方法列表是有序的，则使用<strong>findMethodInSortedMethodList</strong>进行前向查找，使用<strong>二分查找</strong>方式</li>\n<li>否则直接进行遍历</li>\n</ol>\n<h2 id=\"objc-msgSendSuper\"><a href=\"#objc-msgSendSuper\" class=\"headerlink\" title=\"objc_msgSendSuper\"></a>objc_msgSendSuper</h2><p>上文已经提到，当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">OBJC_EXPORT id _Nullable\nobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)\n    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</code></pre>\n\n<p>在实际开发中，当使用<strong>super</strong>关键字调用方法时，编译器则会将代码编译为<strong>objc_msgSendSuper</strong>的格式。</p>\n<p><strong>super关键字本质上类似一个“语法糖”，在代码编译时，编译器会将其替换为objc_super指针类型，来传入到objc_msgSendSuper方法中，而并不是父类的意思。</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct objc_super &#123;\n    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.\n    &#x2F;&#x2F; 消息的接收者，一般为当前类的实例对象。\n    __unsafe_unretained _Nonnull id receiver;\n\n    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. \n    &#x2F;&#x2F; 告知查找方法IMP的去向，当前类实例的父类对象。\n    __unsafe_unretained _Nonnull Class super_class;\n&#125;;</code></pre>\n\n<p><strong>当使用super关键字调用方法时，runtime会到当前类的父类中查找对应IMP，然后将消息发送到当前类的实例上。</strong></p>\n<p>这也解释了为什么**[self class] 和 [super class]**会输出同样结果的原因。</p>\n<p>同样<strong>objc_msgSendSuper</strong>也是由汇编语言实现的，实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">ENTRY _objc_msgSendSuper\n\nldr\tr9, [r0, #CLASS]\t&#x2F;&#x2F; r9 &#x3D; struct super-&gt;class\nCacheLookup NORMAL, _objc_msgSendSuper\n&#x2F;&#x2F; cache hit, IMP in r12, eq already set for nonstret forwarding\nldr\tr0, [r0, #RECEIVER]\t&#x2F;&#x2F; load real receiver\nbx\tr12\t\t\t&#x2F;&#x2F; call imp\n\nCacheLookup2 NORMAL, _objc_msgSendSuper\n&#x2F;&#x2F; cache miss\nldr\tr9, [r0, #CLASS]\t&#x2F;&#x2F; r9 &#x3D; struct super-&gt;class\nldr\tr0, [r0, #RECEIVER]\t&#x2F;&#x2F; load real receiver\nb\t__objc_msgSend_uncached\n\nEND_ENTRY _objc_msgSendSuper</code></pre>\n\n<p>寄存器<strong>r9</strong>中保存的是当前实例的父类对象，获取到对应的父类后，调用<strong>CacheLookup</strong>在方法缓存中查找对应imp，缓存命中后，取出<strong>receiver</strong>，调用imp。如果未在缓存中命中IMP，则调用**__objc_msgSend_uncached<strong>，传入</strong>super class**进行方法查找。</p>\n<h2 id=\"动态解析\"><a href=\"#动态解析\" class=\"headerlink\" title=\"动态解析\"></a>动态解析</h2><p>如果在类的继承链中没有找到对应的IMP，runtime则会进入消息的动态解析流程，即进入到<strong>lookUpImpOrForward</strong>中的<strong>resolveMethod_locked</strong>函数调用中。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;\n       behavior ^&#x3D; LOOKUP_RESOLVER;\n       return resolveMethod_locked(inst, sel, cls, behavior);\n   &#125;</code></pre>\n\n<p><strong>动态解析，就是将方法实现在运行时动态的添加到当前类中。</strong>之后runtime会重新尝试消息查找。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static NEVER_INLINE IMP\nresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)\n&#123;\n    runtimeLock.assertLocked();\n    ASSERT(cls-&gt;isRealized());\n\n    runtimeLock.unlock();\n\n    if (! cls-&gt;isMetaClass()) &#123;\n        &#x2F;&#x2F; try [cls resolveInstanceMethod:sel]\n        resolveInstanceMethod(inst, sel, cls);\n    &#125; \n    else &#123;\n        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]\n        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]\n        resolveClassMethod(inst, sel, cls);\n        if (!lookUpImpOrNil(inst, sel, cls)) &#123;\n            resolveInstanceMethod(inst, sel, cls);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; chances are that calling the resolver have populated the cache\n    &#x2F;&#x2F; so attempt using it\n    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);\n&#125;</code></pre>\n\n<p>在<strong>resolveMethod_locked</strong>中，runtime会根据调用的是实例方法还是类方法，进入到不同的处理逻辑中。</p>\n<ul>\n<li>动态解析实例方法： **resolveInstanceMethod()**用来动态解析实例方法，在运行时可以动态的将对应的方法实现添加到类实例所对应的类的消息列表中。</li>\n<li>动态解析类方法： **resolveClassMethod()**用来动态解析类方法，同样可以在运行时动态的将对应的类方法添加到类的消息列表中。</li>\n</ul>\n<p><strong>举例：</strong></p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;\n    if (sel &#x3D;&#x3D; @selector(test)) &#123;\n        class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(testInstanceMethod)), &quot;v@:&quot;);\n        return YES;\n    &#125;\n    return [super resolveInstanceMethod:sel];\n&#125;\n\n- (void)testInstanceMethod&#123;\n    NSLog(@&quot;%s&quot;, __func__);\n&#125;\n\n+ (BOOL)resolveClassMethod:(SEL)sel&#123;\n    if (sel &#x3D;&#x3D; @selector(test)) &#123;\n        class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(testClassMehotd)), &quot;v@:&quot;);\n        return YES;\n    &#125;\n    return [super resolveClassMethod:sel];\n&#125;\n\n+ (void)testClassMehotd&#123;\n    NSLog(@&quot;%s&quot;, __func__);\n&#125;</code></pre>\n\n<p>在示例中，<strong>test()<strong>方法仅仅声明，没有实现。在运行时，runtime则会进入到消息的动态解析。需要注意的是，动态解析类方法时，方法</strong>class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)<strong>中的第一个参数，需要使用</strong>object_getClass()<strong>进行获取后传参。因为在动态解析类方法时，需要将方法的实现添加到当前类的isa指向类中，而类的指向类为</strong>元类</strong>。</p>\n<ul>\n<li>当<strong>self</strong>是实例对象时，**[self class]** 和 **object_getClass(self)**等价，因为前者会直接调用后者，都是返回对象实例所对应的类。</li>\n<li>当<strong>self</strong>是类对象时，**[self class]<strong>返回类对象本身，而</strong>object_getClass(self)**返回类对应的元类。</li>\n</ul>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><p>当动态解析依然失败，runtime则进入到消息转发流程。<strong>消息转发，是将当前消息转发到其他对象进行处理。</strong> 在NSObject中，针对消息转发提供了专门的API来处理。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">&#x2F;&#x2F; 转发类方法，id返回的是类对象\n+ (id)forwardingTargetForSelector:(SEL)sel;\n&#x2F;&#x2F; 转发实例方法，id返回的是实例对象\n- (id)forwardingTargetForSelector:(SEL)sel;</code></pre>\n\n<p><strong>消息转发示例</strong></p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;\n    if (aSelector &#x3D;&#x3D; @selector(test)) &#123;\n        return testForward;\n    &#125;\n    return [super forwardingTargetForSelector:aSelector];\n&#125;</code></pre>\n\n<p>其中<strong>testForward</strong>为实现了<strong>test</strong>方法的实例对象。如果没有实现<strong>forwardingTargetForSelector</strong>，或者该方法返回<strong>nil</strong>或者<strong>self</strong>，则runtime会进入到另一个转发流程。此时runtime会依次调用**- (NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector<strong>，获取方法签名，然后根据方法签名，包装成了一个</strong>NSInvocation*<em>对象，并调用</em></em>- (void)forwardInvocation:(NSInvocation *)anInvocation**，此时无论转发的消息是否实现，系统都会默认消息已经得到了解析，从而避免崩溃。</p>\n<p><img src=\"/images/runtime/2/message-forward.jpg\"></p>\n<p>消息转发实际上是将消息转发给另一个对象进行处理，而消息动态解析是在当前类的范围内进行处理。</p>\n<h2 id=\"消息转发与多继承\"><a href=\"#消息转发与多继承\" class=\"headerlink\" title=\"消息转发与多继承\"></a>消息转发与多继承</h2><p>通过消息转发流程，可以模拟实现Objective-C语言的多继承机制，具体可查看<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1\">Runtime官方文档</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在Objective-C语言中，方法调用实现的底层机制为<strong>消息发送机制</strong>。在开发中，类的实例对象不能调用类方法，原因是类的实例对象在查找消息IMP的流程仅仅是查找类的方法列表，而对于类方法而言，其实现存放在元类的方法列表中，因此实例对象通过objc_msgSend方法是找不到对应类消息的IMP的。</p>\n<p>类大多数情况下是不能调用实例方法的，除非实例方法定义在根类中，即NSObject中。因为当调用类方法是，会在元类的继承链的方法列表中查找对应的IMP，而跟元类对应的父类是NSObject，因此在NSObject中定义的实例方法，其实是可以通过类方法形式来调用的。</p>\n","text":"在Objective-C中，消息发送指Runtime会根据SEL查找对应的IMP，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。 消息相关数据结构SELSEL称之为消息选择器，相当于一个key，在类的...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">消息相关数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SEL\"><span class=\"toc-text\">SEL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#method-t\"><span class=\"toc-text\">method_t</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMP\"><span class=\"toc-text\">IMP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">消息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#objc-msgSend\"><span class=\"toc-text\">objc_msgSend</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lookUpImpOrForward\"><span class=\"toc-text\">lookUpImpOrForward</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#objc-msgSendSuper\"><span class=\"toc-text\">objc_msgSendSuper</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">动态解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">消息转发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">消息转发与多继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"Runtime剖析01 --- 基本数据结构：objc_object & objc_class","uid":"6fca2ac91a092d45af749e0779750e56","slug":"2020-06-23-iOS-runtime-basic-structure","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-06-23-iOS-runtime-basic-structure.json","keywords":null,"cover":[],"text":"众所周知，Objective-C语言是一门动态性很强的语言，与C、C++等语言有着很大的不同。Objective-C语言的动态性基本上都是由Runtime机制进行支撑和实现的，Runtime的实现，融合了C、C++，以及汇编语言。 什么是Runtime？C、C++等静态语言中的各...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"Runtime剖析03 --- “黑魔法” Method Swizzling","uid":"c17c44d6d8996ee062f87af24348061f","slug":"2020-06-30-iOS-runtime-method-swizzling","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-06-30-iOS-runtime-method-swizzling.json","keywords":null,"cover":null,"text":"方法替换，又称为Method Swizzling，是Objective-C语言中比较流行的“黑魔法”。动态替换方法实现，大多数情况下使用在一些检测类的业务逻辑中，同时，方法替换也带给开发者更多可能的新的开发方式。在简单剖析**Method Swizzling **前，先看看方法替...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}