{"title":"Runtime剖析05 --- 再议iOS内存管理","uid":"e756f728cc576c6fe02245695ebbf9dd","slug":"2020-07-13-iOS-memory-manager","date":"2023-05-19T09:57:19.845Z","updated":"2023-05-19T09:57:19.845Z","comments":true,"path":"api/articles/2020-07-13-iOS-memory-manager.json","keywords":null,"cover":[],"content":"<p>我们都知道，iOS中进行内存管理的管理模型是<strong>引用计数</strong>，但是这属于上层应用的范畴，在系统底层，iOS会根据不同的数据结构或者不同的数据类型，进行系统内存的分区，在不同的分区中，管理着自己的内存，另外，iOS的内存管理并不直接管理硬件内存，而是管理着硬件内存之上的一个过渡内存—<strong>虚拟内存</strong>。关于虚拟内存，可参考<a href=\"https://robinchao.github.io/iOS-VMManage/\">iOS虚拟内存管理</a>一文。</p>\n<h2 id=\"iOS-内存分区\"><a href=\"#iOS-内存分区\" class=\"headerlink\" title=\"iOS 内存分区\"></a>iOS 内存分区</h2><p>iOS的内存管理是基于虚拟内存的管理，虚拟内存能够让每一个进程都在逻辑上<code>独占</code>整个设备的内存。iOS又将虚拟内存按照地址由低到高划分为五大区：</p>\n<p><img src=\"/images/runtime/5/vm-zone\"></p>\n<p>虚拟内中，最上方是系统内核区的内存，最下方是系统保留的内存空间，中间则是程序加载的内存空间。内存按照自下而上，由低地址到高地址的拓展，程序加载到内存分为三段：</p>\n<ol>\n<li>未初始化数据(.bss)：存放未进行初始化的静态变量、全局变量</li>\n<li>已初始化数据(.data)：存放已初始化的静态变量、全局变量</li>\n<li>代码段(.text)：存放代码的二进制代码</li>\n</ol>\n<span id=\"more\"></span>\n\n\n<p>其他内存段<strong>栈区</strong>和<strong>堆区</strong>，分别用于方法或函数的调用和开发者创建的对象等内存。也就是说，开发者所管理的内存是在堆区，堆地址的分配不连续，但是整体地址是由低到高拓展。栈区的内存管理是由系统自动管理，栈区的地址是连续的，其内存地址是由高向低拓展。在程序运行时，栈区和堆区的大小是变化的，只不过栈区是由系统管理的，堆区是通过引用计数的方式管理对象的，内存的管理也是由开发者管理的。</p>\n<h2 id=\"Tagged-Pointer\"><a href=\"#Tagged-Pointer\" class=\"headerlink\" title=\"Tagged Pointer\"></a>Tagged Pointer</h2><p>在开发的过程中，难免会有些数字需要进行存储，而在iOS中，通常使用NSNumber对象来表示数字，对于绝大多数程序而言，所使用到的数字并不会很大，也用不到上亿的数字，同样对于字符串类型，绝大多数情况下，字符的个数也在8个字节以内。在iPhone 5s之后，iOS的寻址地址扩大到了64位，可以使用63位来表示一个数字，一位用来作为符号位。此时如果存储一个数字，例如**NSNumber *num&#x3D;@10000**，远远达不到63位的内存，这样在内存中则会留下很多无用的空位，造成内存空间的浪费。</p>\n<p>针对上述问题，Apple引入了<strong>Tagged Pointer</strong>，一种特殊的<strong>指针</strong>，在该类型的指针中，存储的已经不是地址，而是<strong>真实的数据和一些附加信息</strong>。</p>\n<p><strong>此部分内容不再详述，具体可查看<a href=\"https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/\">深入理解 Tagged Pointer\n</a>。</strong></p>\n<p>在Runtime中，针对Tagged Pointer的辨别，首先需要一个标志位，用来判断当前指针是<strong>真正的指针</strong>还是<strong>Tagged Pointer</strong>，Runtime中使用了一个宏定义<strong>define _OBJC_TAG_MASK (1UL&lt;&lt;63)<strong>，表示如果64位数据中，最高位是1的话，则表明当前是一个</strong>Tagged Pointer</strong>类型。在Runtime中，不仅仅NSNumber有Tagged Pointer类型，还有NSString、NSIndexPath、NSDate等，具体如下定义：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#123;\n    &#x2F;&#x2F; 60-bit payloads\n    OBJC_TAG_NSAtom            &#x3D; 0, \n    OBJC_TAG_1                 &#x3D; 1, \n    OBJC_TAG_NSString          &#x3D; 2, \n    OBJC_TAG_NSNumber          &#x3D; 3, \n    OBJC_TAG_NSIndexPath       &#x3D; 4, \n    OBJC_TAG_NSManagedObjectID &#x3D; 5, \n    OBJC_TAG_NSDate            &#x3D; 6,\n\n    &#x2F;&#x2F; 60-bit reserved\n    OBJC_TAG_RESERVED_7        &#x3D; 7, \n\n    &#x2F;&#x2F; 52-bit payloads\n    OBJC_TAG_Photos_1          &#x3D; 8,\n    OBJC_TAG_Photos_2          &#x3D; 9,\n    OBJC_TAG_Photos_3          &#x3D; 10,\n    OBJC_TAG_Photos_4          &#x3D; 11,\n    OBJC_TAG_XPC_1             &#x3D; 12,\n    OBJC_TAG_XPC_2             &#x3D; 13,\n    OBJC_TAG_XPC_3             &#x3D; 14,\n    OBJC_TAG_XPC_4             &#x3D; 15,\n    OBJC_TAG_NSColor           &#x3D; 16,\n    OBJC_TAG_UIColor           &#x3D; 17,\n    OBJC_TAG_CGColor           &#x3D; 18,\n    OBJC_TAG_NSIndexSet        &#x3D; 19,\n\n    OBJC_TAG_First60BitPayload &#x3D; 0, \n    OBJC_TAG_Last60BitPayload  &#x3D; 6, \n    OBJC_TAG_First52BitPayload &#x3D; 8, \n    OBJC_TAG_Last52BitPayload  &#x3D; 263, \n\n    OBJC_TAG_RESERVED_264      &#x3D; 264\n&#125;;</code></pre>\n\n<p>例如<strong>0xa</strong>转换为二进制，得到<strong>1010</strong>，其中高位<strong>1xxx</strong>表明是一个<strong>Tagged Pointer</strong>,而剩下的3位<strong>010</strong>,表示是一个<strong>NSString</strong>类型，即<strong>010</strong>转换为十进制为<strong>2</strong>，对应上述定义中的<strong>OBJC_TAG_NSString &#x3D; 2</strong>。</p>\n<p>对于字符串来说，只有小字符串会被存储为<strong>Tagged Pointer</strong>类型，那么到底要多小呢？能够想到的是，字符串在进行春初的时候，并不是存储着字符串本身，而是字符串中每个字符的ASCII码，在字符串长度增加到8个字符之前，字符串是按照小对象的方式存储的，更大的字符串则是使用传统的指针方式存储的。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">NSString *test_small &#x3D; @&quot;a&quot;;\nNSString *str &#x3D; [NSString stringWithFormat:@&quot;%@&quot;, test_small];\n\nNSNumber *number &#x3D; @1.0;\nNSNumber *number_large &#x3D; @3.1415926;</code></pre>\n\n<p><img src=\"/images/runtime/5/tagged-pointer.jpg\"></p>\n<p><strong>isa</strong></p>\n<p>从上述示例的结果中可以看到，当一个对象被存储未<strong>Tagged Pointer</strong>类型后，该对象的<strong>isa</strong>指针是<strong>0x0</strong>，指向空的，也就是说<strong>Tagged Pointer</strong>类型的对象，是没有isa属性的。在Runtime中，获取一个对象的isa指针定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">inline Class \nobjc_object::getIsa() \n&#123;\n    if (fastpath(!isTaggedPointer())) return ISA();\n\n    extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;\n    uintptr_t slot, ptr &#x3D; (uintptr_t)this;\n    Class cls;\n\n    slot &#x3D; (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;\n    cls &#x3D; objc_tag_classes[slot];\n    if (slowpath(cls &#x3D;&#x3D; (Class)&amp;OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) &#123;\n        slot &#x3D; (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;\n        cls &#x3D; objc_tag_ext_classes[slot];\n    &#125;\n    return cls;\n&#125;\n\nstatic inline bool \n_objc_isTaggedPointer(const void * _Nullable ptr)\n&#123;\n    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;\n&#125;</code></pre>\n\n<p>当获取一个对象的isa指针式，如果是tagged pointer类型，则会取出高4位的内容，进行对象类型的确定。</p>\n<h2 id=\"NONPOINTER-ISA\"><a href=\"#NONPOINTER-ISA\" class=\"headerlink\" title=\"NONPOINTER_ISA\"></a>NONPOINTER_ISA</h2><p><strong>NONPOINTER_ISA</strong>是iOS中另一种内存管理的方式，即对象的isa指针，该指针用来表明对象属性和类类型。Apple同样优化了该中方式的内存管理方式，在isa中，不仅表明了属性属于那个类，还附加了引用计数<strong>extra_rc</strong>、是否weak引用<strong>weakly_referenced</strong>、是否有附加属性<strong>has_assoc</strong>等附加信息。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">@interface NSObject &lt;NSObject&gt; &#123;\n    Class isa  OBJC_ISA_AVAILABILITY;\n&#125;\n\ntypedef struct objc_class *Class;\n\nstruct objc_class : objc_object &#123;\n    Class superclass;\n    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable\n    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags\n&#125;\n \nstruct objc_object &#123;\nprivate:\n    isa_t isa;\n&#125;\n\nunion isa_t \n&#123;\n    isa_t() &#123; &#125;\n    isa_t(uintptr_t value) : bits(value) &#123; &#125;\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    struct &#123;\n        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h\n    &#125;;\n#endif\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n    struct &#123;\n        uintptr_t nonpointer        : 1;\n        uintptr_t has_assoc         : 1;\n        uintptr_t has_cxx_dtor      : 1;\n        uintptr_t shiftcls          : 33; &#x2F;&#x2F; MACH_VM_MAX_ADDRESS 0x1000000000\n        uintptr_t magic             : 6;\n        uintptr_t weakly_referenced : 1;\n        uintptr_t deallocating      : 1;\n        uintptr_t has_sidetable_rc  : 1;\n        uintptr_t extra_rc          : 19;\n#       define RC_ONE   (1ULL&lt;&lt;45)\n#       define RC_HALF  (1ULL&lt;&lt;18)\n    &#125;;\n&#125;</code></pre>\n\n<p><strong>isa指针</strong>其本质是<strong>isa_t 联合类型</strong>。联合类型的作用在于用更少的空间，表示更多可能的类型，但是类型之间是不能共存的。</p>\n<p>在<strong>isa_t</strong>的定义中，有两个重要的成员变量<strong>cls</strong>和<strong>struct</strong>，并且<strong>struct</strong>部分是在定义了<strong>ISA_BITFIELD</strong>之后才会使用的，也就是说，只有符合ISA_BITFIELD的时候，才会使用<strong>struct</strong>结构体，即采用了优化的isa策略时，<strong>isa_t</strong>类型并不等同于<strong>Class</strong>，而是一个<strong>struct</strong>结构。这个结构共占用了64个字节，从低位的<strong>nonpointer</strong>到高位的<strong>extra_rc</strong>，定义中中**:**表示该成员占用几个字节。</p>\n<p>各成员的含义如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>占用位(单位：bit)</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>nonpointer</td>\n<td>1</td>\n<td>标志位。1 代表开启了isa优化，0 代表未开启isa优化</td>\n<td>可根据此位判断对象是否启用了isa优化。</td>\n</tr>\n<tr>\n<td>has_assoc</td>\n<td>1</td>\n<td>标志位。标识该对象是否有关联对象。</td>\n<td>对象没有关联对象时，其内存释放更快。</td>\n</tr>\n<tr>\n<td>has_cxx_dtor</td>\n<td>1</td>\n<td>标志位。标识对象是否有C++或ARC析构函数。</td>\n<td>无析构函数时，内存释放更快。</td>\n</tr>\n<tr>\n<td>shiftcls</td>\n<td>33</td>\n<td>类指针的非零位。</td>\n<td></td>\n</tr>\n<tr>\n<td>magic</td>\n<td>6</td>\n<td>“魔法”位。固定值0x1a，用于调试时区分对象是否已经初始化。</td>\n<td></td>\n</tr>\n<tr>\n<td>weakly_referenced</td>\n<td>1</td>\n<td>标志位。标识对象是否被别的对象弱引用。</td>\n<td>没有弱引用的对象内存释放更快。</td>\n</tr>\n<tr>\n<td>deallocating</td>\n<td>1</td>\n<td>标志位。标识对象是否正在被释放。</td>\n<td></td>\n</tr>\n<tr>\n<td>has_sidetable_rc</td>\n<td>1</td>\n<td>标志位。标识对象当前的引用计数是否过大，如果过大则需要使用sidetable存储引用计数。</td>\n<td></td>\n</tr>\n<tr>\n<td>extra_rc</td>\n<td>19</td>\n<td>记录当前对象的引用计数。</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>其中和对象引用计数相关的有<strong>has_sidetable_rc</strong>和<strong>extra_rc</strong>，如上所述，当对象引用计数过大时，<strong>has_sidetable_rc</strong>会被设定为1，并启用sidetable来存储引用计数。</p>\n<h3 id=\"SideTable\"><a href=\"#SideTable\" class=\"headerlink\" title=\"SideTable\"></a>SideTable</h3><p><strong>SideTable</strong>是一个全局的引用计数表，其中存储了项目中所有对象的引用计数。在弄清楚<strong>SideTable</strong>和<strong>extra_rc</strong>之间的关系之前，先了解一下Runtime是如何添加对象的引用计数的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">ALWAYS_INLINE id \nobjc_object::rootRetain(bool tryRetain, bool handleOverflow)\n&#123;\n\t&#x2F;&#x2F; 如果是Tagged Pointer类型，直接返回this。因为TaggedPointer类型不使用引用计数管理内存\n    if (isTaggedPointer()) return (id)this;\n\n    bool sideTableLocked &#x3D; false;\n    &#x2F;&#x2F; 标记 extra_rc 是否溢出，默认false\n    bool transcribeToSideTable &#x3D; false;\n\n    &#x2F;&#x2F; 临时变量，用于isa_t的存储方式切换\n    isa_t oldisa;\n    isa_t newisa;\n\n    do &#123;\n        transcribeToSideTable &#x3D; false;\n        &#x2F;&#x2F; 先取出isa_t\n        oldisa &#x3D; LoadExclusive(&amp;isa.bits);\n        newisa &#x3D; oldisa;\n        &#x2F;&#x2F; 如果没有启用isa优化，则返回对应的sidetable记录\n        if (slowpath(!newisa.nonpointer)) &#123;\n            ClearExclusive(&amp;isa.bits);\n            if (rawISA()-&gt;isMetaClass()) return (id)this;\n            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();\n            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;\n            else return sidetable_retain();\n        &#125;\n        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides\n        &#x2F;&#x2F; 如果对象正在析构，则返回nil\n        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;\n            ClearExclusive(&amp;isa.bits);\n            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();\n            return nil;\n        &#125;\n        &#x2F;&#x2F; 是否溢出标记\n        uintptr_t carry;\n        &#x2F;&#x2F; 调用 addc 函数 对 extra_rc 执行 ++ 操作，返回 carry\n        newisa.bits &#x3D; addc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc++\n        &#x2F;&#x2F; 如果有溢出，则表明extra_rc已经溢出。\n        &#x2F;&#x2F; 1. 先将 extra_rc 减半\n        &#x2F;&#x2F; 2. 然后将另一半转存至sidetable\n        if (slowpath(carry)) &#123;\n            &#x2F;&#x2F; newisa.extra_rc++ overflowed\n            &#x2F;&#x2F; 如果本次不处理溢出，则递归调用一次，并设置handleOverflow为true，下次处理\n            if (!handleOverflow) &#123;\n                ClearExclusive(&amp;isa.bits);\n                return rootRetain_overflow(tryRetain); &#x2F;&#x2F; return rootRetain(tryRetain, true);\n            &#125;\n            &#x2F;&#x2F; Leave half of the retain counts inline and \n            &#x2F;&#x2F; prepare to copy the other half to the side table.\n            &#x2F;&#x2F; 进行具体的溢出处理：\n            &#x2F;&#x2F; 1. 使用 RC_HALF 宏定义，对 extra_rc 进行减半操作\n            &#x2F;&#x2F; 2. 设置has_sidetable_rc标记为true\n            &#x2F;&#x2F; 3. transcribeToSideTable 标记为true\n            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();\n            sideTableLocked &#x3D; true;\n            transcribeToSideTable &#x3D; true;\n            newisa.extra_rc &#x3D; RC_HALF;\n            newisa.has_sidetable_rc &#x3D; true;\n        &#125;\n    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));\n\n    &#x2F;&#x2F; transcribeToSideTable为true时，将extra_rc减半的一部分，转存到sidetable中\n    if (slowpath(transcribeToSideTable)) &#123;\n        &#x2F;&#x2F; Copy the other half of the retain counts to the side table.\n        sidetable_addExtraRC_nolock(RC_HALF);\n    &#125;\n\n    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();\n    return (id)this;\n&#125;</code></pre>\n\n<p>在Runtime中，通过<strong>SideTable</strong>来管理对象的引用计数和弱引用。<strong>SideTable</strong>中会包含三部分内容：自旋锁、引用计数表和弱引用表。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct SideTable &#123;\n    spinlock_t slock; &#x2F;&#x2F; 自旋锁\n    RefcountMap refcnts; &#x2F;&#x2F; 引用计数表\n    weak_table_t weak_table; &#x2F;&#x2F; 弱引用表\n\n    SideTable() &#123;\n        memset(&amp;weak_table, 0, sizeof(weak_table));\n    &#125;\n\n    ~SideTable() &#123;\n        _objc_fatal(&quot;Do not delete SideTable.&quot;);\n    &#125;\n\n    void lock() &#123; slock.lock(); &#125;\n    void unlock() &#123; slock.unlock(); &#125;\n    void forceReset() &#123; slock.forceReset(); &#125;\n\n    &#x2F;&#x2F; Address-ordered lock discipline for a pair of side tables.\n\n    template&lt;HaveOld, HaveNew&gt;\n    static void lockTwo(SideTable *lock1, SideTable *lock2);\n    template&lt;HaveOld, HaveNew&gt;\n    static void unlockTwo(SideTable *lock1, SideTable *lock2);\n&#125;;</code></pre>\n\n<p><strong>SideTable</strong>本质上也是一个结构体，多个<strong>SideTable</strong>会构成一个集合，一张<strong>SideTable</strong>会管理多个对象，因此通常被称为<strong>SideTables</strong>，在系统中是全局唯一的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;\n\nstatic StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;\n    return SideTablesMap.get();\n&#125;</code></pre>\n\n<p><strong>SideTables</strong>被包裹在<strong>StripedMap</strong>类中，每个对象在进行引用计数管理时，都需要通过<strong>StripedMap</strong>的哈希算法，找到对应的<strong>SideTable</strong>表，之后再对引用计数进行管理。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; StripedMap 哈希算法\nstatic unsigned int indexForPointer(const void *p) &#123;\n    uintptr_t addr &#x3D; reinterpret_cast&lt;uintptr_t&gt;(p);\n    return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;\n&#125;</code></pre>\n\n<p>从<strong>SideTable</strong>的定义中得知，引用计数表<strong>refcnts</strong>的数据类型为<strong>RefcountMap</strong>，而<strong>RefcountMap</strong>实际上是一个<strong>模板类 DenseMap</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt; RefcountMap;</code></pre>\n\n<p>简单理解<strong>DenseMap</strong>就是一个<strong>map</strong>，其中<strong>key</strong>是<strong>DisguisedPtr<objc_object><strong>，</strong>value</strong>是对应的引用计数，另外在该<strong>map</strong>中会检测引用计数，当引用计数为0时，会自动将对象的引用计数数据清空。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void shrink_and_clear() &#123;\n    unsigned OldNumEntries &#x3D; NumEntries;\n    this-&gt;destroyAll();\n\n    &#x2F;&#x2F; Reduce the number of buckets.\n    unsigned NewNumBuckets &#x3D; 0;\n    if (OldNumEntries)\n      NewNumBuckets &#x3D; std::max(MIN_BUCKETS, 1 &lt;&lt; (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets &#x3D;&#x3D; NumBuckets) &#123;\n      this-&gt;BaseT::initEmpty();\n      return;\n    &#125;\n\n    operator delete(Buckets);\n    init(NewNumBuckets);\n  &#125;</code></pre>\n\n<p>在Objective-C中，当要获取一个对象的引用计数时，Runtime会分为三种情况进行获取，分别对应Tagged Pointer、优化的isa和未优化的isa。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">inline uintptr_t \nobjc_object::rootRetainCount()\n&#123;\n\t&#x2F;&#x2F; 如果是Tagged Pointer，则直接返回this\n    if (isTaggedPointer()) return (uintptr_t)this;\n\n    sidetable_lock();\n    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);\n    ClearExclusive(&amp;isa.bits);\n    &#x2F;&#x2F; 如果是优化的isa_t\n    if (bits.nonpointer) &#123;\n        uintptr_t rc &#x3D; 1 + bits.extra_rc;\n        &#x2F;&#x2F; 如果使用了sidetable，则从sidetable中获取引用计数\n        if (bits.has_sidetable_rc) &#123;\n        \t&#x2F;&#x2F; 总的引用计数 &#x3D; rc部分 + sidetable部分\n            rc +&#x3D; sidetable_getExtraRC_nolock();\n        &#125;\n        sidetable_unlock();\n        return rc;\n    &#125;\n\n    sidetable_unlock();\n    &#x2F;&#x2F; 如果是未优化的isa_t，则返回sidetable中的数据\n    return sidetable_retainCount();\n&#125;</code></pre>\n\n<p>在获取优化的isa_t类型对象的引用计数时，注意是要取两部分的记录，然后进行汇总，对应添加引用计数的步骤。在取SideTable部分记录的引用计数时，需要注意在记录中并不是直接获取，而是要根据存储的情况进行获取。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">size_t \nobjc_object::sidetable_getExtraRC_nolock()\n&#123;\n    ASSERT(isa.nonpointer);\n    SideTable&amp; table &#x3D; SideTables()[this];\n    &#x2F;&#x2F; 找到对应的引用计数表\n    RefcountMap::iterator it &#x3D; table.refcnts.find(this);\n    &#x2F;&#x2F; 如果表为空，则返回0\n    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;\n    &#x2F;&#x2F; 否则先进行移位操作，然后返回结果\n    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;\n&#125;</code></pre>\n\n<p><strong>#define SIDE_TABLE_RC_SHIFT 2</strong>宏定义直接使用在引用计数的获取流程中，是因为在引用计数表的低2位的位置存储的并不是引用计数，而是记录当前对象是否有弱引用，以及是否正在deallocing。</p>\n<h3 id=\"弱引用表\"><a href=\"#弱引用表\" class=\"headerlink\" title=\"弱引用表\"></a>弱引用表</h3><p>在<strong>SideTable</strong>的定义中，还有一个非常重要的属性<strong>weak_table_t weak_table</strong>，前文已经了解，<strong>weak_table</strong>是当前对象的弱引用表，存储着弱引用相关的信息，在Runtime中，其定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct weak_table_t &#123;\n    weak_entry_t *weak_entries; &#x2F;&#x2F; hash数组，存储弱引用对象的信息\n    size_t    num_entries; &#x2F;&#x2F; hash数组中元素个数\n    uintptr_t mask; &#x2F;&#x2F; hash数组长度-1，参与hash计算 \n    uintptr_t max_hash_displacement; &#x2F;&#x2F; 发生hash冲突的最大次数\n&#125;;</code></pre>\n\n<p><strong>weak_table_t</strong>中相对重要的是<strong>weak_entry_t</strong>类型的数组部分，可通过hash算法找到对应的对象在数组中的index，另外，<strong>weak_table_t</strong>具有动态扩容的特性，而<strong>sidetables</strong>的大小是固定64个。</p>\n<p><strong>weak_entries</strong>本质上是一个hash数组，数组中存储着<strong>weak_entry_t</strong>类型的元素。<strong>weak_entry_t</strong>定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;**\n * The internal structure stored in the weak references table. \n * It maintains and stores\n * a hash set of weak references pointing to an object.\n * If out_of_line_ness !&#x3D; REFERRERS_OUT_OF_LINE then the set\n * is instead a small inline array.\n *&#x2F;\n#define WEAK_INLINE_COUNT 4\n\n&#x2F;&#x2F; out_of_line_ness field overlaps with the low two bits of inline_referrers[1].\n&#x2F;&#x2F; inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.\n&#x2F;&#x2F; The low two bits of a pointer-aligned DisguisedPtr will always be 0b00\n&#x2F;&#x2F; (disguised nil or 0x80..00) or 0b11 (any other address).\n&#x2F;&#x2F; Therefore out_of_line_ness &#x3D;&#x3D; 0b10 is used to mark the out-of-line state.\n#define REFERRERS_OUT_OF_LINE 2\n\nstruct weak_entry_t &#123;\n    DisguisedPtr&lt;objc_object&gt; referent; &#x2F;&#x2F; 弱引用对象\n\n    &#x2F;&#x2F; 联合体，引用该对象的对象列表。\n    &#x2F;&#x2F; 引用个数小于4，使用inline_referrers数组\n    &#x2F;&#x2F; 引用个数大于4，使用weak_referrer_t *referrers动态数组\n    union &#123;\n        struct &#123;\n            weak_referrer_t *referrers; &#x2F;&#x2F; 弱引用该对象的对象数组，动态\n            uintptr_t        out_of_line_ness : 2; &#x2F;&#x2F; 是否使用动态数组的标记\n            uintptr_t        num_refs : PTR_MINUS_2; &#x2F;&#x2F; 动态数组中的元素个数\n            uintptr_t        mask; &#x2F;&#x2F; 参与hash计算，大小为数组大小-1，最终确定数组index\n            uintptr_t        max_hash_displacement; &#x2F;&#x2F; 最大hash冲突次数\n        &#125;;\n        struct &#123;\n            &#x2F;&#x2F; out_of_line_ness field is low bits of inline_referrers[1]\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        &#125;;\n    &#125;;\n\n    bool out_of_line() &#123;\n        return (out_of_line_ness &#x3D;&#x3D; REFERRERS_OUT_OF_LINE);\n    &#125;\n\n    weak_entry_t&amp; operator&#x3D;(const weak_entry_t&amp; other) &#123;\n        memcpy(this, &amp;other, sizeof(other));\n        return *this;\n    &#125;\n\n    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)\n        : referent(newReferent)\n    &#123;\n        inline_referrers[0] &#x3D; newReferrer;\n        for (int i &#x3D; 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;\n            inline_referrers[i] &#x3D; nil;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<p>在查找弱引用对象的时候，始终使用的是hash定位的方式，在runtime中，弱引用所使用的hash定位算法如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static weak_entry_t *\nweak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)\n&#123;\n    ASSERT(referent);\n\n    &#x2F;&#x2F; 获取弱引用表中所有弱引用对象\n    weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;\n\n    if (!weak_entries) return nil;\n    &#x2F;&#x2F; 确定hash值对应数组的开始索引，内部调用 ptr_hash 函数\n    &#x2F;&#x2F; 1. 获取到对象的hash指针\n    &#x2F;&#x2F; 2. 与如引用表的 mask 进行 位与 运算\n    &#x2F;&#x2F; 这样的目的是为了减小数值，便于计算。1000...000类型转变为 011...1 的形式\n    size_t begin &#x3D; hash_pointer(referent) &amp; weak_table-&gt;mask;\n    size_t index &#x3D; begin;\n    size_t hash_displacement &#x3D; 0;\n    &#x2F;&#x2F; 遍历对象数组\n    while (weak_table-&gt;weak_entries[index].referent !&#x3D; referent) &#123;\n    \t&#x2F;&#x2F; 加入位与运算，防止数组下标越界\n        index &#x3D; (index+1) &amp; weak_table-&gt;mask;\n        &#x2F;&#x2F; 寻找一轮后，没有找到对应元素，触发 bad_weak_table\n        if (index &#x3D;&#x3D; begin) bad_weak_table(weak_table-&gt;weak_entries);\n        &#x2F;&#x2F; hash冲突增加\n        hash_displacement++;\n        &#x2F;&#x2F; 如果hash冲突大于最大可能冲突次数，说明目标元素不在数组中，返回nil\n        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;\n            return nil;\n        &#125;\n    &#125;\n\n    return &amp;weak_table-&gt;weak_entries[index];\n&#125;\n\nstatic inline uint32_t ptr_hash(uint64_t key)\n&#123;\n    key ^&#x3D; key &gt;&gt; 4;\n    key *&#x3D; 0x8a970be7488fda55;\n    key ^&#x3D; __builtin_bswap64(key);\n    return (uint32_t)key;\n&#125;</code></pre>\n\n<p>在进行hash定位的时候，有一个巧妙的操作语句：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">index &#x3D; (index+1) &amp; weak_table-&gt;mask;</code></pre>\n\n<p>该语句会在当前位置的下一个相邻位置进行查找，同时当查找到最后一个位置时，会自动从数组的第一个位置开始查找，也就是巧妙的实现了数组的轮转查找，也保证了数组下表不会越界。</p>\n<p>由于弱引用表的大小不是固定的，而是随着元素的插入和删除进行动态调整大小的，因此关键在于学习Runtime是如何对其进行动态大小调整的。</p>\n<h4 id=\"动态扩容\"><a href=\"#动态扩容\" class=\"headerlink\" title=\"动态扩容\"></a>动态扩容</h4><p>扩容主要发生在表格容量满的时候，而进行扩容前，而在Runtime中会进行提前扩容，需要先判断存储表是否需要进行扩容，判断方法如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)\n\n&#x2F;&#x2F; Grow the given zone&#39;s table of weak references if it is full.\nstatic void weak_grow_maybe(weak_table_t *weak_table)\n&#123;\n    size_t old_size &#x3D; TABLE_SIZE(weak_table);\n\n    &#x2F;&#x2F; Grow if at least 3&#x2F;4 full.\n    if (weak_table-&gt;num_entries &gt;&#x3D; old_size * 3 &#x2F; 4) &#123;\n        weak_resize(weak_table, old_size ? old_size*2 : 64);\n    &#125;\n&#125;</code></pre>\n\n<p>判断的依据在于 <strong>weak_table-&gt;num_entries &gt;&#x3D; old_size * 3 &#x2F; 4</strong>，即当当前存储表的容量仅剩下1&#x2F;4的时候，会进行扩容操作。具体的扩容操作是在<strong>weak_resize</strong>中进行的，也就是后文所说的<strong>容量重置</strong>部分。</p>\n<p>进行扩容后，存储表的容量会比原有容量大一倍，这么做的目的在于，放置后序频繁的进行内存申请，以及既然这次要扩容，后序扩容的几率会更大，不如一次扩多点。</p>\n<h4 id=\"动态收缩\"><a href=\"#动态收缩\" class=\"headerlink\" title=\"动态收缩\"></a>动态收缩</h4><p>存储表容量的压缩通常发生在删除了其中一些元素之后，此时系统会调用<strong>weak_compact_maybe</strong>判断当前存储表是否需要收缩：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; Shrink the table if it is mostly empty.\nstatic void weak_compact_maybe(weak_table_t *weak_table)\n&#123;\n    size_t old_size &#x3D; TABLE_SIZE(weak_table);\n\n    &#x2F;&#x2F; Shrink if larger than 1024 buckets and at most 1&#x2F;16 full.\n    if (old_size &gt;&#x3D; 1024  &amp;&amp; old_size &#x2F; 16 &gt;&#x3D; weak_table-&gt;num_entries) &#123;\n        weak_resize(weak_table, old_size &#x2F; 8);\n        &#x2F;&#x2F; leaves new table no more than 1&#x2F;2 full\n    &#125;\n&#125;</code></pre>\n\n<p>此时判断的依据是<strong>old_size &gt;&#x3D; 1024  &amp;&amp; old_size &#x2F; 16 &gt;&#x3D; weak_table-&gt;num_entries</strong>，即容量已经超过1024字节以及存储表容量最多只使用了1&#x2F;16的时候，会进行容量收缩处理，而收缩是按照现有容量的八倍大小进行收缩的。</p>\n<h4 id=\"容量重置\"><a href=\"#容量重置\" class=\"headerlink\" title=\"容量重置\"></a>容量重置</h4><p>无论是扩容，还是收缩，都调用了<strong>weak_resize</strong>进行容量的处理。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void weak_resize(weak_table_t *weak_table, size_t new_size)\n&#123;\n    size_t old_size &#x3D; TABLE_SIZE(weak_table);\n    &#x2F;&#x2F; 取出原始数据\n    weak_entry_t *old_entries &#x3D; weak_table-&gt;weak_entries;\n    &#x2F;&#x2F; 给新的容量申请内存\n    weak_entry_t *new_entries &#x3D; (weak_entry_t *)\n        calloc(new_size, sizeof(weak_entry_t));\n    &#x2F;&#x2F; 重置weak_table容量相关属性\n    weak_table-&gt;mask &#x3D; new_size - 1; &#x2F;&#x2F; 数组大小-1\n    weak_table-&gt;weak_entries &#x3D; new_entries; &#x2F;&#x2F; 元素\n    weak_table-&gt;max_hash_displacement &#x3D; 0; &#x2F;&#x2F; 最大hash冲突重置\n    weak_table-&gt;num_entries &#x3D; 0;  &#x2F;&#x2F; restored by weak_entry_insert below\n    \n    if (old_entries) &#123;\n        weak_entry_t *entry;\n        weak_entry_t *end &#x3D; old_entries + old_size;\n        &#x2F;&#x2F; 遍历元素数组，将元素重新插入到新的存储表中\n        for (entry &#x3D; old_entries; entry &lt; end; entry++) &#123;\n            if (entry-&gt;referent) &#123;\n                weak_entry_insert(weak_table, entry);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 最后释放掉老的内存空间\n        free(old_entries);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 元素的插入操作\nstatic void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)\n&#123;\n    weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;\n    ASSERT(weak_entries !&#x3D; nil);\n\n    size_t begin &#x3D; hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);\n    size_t index &#x3D; begin;\n    size_t hash_displacement &#x3D; 0;\n    while (weak_entries[index].referent !&#x3D; nil) &#123;\n        index &#x3D; (index+1) &amp; weak_table-&gt;mask;\n        if (index &#x3D;&#x3D; begin) bad_weak_table(weak_entries);\n        hash_displacement++;\n    &#125;\n\n    weak_entries[index] &#x3D; *new_entry;\n    weak_table-&gt;num_entries++;\n\n    if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;\n        weak_table-&gt;max_hash_displacement &#x3D; hash_displacement;\n    &#125;\n&#125;</code></pre>\n\n<p>也就是说，弱引用存储表的容量在扩容的时候，并不是在原有存储表上进行直接扩容的，而是根据新的大小开辟了一块新的内存空间，同时将老的数据完整迁移到新的内存空间上，然后释放掉老的存储表。</p>\n<h2 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"autoreleasepool\"></a>autoreleasepool</h2><p>在iOS中，第三种内存管理的方式是<strong>autoreleasepool</strong>，在ARC中，通常直接使用**@autoreleasepool{}**的方式使用，其中包裹的对象的内存管理工作就交给了自动释放池进行管理。</p>\n<p>关于<strong>autoreleasepool</strong>这里不再详述，具体可查看开源项目<a href=\"https://github.com/opensource-apple/objc4\">objc</a>。</p>\n","text":"我们都知道，iOS中进行内存管理的管理模型是引用计数，但是这属于上层应用的范畴，在系统底层，iOS会根据不同的数据结构或者不同的数据类型，进行系统内存的分区，在不同的分区中，管理着自己的内存，另外，iOS的内存管理并不直接管理硬件内存，而是管理着硬件内存之上的一个过渡内存—虚拟内...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iOS-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">iOS 内存分区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tagged-Pointer\"><span class=\"toc-text\">Tagged Pointer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NONPOINTER-ISA\"><span class=\"toc-text\">NONPOINTER_ISA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SideTable\"><span class=\"toc-text\">SideTable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E5%BC%95%E7%94%A8%E8%A1%A8\"><span class=\"toc-text\">弱引用表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">动态扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E6%94%B6%E7%BC%A9\"><span class=\"toc-text\">动态收缩</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E9%87%8F%E9%87%8D%E7%BD%AE\"><span class=\"toc-text\">容量重置</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#autoreleasepool\"><span class=\"toc-text\">autoreleasepool</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"Runtime剖析04 --- 深入理解Category","uid":"c6997d59d32873c326b54f9cbde95646","slug":"2020-07-01-iOS-runtime-category","date":"2023-05-19T09:57:19.845Z","updated":"2023-05-19T09:57:19.845Z","comments":true,"path":"api/articles/2020-07-01-iOS-runtime-category.json","keywords":null,"cover":null,"text":"在Objective-C中，可以通过Category添加属性、方法、协议，在Runtime中Class和Category都是通过结构体实现的。和Category相似的还有Extension，二者的区别在于，Extension在编译期就直接和原类编译在一起，而Category是在运...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"《实现模式》读书小记","uid":"e82075038d4d045b9b352d5ca62ff95f","slug":"2022-05-01-iOS-implementation-patterns-tips","date":"2023-05-19T09:57:19.845Z","updated":"2023-05-19T09:57:19.845Z","comments":true,"path":"api/articles/2022-05-01-iOS-implementation-patterns-tips.json","keywords":null,"cover":"/images/cover/2022-05-01-iOS-implementation-patterns-tips.jpg","text":"《实现模式》一书作者Kent Beck，软件开发方法学的泰山北斗，是最早研究软件开发模式和重构方法论的先导者之一，是敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人。该书是一本关于如何撰写代码的书。本书中的模式，是基于 Kent 对现存代码的阅读以及他自己的编程习惯而形成...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"读书小记","slug":"读书小记","count":2,"path":"api/categories/读书小记.json"}],"tags":[{"name":"读书小记","slug":"读书小记","count":2,"path":"api/tags/读书小记.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}