{"title":"iOS虚拟内存管理","uid":"11480c51ae26bed2fd1029069074ca32","slug":"2019-01-22-iOS_VMManage","date":"2023-05-24T09:24:36.371Z","updated":"2023-05-24T09:24:36.371Z","comments":true,"path":"api/articles/2019-01-22-iOS_VMManage.json","keywords":null,"cover":"/images/vm/memory_manage.jpg","content":"<p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p>\n<h2 id=\"虚拟内存概述\"><a href=\"#虚拟内存概述\" class=\"headerlink\" title=\"虚拟内存概述\"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p>\n<p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p>\n<p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p>\n<p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"虚拟内存的限制\"><a href=\"#虚拟内存的限制\" class=\"headerlink\" title=\"虚拟内存的限制\"></a>虚拟内存的限制</h2><p>在iOS开发的过程中，难免手动去申请内存，目前大多数的移动设备都是ARM64的设备，即使用的是64位寻址空间，而且在iOS上通过malloc申请的内存只是虚拟内存，不是真正的物理内存，那么在iOS设备上为什么会出现申请了2-3G就会出现申请失败呢？</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void *buffer &#x3D; malloc(2000 * 1024 * 1024);</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">malloc: *** mach_vm_map(size&#x3D;2097152000) failed (error code&#x3D;3)\n*** error: can&#39;t allocate region</code></pre>\n\n<p>当申请分配一个超大的内存时，iOS系统会按照<code>nano_zone</code>和<code>scalable_zone</code>的设计理念进行内存的申请，申请原理如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void *    szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested)\n&#123;\n    void *ptr;\n    msize_t msize;\n\n    if (size &lt;&#x3D; SMALL_THRESHOLD) &#123;\n        &#x2F;&#x2F; tiny size: &lt;1024 bytes (64-bit), &lt;512 bytes (32-bit)\n        &#x2F;&#x2F; think tiny\n        msize &#x3D; TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1);\n        if (!msize) &#123;\n            msize &#x3D; 1;\n        &#125;\n        ptr &#x3D; tiny_malloc_should_clear(szone, msize, cleared_requested);\n    &#125; else if (size &lt;&#x3D; szone-&gt;large_threshold) &#123;\n        &#x2F;&#x2F; small size: &lt;15k (&lt;1GB machines), &lt;127k (&gt;1GB machines)\n        &#x2F;&#x2F; think small\n        msize &#x3D; SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1);\n        if (!msize) &#123;\n            msize &#x3D; 1;\n        &#125;\n        ptr &#x3D; small_malloc_should_clear(szone, msize, cleared_requested);\n    &#125; else &#123;\n        &#x2F;&#x2F; large: all other allocations\n        size_t num_kernel_pages &#x3D; round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;\n        if (num_kernel_pages &#x3D;&#x3D; 0) &#123; &#x2F;* Overflowed *&#x2F;\n            ptr &#x3D; 0;\n        &#125; else &#123;\n            ptr &#x3D; large_malloc(szone, num_kernel_pages, 0, cleared_requested);\n        &#125;\n    &#125;\n#if DEBUG_MALLOC\n    if (LOG(szone, ptr)) &#123;\n        malloc_printf(&quot;szone_malloc returned %p\\n&quot;, ptr);\n    &#125;\n#endif\n    &#x2F;*\n     * If requested, scribble on allocated memory.\n     *&#x2F;\n    if ((szone-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; ptr &amp;&amp; !cleared_requested &amp;&amp; size) &#123;\n        memset(ptr, SCRIBBLE_BYTE, szone_size(szone, ptr));\n    &#125;\n\n    return ptr;\n&#125;</code></pre>\n\n<ul>\n<li>小于1k的走 tiny_malloc</li>\n<li>小于15k或者127k的走 small_malloc （视具体不同的设备内存上限不同）</li>\n<li>剩下的走 large_malloc</li>\n</ul>\n<p>由于我们分配的非常大，我们可以确定我们的逻辑是落入<code>large_malloc</code>中。需要特别注意的是： <code>large_malloc</code>分配内存的基本单位是一页大小，而对于其他的几种分配方式，则不是必须按照页大小进行分配。</p>\n<p>由于 <code>large_malloc</code> 这个函数本身并没有特殊需要注意的地方，我们直接关注其真正分配内存的地方，即 <code>allocate_pages</code> ，如下所示：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">vm_addr &#x3D; vm_page_quanta_size;\nkr &#x3D; mach_vm_map(mach_task_self(), &amp;vm_addr, allocation_size, allocation_mask, alloc_flags, MEMORY_OBJECT_NULL, 0, FALSE,\n            VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);\nif (kr) &#123;\n    szone_error(szone, 0, &quot;can&#39;t allocate region&quot;, NULL, &quot;*** mach_vm_map(size&#x3D;%lu) failed (error code&#x3D;%d)\\n&quot;, size, kr);\n    return NULL;\n&#125;\naddr &#x3D; (uintptr_t)vm_addr;</code></pre>\n\n<p>从上不难看出，如果分配失败，就是提示报错。而 <code>mach_vm_map</code> 则是整个内存的分配核心。</p>\n<p><img src=\"/images/vm/virtual.png\"></p>\n<p>概括来说，<code>vm_map</code> 代表就是一个进程运行时候涉及的虚拟内存， <code>pmap</code> 代表的就是和具体硬件架构相关的物理内存。（这里我们暂时先不考虑 <code>submap</code> 这种情况）。</p>\n<p><code>vm_map</code>本身是进程（或者从Mach内核的角度看是task的地址分布图）。这个地址分布图维护着一个 <strong>双向列表</strong> ，列表的每一项都是 <code>vm_entry_t</code> ，代表着虚拟地址上连续的一个范围。而 <code>pmap</code> 这个结构体代表了个硬件相关的内存转换：即利用 <code>pmap</code> 这个结构体来描述抽象的物理地址访问和使用。</p>\n<h2 id=\"进程（任务）的创建\"><a href=\"#进程（任务）的创建\" class=\"headerlink\" title=\"进程（任务）的创建\"></a>进程（任务）的创建</h2><p>对于在iOS上的进程创建和加载执行Mach-O过程，有必要进行一个简单的介绍，在类UNIX系统本质上是不会无缘无故创建出一个进程的，基本上必须通过<code>fork</code>的形式来创建。无论是用户态调用<code>posix</code>相关的API还是别的API，最终落入内核是均是通过函数<code>fork_create_child</code>来创建属于Mach内核的任务。实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">thread_t\nfork_create_child(task_t parent_task, proc_t child, int inherit_memory, int is64bit)\n&#123;\n\tthread_t\tchild_thread &#x3D; NULL;\n\ttask_t\t\tchild_task;\n\tkern_return_t\tresult;\n\n\t&#x2F;* Create a new task for the child process *&#x2F;\n\tresult &#x3D; task_create_internal(parent_task,\n\t\t\t\t\tinherit_memory,\n\t\t\t\t\tis64bit,\n\t\t\t\t\t&amp;child_task);\n\tif (result !&#x3D; KERN_SUCCESS) &#123;\n\t\tprintf(&quot;execve: task_create_internal failed.  Code: %d\\n&quot;, result);\n\t\tgoto bad;\n\t&#125;\n\n\t&#x2F;* Set the child task to the new task *&#x2F;\n\tchild-&gt;task &#x3D; child_task;\n\n\t&#x2F;* Set child task proc to child proc *&#x2F;\n\tset_bsdtask_info(child_task, child);\n\n\t&#x2F;* Propagate CPU limit timer from parent *&#x2F;\n\tif (timerisset(&amp;child-&gt;p_rlim_cpu))\n\t\ttask_vtimer_set(child_task, TASK_VTIMER_RLIM);\n\n\t&#x2F;* Set&#x2F;clear 64 bit vm_map flag *&#x2F;\n\tif (is64bit)\n\t\tvm_map_set_64bit(get_task_map(child_task));\n\telse\n\t\tvm_map_set_32bit(get_task_map(child_task));\n\n#if CONFIG_MACF\n\t&#x2F;* Update task for MAC framework *&#x2F;\n\t&#x2F;* valid to use p_ucred as child is still not running ... *&#x2F;\n\tmac_task_label_update_cred(child-&gt;p_ucred, child_task);\n#endif\n\n\t&#x2F;* Set child scheduler priority if nice value inherited from parent *&#x2F;\n\tif (child-&gt;p_nice !&#x3D; 0)\n\t\tresetpriority(child);\n\n\t&#x2F;* Create a new thread for the child process *&#x2F;\n\tresult &#x3D; thread_create(child_task, &amp;child_thread);\n\tif (result !&#x3D; KERN_SUCCESS) &#123;\n\t\tprintf(&quot;execve: thread_create failed. Code: %d\\n&quot;, result);\n\t\ttask_deallocate(child_task);\n\t\tchild_task &#x3D; NULL;\n\t&#125;\nbad:\n\tthread_yield_internal(1);\n\n\treturn(child_thread);\n&#125;</code></pre>\n\n<ul>\n<li>要注意的就是<strong>Mach内核里面没有进程的概念，只有任务</strong>，进程是属于BSD之上的抽象。它们之间的联系就是通过指针建立， <code>child_proc-&gt;task = child_task</code>。</li>\n</ul>\n<p><code>fork</code>出来的进程像是一个空壳，需要利用这个进程壳去执行科执行文件编程有意义的<strong>程序进程</strong>。从XNU上看，可执行文件的类型有如下分类：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#123; exec_mach_imgact,        &quot;Mach-o Binary&quot; &#125;,\n&#123; exec_fat_imgact,        &quot;Fat Binary&quot; &#125;,\n&#123; exec_shell_imgact,    &quot;Interpreter Script&quot; &#125;</code></pre>\n\n<p>常用的通常是<code>Mach-o</code>文件：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">exec_mach_imgact(struct image_params *imgp)\n&#123;\n    ... 省略无数\n\n    if ((mach_header-&gt;magic &#x3D;&#x3D; MH_CIGAM) ||\n        (mach_header-&gt;magic &#x3D;&#x3D; MH_CIGAM_64)) &#123;\n        error &#x3D; EBADARCH;\n        goto bad;\n    &#125;\n\n    if ((mach_header-&gt;magic !&#x3D; MH_MAGIC) &amp;&amp;\n        (mach_header-&gt;magic !&#x3D; MH_MAGIC_64)) &#123;\n        error &#x3D; -1;\n        goto bad;\n    &#125;\n\n    if (mach_header-&gt;filetype !&#x3D; MH_EXECUTE) &#123;\n        error &#x3D; -1;\n        goto bad;\n    &#125;\n\n    if (imgp-&gt;ip_origcputype !&#x3D; 0) &#123;\n        &#x2F;* Fat header previously had an idea about this thin file *&#x2F;\n        if (imgp-&gt;ip_origcputype !&#x3D; mach_header-&gt;cputype ||\n            imgp-&gt;ip_origcpusubtype !&#x3D; mach_header-&gt;cpusubtype) &#123;\n            error &#x3D; EBADARCH;\n            goto bad;\n        &#125;\n    &#125; else &#123;\n        imgp-&gt;ip_origcputype &#x3D; mach_header-&gt;cputype;\n        imgp-&gt;ip_origcpusubtype &#x3D; mach_header-&gt;cpusubtype;\n    &#125;\n\n    task &#x3D; current_task();\n    thread &#x3D; current_thread();\n    uthread &#x3D; get_bsdthread_info(thread);\n\n    if ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) &#x3D;&#x3D; CPU_ARCH_ABI64)\n        imgp-&gt;ip_flags |&#x3D; IMGPF_IS_64BIT;\n\n    &#x2F;* If posix_spawn binprefs exist, respect those prefs. *&#x2F;\n    psa &#x3D; (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;\n    if (psa !&#x3D; NULL &amp;&amp; psa-&gt;psa_binprefs[0] !&#x3D; 0) &#123;\n        int pr &#x3D; 0;\n        for (pr &#x3D; 0; pr &lt; NBINPREFS; pr++) &#123;\n            cpu_type_t pref &#x3D; psa-&gt;psa_binprefs[pr];\n            if (pref &#x3D;&#x3D; 0) &#123;\n                &#x2F;* No suitable arch in the pref list *&#x2F;\n                error &#x3D; EBADARCH;\n                goto bad;\n            &#125;\n\n            if (pref &#x3D;&#x3D; CPU_TYPE_ANY) &#123;\n                &#x2F;* Jump to regular grading *&#x2F;\n                goto grade;\n            &#125;\n\n            if (pref &#x3D;&#x3D; imgp-&gt;ip_origcputype) &#123;\n                &#x2F;* We have a match! *&#x2F;\n                goto grade;\n            &#125;\n        &#125;\n        error &#x3D; EBADARCH;\n        goto bad;\n    &#125;\ngrade:\n    if (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) &#123;\n        error &#x3D; EBADARCH;\n        goto bad;\n    &#125;\n\n    &#x2F;* Copy in arguments&#x2F;environment from the old process *&#x2F;\n    error &#x3D; exec_extract_strings(imgp);\n    if (error)\n        goto bad;\n\n    AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, \n        imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);\n    AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,\n        imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);\n\n    &#x2F;* reset local idea of thread, uthread, task *&#x2F;\n    thread &#x3D; imgp-&gt;ip_new_thread;\n    uthread &#x3D; get_bsdthread_info(thread);\n    task &#x3D; new_task &#x3D; get_threadtask(thread);\n\n    &#x2F;&#x2F; 注意点：\n    lret &#x3D; load_machfile(imgp, mach_header, thread, &amp;map, &amp;load_result);\n\n    ... 省略无数</code></pre>\n\n<p>上面的代码基本上都是在对文件进行各种检查，然后分配一个预使用的进程壳，之后使用<code>load_machfile</code>加载真正的二进制文件。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">load_return_t\nload_machfile(\n    struct image_params    *imgp,\n    struct mach_header    *header,\n    thread_t         thread,\n    vm_map_t         *mapp,\n    load_result_t        *result\n)\n&#123;\n    ... 省略一大堆\n\n    if (macho_size &gt; file_size) &#123;\n        return(LOAD_BADMACHO);\n    &#125;\n\n    result-&gt;is64bit &#x3D; ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) &#x3D;&#x3D; IMGPF_IS_64BIT);\n\n    task_t ledger_task;\n    if (imgp-&gt;ip_new_thread) &#123;\n        ledger_task &#x3D; get_threadtask(imgp-&gt;ip_new_thread);\n    &#125; else &#123;\n        ledger_task &#x3D; task;\n    &#125;\n\n    &#x2F;&#x2F; 注意点1\n    pmap &#x3D; pmap_create(get_task_ledger(ledger_task),\n               (vm_map_size_t) 0,\n               result-&gt;is64bit);\n\n    &#x2F;&#x2F; 注意点2\n    map &#x3D; vm_map_create(pmap,\n,\n            vm_compute_max_offset(result-&gt;is64bit),\n            TRUE);\n\n#if defined(__arm64__)\n    &#x2F;&#x2F; 注意点三\n    if (result-&gt;is64bit) &#123;\n        &#x2F;* enforce 16KB alignment of VM map entries *&#x2F;\n        vm_map_set_page_shift(map, SIXTEENK_PAGE_SHIFT);\n    &#125; else &#123;\n        vm_map_set_page_shift(map, page_shift_user32);\n    &#125;</code></pre>\n\n<ul>\n<li>利用 <code>pmap_create</code> 创建硬件相关的物理内存抽象。</li>\n<li>利用 <code>vmap_create</code> 创建虚拟内存的地址图。</li>\n<li>ARM64下的页是16k一个虚拟页对应一个物理页。</li>\n</ul>\n<p>这里需要重点关注 <code>vm_map_create 0</code> 和 <code>vm_compute_max_offset(result-&gt;is64bit)</code>，代表着当前任务分配的虚拟内存地址的上下限， <code>vm_compute_max_offset</code>函数实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">vm_map_offset_t\nvm_compute_max_offset(boolean_t is64)\n&#123;\n#if defined(__arm__) || defined(__arm64__)\n    return (pmap_max_offset(is64, ARM_PMAP_MAX_OFFSET_DEVICE));\n#else\n    return (is64 ? (vm_map_offset_t)MACH_VM_MAX_ADDRESS : (vm_map_offset_t)VM_MAX_ADDRESS);\n#endif\n&#125;</code></pre>\n\n<p><code>pmap_max_offset</code>函数实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">vm_map_offset_t pmap_max_offset(\n    boolean_t    is64 __unused,\n    unsigned int    option)\n&#123;\n    vm_map_offset_t    max_offset_ret &#x3D; 0;\n\n#if defined(__arm64__)\n    assert (is64);\n    vm_map_offset_t min_max_offset &#x3D; SHARED_REGION_BASE_ARM64 + SHARED_REGION_SIZE_ARM64 + 0x20000000; &#x2F;&#x2F; end of shared region + 512MB for various purposes\n    if (option &#x3D;&#x3D; ARM_PMAP_MAX_OFFSET_DEFAULT) &#123;\n        max_offset_ret &#x3D; arm64_pmap_max_offset_default;\n    &#125; else if (option &#x3D;&#x3D; ARM_PMAP_MAX_OFFSET_MIN) &#123;\n        max_offset_ret &#x3D; min_max_offset;\n    &#125; else if (option &#x3D;&#x3D; ARM_PMAP_MAX_OFFSET_MAX) &#123;\n        max_offset_ret &#x3D; MACH_VM_MAX_ADDRESS;\n    &#125; else if (option &#x3D;&#x3D; ARM_PMAP_MAX_OFFSET_DEVICE) &#123;\n        if (arm64_pmap_max_offset_default) &#123;\n            max_offset_ret &#x3D; arm64_pmap_max_offset_default;\n        &#125; else if (max_mem &gt; 0xC0000000) &#123;\n            max_offset_ret &#x3D; 0x0000000318000000ULL;     &#x2F;&#x2F; Max offset is 12.375GB for devices with &gt; 3GB of memory\n        &#125; else if (max_mem &gt; 0x40000000) &#123;\n            max_offset_ret &#x3D; 0x0000000218000000ULL;     &#x2F;&#x2F; Max offset is 8.375GB for devices with &gt; 1GB and &lt;&#x3D; 3GB of memory\n        &#125; else &#123;\n            max_offset_ret &#x3D; min_max_offset;\n        &#125;\n    &#125; else if (option &#x3D;&#x3D; ARM_PMAP_MAX_OFFSET_JUMBO) &#123;\n        max_offset_ret &#x3D; 0x0000000518000000ULL;     &#x2F;&#x2F; Max offset is 20.375GB for pmaps with special &quot;jumbo&quot; blessing\n    &#125; else &#123;\n        panic(&quot;pmap_max_offset illegal option 0x%x\\n&quot;, option);\n    &#125;\n\n    assert(max_offset_ret &gt;&#x3D; min_max_offset);\n    return max_offset_ret;</code></pre>\n\n<p>这里的关键点代码是：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (max_mem &gt; 0xC0000000) &#123;\n    max_offset_ret &#x3D; 0x0000000318000000ULL;     &#x2F;&#x2F; Max offset is 12.375GB for devices with &gt; 3GB of memory\n&#125; else if (max_mem &gt; 0x40000000) &#123;\n    max_offset_ret &#x3D; 0x0000000218000000ULL;     &#x2F;&#x2F; Max offset is 8.375GB for devices with &gt; 1GB and &lt;&#x3D; 3GB of memory\n&#125; else &#123;\n    max_offset_ret &#x3D; min_max_offset;\n&#125;</code></pre>\n\n<p><code>max_offset_ret</code> 这个值就代表了我们任务对应的 <code>vm_map_t</code> 的最大地址范围，比如说这里是8.375GB。</p>\n<h2 id=\"虚拟内存分配的限制\"><a href=\"#虚拟内存分配的限制\" class=\"headerlink\" title=\"虚拟内存分配的限制\"></a>虚拟内存分配的限制</h2><p>之前提到了 <code>large_malloc</code> 会走入到最后的 <code>vm_map_enter</code> ，那么我们来看看 <code>vm_map_enter</code> 的实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">vm_map_enter(\n    vm_map_t        map,\n    vm_map_offset_t        *address,    &#x2F;* IN&#x2F;OUT *&#x2F;\n    vm_map_size_t        size,\n    vm_map_offset_t        mask,\n    int            flags,\n    vm_map_kernel_flags_t    vmk_flags,\n    vm_tag_t        alias,\n    vm_object_t        object,\n    vm_object_offset_t    offset,\n    boolean_t        needs_copy,\n    vm_prot_t        cur_protection,\n    vm_prot_t        max_protection,\n    vm_inherit_t        inheritance)\n&#123;\n\n#if CONFIG_EMBEDDED\n    &#x2F;&#x2F; 注意点1:检查页的权限\n    if (cur_protection &amp; VM_PROT_WRITE)&#123;\n        if ((cur_protection &amp; VM_PROT_EXECUTE) &amp;&amp; !entry_for_jit)&#123;\n            printf(&quot;EMBEDDED: %s: curprot cannot be write+execute. &quot;\n                   &quot;turning off execute\\n&quot;,\n                   __FUNCTION__);\n            cur_protection &amp;&#x3D; ~VM_PROT_EXECUTE;\n        &#125;\n    &#125;\n#endif &#x2F;* CONFIG_EMBEDDED *&#x2F;\n\n    if (resilient_codesign || resilient_media) &#123;\n        if ((cur_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE)) ||\n            (max_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE))) &#123;\n            return KERN_PROTECTION_FAILURE;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 1. 获取任务的可用的地址最小值和最大值\n    effective_min_offset &#x3D; map-&gt;min_offset;\n    effective_max_offset &#x3D; map-&gt;max_offset;\n\n    if (map-&gt;pmap &#x3D;&#x3D; kernel_pmap) &#123;\n        user_alias &#x3D; VM_KERN_MEMORY_NONE;\n    &#125; else &#123;\n        user_alias &#x3D; alias;\n    &#125;\n\n#define    RETURN(value)    &#123; result &#x3D; value; goto BailOut; &#125;\n\n    assert(page_aligned(*address));\n    assert(page_aligned(size));\n\n    if (!VM_MAP_PAGE_ALIGNED(size, VM_MAP_PAGE_MASK(map))) &#123;\n        clear_map_aligned &#x3D; TRUE;\n    &#125;\n\nStartAgain: ;\n\n    start &#x3D; *address;\n\n    if (anywhere) &#123;\n        vm_map_lock(map);\n        map_locked &#x3D; TRUE;\n\n        if (start &lt; effective_min_offset)\n            start &#x3D; effective_min_offset;\n        if (start &gt; effective_max_offset)\n            RETURN(KERN_NO_SPACE);\n\n\n        if( FALSE ) &#123;\n\n        &#125; else &#123;\n\n            if (map-&gt;holelistenabled) &#123;\n                hole_entry &#x3D; (vm_map_entry_t)map-&gt;holes_list;\n\n                if (hole_entry &#x3D;&#x3D; NULL) &#123;\n                    &#x2F;*\n                     * No more space in the map?\n                     *&#x2F;\n                    result &#x3D; KERN_NO_SPACE;\n                    goto BailOut;\n                &#125; else &#123;\n\n                    boolean_t found_hole &#x3D; FALSE;\n\n                    do &#123;\n                        if (hole_entry-&gt;vme_start &gt;&#x3D; start) &#123;\n                            start &#x3D; hole_entry-&gt;vme_start;\n                            found_hole &#x3D; TRUE;\n                            break;\n                        &#125;\n\n                        if (hole_entry-&gt;vme_end &gt; start) &#123;\n                            found_hole &#x3D; TRUE;\n                            break;\n                        &#125;\n                        hole_entry &#x3D; hole_entry-&gt;vme_next;\n\n                    &#125; while (hole_entry !&#x3D; (vm_map_entry_t) map-&gt;holes_list);\n\n                    if (found_hole &#x3D;&#x3D; FALSE) &#123;\n                        result &#x3D; KERN_NO_SPACE;\n                        goto BailOut;\n                    &#125;\n\n                    entry &#x3D; hole_entry;\n\n                    if (start &#x3D;&#x3D; 0)\n                        start +&#x3D; PAGE_SIZE_64;\n                &#125;\n            &#125;\n        &#125;\n\n        while (TRUE) &#123;\n            vm_map_entry_t    next;\n\n            end &#x3D; ((start + mask) &amp; ~mask);\n            end &#x3D; vm_map_round_page(end,\n                        VM_MAP_PAGE_MASK(map));\n\n            if (end &lt; start)\n                RETURN(KERN_NO_SPACE);\n\n            start &#x3D; end;\n            end +&#x3D; size;\n\n            if ((end &gt; effective_max_offset) || (end &lt; start)) &#123;\n                RETURN(KERN_NO_SPACE);\n            &#125;\n\n            next &#x3D; entry-&gt;vme_next;\n\n            if (map-&gt;holelistenabled) &#123;\n                if (entry-&gt;vme_end &gt;&#x3D; end)\n                    break;\n            &#125; else &#123;\n\n                if (next &#x3D;&#x3D; vm_map_to_entry(map))\n                    break;\n\n                if (next-&gt;vme_start &gt;&#x3D; end)\n                    break;\n            &#125;\n\n            entry &#x3D; next;\n\n            if (map-&gt;holelistenabled) &#123;\n                if (entry &#x3D;&#x3D; (vm_map_entry_t) map-&gt;holes_list) &#123;\n                    result &#x3D; KERN_NO_SPACE;\n                    goto BailOut;\n                &#125;\n                start &#x3D; entry-&gt;vme_start;\n            &#125; else &#123;\n                start &#x3D; entry-&gt;vme_end;\n            &#125;\n\n            start &#x3D; vm_map_round_page(start,\n                          VM_MAP_PAGE_MASK(map));\n        &#125;\n\n        if (map-&gt;holelistenabled) &#123;\n            if (vm_map_lookup_entry(map, entry-&gt;vme_start, &amp;entry)) &#123;\n                panic(&quot;Found an existing entry (%p) instead of potential hole at address: 0x%llx.\\n&quot;, entry, (unsigned long long)entry-&gt;vme_start);\n            &#125;\n        &#125;\n\n        *address &#x3D; start;\n    &#125; </code></pre>\n\n<ul>\n<li>注意点1：基本上就是检查页的权限等，iOS上不允许可写和可执行并存。</li>\n<li>剩下的就是作各种前置检查。</li>\n</ul>\n<p>如果上述代码不够清晰明了，如下这段代码可以更加的简洁：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">entry &#x3D; map-&gt;first_free;\n\nif (entry &#x3D;&#x3D; vm_map_to_entry(map)) &#123;\n    entry &#x3D; NULL;\n&#125; else &#123;\n       if (entry-&gt;vme_next &#x3D;&#x3D; vm_map_to_entry(map))&#123;\n            entry &#x3D; NULL;\n       &#125; else &#123;\n            if (start &lt; (entry-&gt;vme_next)-&gt;vme_start ) &#123;\n                start &#x3D; entry-&gt;vme_end;\n                start &#x3D; vm_map_round_page(start,\n                              VM_MAP_PAGE_MASK(map));\n            &#125; else &#123;\n                entry &#x3D; NULL;\n            &#125;\n       &#125;\n&#125;\n\nif (entry &#x3D;&#x3D; NULL) &#123;\n    vm_map_entry_t    tmp_entry;\n    if (vm_map_lookup_entry(map, start, &amp;tmp_entry)) &#123;\n        assert(!entry_for_jit);\n        start &#x3D; tmp_entry-&gt;vme_end;\n        start &#x3D; vm_map_round_page(start,\n                      VM_MAP_PAGE_MASK(map));\n    &#125;\n    entry &#x3D; tmp_entry;\n&#125;</code></pre>\n\n<ul>\n<li>整个这段代码的意思是，就是要我们要找个一个比我们这个 <code>start</code> 地址大的 <code>vm_entry_t</code> 。最终的目的是为了在两个已经存在 <code>vm_entry_t</code> 之间尝试插入一个能包含从 <code>start</code> 到 <code>start + size</code> 的新的 <code>vm_entry_t</code>。</li>\n<li>如果没找到的话，就尝试利用 <code>vm_map_lookup_entry</code> 找一个 <code>preceding</code> 我们地址的的 <code>vm_entry_t</code> 。</li>\n</ul>\n<p>当找到了一个满足 <code>start</code> 地址条件的 <code>vm_entry_t</code> 后，剩下就是要满足分配大小 size 的需求了。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">while (TRUE) &#123;\n    register vm_map_entry_t    next;\n\n    end &#x3D; ((start + mask) &amp; ~mask);\n    end &#x3D; vm_map_round_page(end,\n                VM_MAP_PAGE_MASK(map));\n    if (end &lt; start)\n        RETURN(KERN_NO_SPACE);\n\n    start &#x3D; end;\n    end +&#x3D; size;\n\n    if ((end &gt; effective_max_offset) || (end &lt; start)) &#123;\n        RETURN(KERN_NO_SPACE);\n    &#125;\n\n    next &#x3D; entry-&gt;vme_next;\n\n    &#x2F;&#x2F; 如果是空的头\n    if (next &#x3D;&#x3D; vm_map_to_entry(map))\n        break;\n\n    &#x2F;&#x2F; 如果下一个的start \n    if (next-&gt;vme_start &gt;&#x3D; end)\n        break;\n\n    entry &#x3D; next;\n    start &#x3D; entry-&gt;vme_end;\n    start &#x3D; vm_map_round_page(start,\n                  VM_MAP_PAGE_MASK(map));\n&#125;\n*address &#x3D; start;\nassert(VM_MAP_PAGE_ALIGNED(*address,\n               VM_MAP_PAGE_MASK(map)));</code></pre>\n\n<ul>\n<li>判断 <code>start + size</code> 是不是可以正好插入在 <code>vm_entry_t</code> 代表的地址范围的空隙内，如果一直遍历到最后的任务地址上限都找不到，那就说明不存在我们需求的连续的虚拟内存空间用于作分配了。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>除了本文说明的虚拟内存分配的连续性限制以外，虚拟内存作为堆内存分配的一种，在布局范围上也有限制。更多详细的信息可参考如下链接。</p>\n<ul>\n<li><a href=\"https://github.com/opensource-apple/xnu\">XNU</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MemoryManagement.html\">Memory management</a></li>\n<li><a href=\"https://www.jianshu.com/p/4f49c5c81021\">iOS内存管理</a></li>\n<li><a href=\"https://blog.devtang.com/2016/07/30/ios-memory-management/\">理解 iOS 的内存管理</a></li>\n</ul>\n","text":"虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">虚拟内存概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E9%99%90%E5%88%B6\"><span class=\"toc-text\">虚拟内存的限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">进程（任务）的创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E9%99%90%E5%88%B6\"><span class=\"toc-text\">虚拟内存分配的限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"iOS中Log同步获取与重定向","uid":"ea3e901619c09b0b5da7b4018126c113","slug":"2019-01-22-iOS_NSLog","date":"2023-05-24T09:24:36.371Z","updated":"2023-05-24T09:24:36.371Z","comments":true,"path":"api/articles/2019-01-22-iOS_NSLog.json","keywords":null,"cover":null,"text":"在iOS开发的过程中，经常会使用NSLog作为调试和查看相关数据的输出口，该方法连接Xcode构建项目时能够实时输出开发者在代码线中打印的日志。但是在断开Xcode并使用真机测试的时候，经常会无法查看真机的实时日志，导致一些问题难以追查和确定，导致问题的定位与解决花费较长的时间，...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"从Keras开始构建iOS平台手写数字实时识别","uid":"4e4a7be388e7ca1f326d22f43bf851ec","slug":"2019-01-22-keras_mnist_for_iOS","date":"2023-05-24T09:24:36.371Z","updated":"2023-05-24T09:24:36.371Z","comments":true,"path":"api/articles/2019-01-22-keras_mnist_for_iOS.json","keywords":null,"cover":"/images/keras-mnist-for-ios/cover.jpg","text":"本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。 10步之内完成模型的构建、训练和发布使用TLDR； 本文中暂时不会介绍卷积神经网络的细节内容，例如如...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":10,"path":"api/categories/机器学习.json"}],"tags":[{"name":"机器学习 Keras MNIST","slug":"机器学习-Keras-MNIST","count":1,"path":"api/tags/机器学习-Keras-MNIST.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}