{"title":"\\#7\\ Stack & Stack Simple Challenges","uid":"d2a03c6015acad9ab2a35a4a08b03676","slug":"2019-12-08-Data-Structures-&-Algorithms-in-Swift-07","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2019-12-08-Data-Structures-&-Algorithms-in-Swift-07.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/7/cover.jpeg","content":"<p><strong>栈（Stack）</strong>是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属于一种受限的线性表结构。栈的操作特性通常被称为**后进先出(LIFO-last in first out)<strong>的方式，另一种数据结构队列的操作特性与栈有着不同，通常称为</strong>先进先出(FIFO-first in first out)**。</p>\n<h2 id=\"栈的一般操作\"><a href=\"#栈的一般操作\" class=\"headerlink\" title=\"栈的一般操作\"></a>栈的一般操作</h2><p>栈是一种很有用，但是相对简单的数据结构。构建栈类型数据结构的主要目标是数据的访问权限和方式问题。相比于链表而言，栈并没有链表那个复杂和琐碎。</p>\n<p>对于栈来说，主要的操作有两个，即上述所说的<strong>压栈</strong>和<strong>出栈</strong>的操作：</p>\n<ul>\n<li><strong>push：</strong>添加一个元素到栈顶；</li>\n<li><strong>pop：</strong>从栈顶删除一个元素</li>\n</ul>\n<p>也就是说，对于栈而言，只能从栈的一边添加或者移除元素，也就是上述所说的**后进先出(LIFO-last in first out)**的方式。在计算机编程中，栈的身影无处不在，例如下面几个场景中，都是栈的理念和其应用的结果：</p>\n<ul>\n<li>在iOS中,导航控制器的作用是将视图控制器的视图弹出或者弹入，并且最新弹出的总是最后弹入的视图控制器视图；</li>\n<li>内存分配在体系结构级别使用堆栈。局部变量的内存也使用堆栈进行管理；</li>\n<li>Search和conquer算法，例如从迷宫中寻找路径，均使用堆栈来方便回溯。</li>\n</ul>\n<h2 id=\"栈数据结构实现\"><a href=\"#栈数据结构实现\" class=\"headerlink\" title=\"栈数据结构实现\"></a>栈数据结构实现</h2><p>首先定义栈的基础结构，对于栈而言，其核心就是一个列表，只是再具体的操作时有LIFO的限制。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public struct Stack&lt;Element&gt; &#123;\n    private var storage: [Element] &#x3D; []\n    \n    public init() &#123;&#125;\n&#125;\n\nextension Stack: CustomStringConvertible &#123;\n    public var description: String &#123;\n        let topDivider &#x3D; &quot;---- top ----\\n&quot;\n        let bottomDivider &#x3D; &quot;\\n -----------&quot;\n        \n        let stackElements &#x3D; storage\n            .map &#123; &quot;\\($0)&quot; &#125;\n            .reversed()\n            .joined(separator: &quot;\\n&quot;)\n        return topDivider + stackElements + bottomDivider\n    &#125;\n&#125;</code></pre>\n\n<p>另外，在栈的数据结构中使用列表的方式进行数据存储，是因为对于列表来说，在其一端进行操作 — <strong>append</strong> 和<strong>popLast</strong>，都属于恒定时间的复杂度O(1)。也更是促进了栈的进栈和出栈特性的性能表现。</p>\n<h2 id=\"push-amp-pop-操作\"><a href=\"#push-amp-pop-操作\" class=\"headerlink\" title=\"push &amp; pop 操作\"></a>push &amp; pop 操作</h2><p>在栈的数据结构定义中，增加基本的压栈和出栈操作，压栈操作直接使用列表的<strong>append</strong>，出栈使用<strong>popLast</strong>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; push\npublic mutating func push(_ element: Element) &#123;\n    storage.append(element)\n&#125;\n    \n&#x2F;&#x2F; pop\n@discardableResult\npublic mutating func pop() -&gt; Element? &#123;\n    return storage.popLast()\n&#125;</code></pre>\n\n<p>对于这两个基本操作来说，实现也非常直截了当。接下来对其进行实际测试，在主Playground中，进行测试代码编写。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在进行测试前，可以将<a href=\"https://robinchao.github.io/2019/12/03/Data-Structures-&-Algorithms-in-Swift-04.html\">\\#4\\ Linked List 的Swift实现\n</a>中的<strong>Helper.swift</strong>拷贝到当前工程中。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;using a stack&quot;) &#123;\n    var stack &#x3D; Stack&lt;Int&gt;()\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n    stack.push(4)\n    \n    print(stack)\n    \n    if let poppedElement &#x3D; stack.pop() &#123;\n        assert(4 &#x3D;&#x3D; poppedElement)\n        print(&quot;Popped: \\(poppedElement)&quot;)\n    &#125;\n&#125;\n\n&#x2F;* \n---Example of using a stack---\n---- top ----\n4\n3\n2\n1\n -----------\nPopped: 4\n*&#x2F;</code></pre>\n\n<h2 id=\"扩展性操作\"><a href=\"#扩展性操作\" class=\"headerlink\" title=\"扩展性操作\"></a>扩展性操作</h2><p>对于栈来说，除了常用的push和pop操作之外，还有一些额外的操作，能够提高对栈的使用等。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; peek\npublic func peek() -&gt; Element? &#123;\n    return storage.last\n&#125;\n    \n&#x2F;&#x2F; isEmpty\npublic var isEmpty: Bool &#123;\n    return peek() &#x3D;&#x3D; nil\n&#125;</code></pre>\n\n<ul>\n<li><strong>peek()：</strong>获取栈顶元素</li>\n<li><strong>isEmpty：</strong>判断栈是否为空</li>\n</ul>\n<h2 id=\"Less-is-more\"><a href=\"#Less-is-more\" class=\"headerlink\" title=\"Less is more\"></a>Less is more</h2><p>在链表的实现中，我们使用了Swift标准库中的Collection协议，那么在栈的实现中是否也能够使用Collection协议呢？栈的目的是有限制的访问数据，通过迭代或者下标的方式即可实现该目标，但是对于Collection协议来说，并不止于此，因此在栈上使用Collection协议和栈的最初目标是相互制约的。在这种情况下，少即是多！</p>\n<p>您可能希望采用现有数组并将其转换为栈，以便保证访问顺序，也可以循环遍历数组元素以及添加元素。对于栈来说，为了能够对栈的操作有一个统一的初始化存储方式，可以定义其初始化方式：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public init(_ elements: [Element]) &#123;\n    storage &#x3D; elements\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;initializing a stack from a array&quot;) &#123;\n    let array &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]\n    var stack &#x3D; Stack(array)\n    print(stack)\n    \n    if let poppedElement &#x3D; stack.pop() &#123;\n        print(&quot;Popped: \\(poppedElement)&quot;)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of initializing a stack from a array---\n---- top ----\nD\nC\nB\nA\n -----------\nPopped: D\n*&#x2F;</code></pre>\n\n<p>上述实现中，将一个数组转化为了栈，并且栈中元素的数据类型是String，也就意味着栈中可以放置多种类型的数据元素。</p>\n<p>既然可以使用数组直接转化为栈，那么是否可以直接使用数组的方式初始化栈呢？</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Stack: ExpressibleByArrayLiteral &#123;\n    public init(arrayLiteral elements: Element...) &#123;\n        storage &#x3D; elements\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;initializing a stack from an array literal&quot;) &#123;\n    var stack: Stack &#x3D; [1.0, 2.0, 3.0, 4.0]\n    print(stack)\n    if let poppedElement &#x3D; stack.pop() &#123;\n        print(&quot;Popped: \\(poppedElement)&quot;)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of initializing a stack from an array literal---\n---- top ----\n4.0\n3.0\n2.0\n1.0\n -----------\nPopped: 4.0\n*&#x2F;</code></pre>\n\n<p>在搜索树和图的问题求解中，栈至关重要。例如在查找迷宫的路径方法中，每次叨叨左、右、前或后的决策点时，都可以将所有可能的决策点压入栈中，当栈顶的路径是一个死胡同时，只需要从栈中弹出并继续下一个判断，直到走出迷宫即可。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>栈的数据结构虽然非常简单，但栈是解决很多问题的关键性数据结构；</li>\n<li>对于栈爱说，只有两个基本操作，分别是压栈<strong>push</strong>和出栈<strong>pop</strong>。</li>\n</ul>\n<h2 id=\"栈的挑战\"><a href=\"#栈的挑战\" class=\"headerlink\" title=\"栈的挑战\"></a>栈的挑战</h2><h2 id=\"Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。\"><a href=\"#Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。\" class=\"headerlink\" title=\"Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。\"></a>Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在<a href=\"https://robinchao.github.io/2019/12/05/Data-Structures-&-Algorithms-in-Swift-06.html\">\\#6\\ Linked List 挑战</a>中我们使用了递归的方式，反向打印了一个链表的节点。在这里将使用栈的结构进行，避免递归调用。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func printInReverseNoRecursion&lt;T&gt;(_ list: LinkedList&lt;T&gt;) &#123;\n    var current &#x3D; list.head\n    var stack &#x3D; Stack&lt;T&gt;()\n    \n    while let node &#x3D; current &#123;\n        stack.push(node.value)\n        current &#x3D; node.next\n    &#125;\n    \n    while let value &#x3D; stack.pop() &#123;\n        print(value)\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;Print Linkedlist reverse without recursion&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Original list: \\(list)&quot;)\n    print(&quot;Printing in reverse: &quot;)\n    printInReverseNoRecursion(list)\n&#125;\n\n&#x2F;*\n---Example of Print Linkedlist reverse without recursion---\nOriginal list: 1 -&gt;2 -&gt;3  \nPrinting in reverse: \n3\n2\n1\n*&#x2F;</code></pre>\n\n\n<h2 id=\"Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如：\"><a href=\"#Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如：\" class=\"headerlink\" title=\"Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 （ 和 ） 字符，如果字符串中的括号是平衡的，则返回 true。例如：\"></a>Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 <code>（</code> 和 <code>）</code> 字符，如果字符串中的括号是平衡的，则返回 <code>true</code>。例如：</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; 1 h((e))llo(world)() &#x2F;&#x2F; balanced parentheses\n\n&#x2F;&#x2F; 2 (hello world &#x2F;&#x2F; unbalanced parentheses</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func checkParentheses(_ string: String) -&gt; Bool &#123;\n    var stack &#x3D; Stack&lt;Character&gt;()\n    \n    for character in string &#123;\n        if character &#x3D;&#x3D; &quot;(&quot; &#123;\n            stack.push(character)\n        &#125; else if character &#x3D;&#x3D; &quot;)&quot; &#123;\n            if stack.isEmpty &#123;\n                return false\n            &#125;else &#123;\n                stack.pop()\n            &#125;\n        &#125;\n    &#125;\n    return stack.isEmpty\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;check parentheses&quot;) &#123;\n    let string &#x3D; &quot;h((e))llo(world)())&quot;\n    \n    let result &#x3D; checkParentheses(string)\n    \n    print(&quot;\\(result)&quot;)\n&#125;\n\n&#x2F;*\n---Example of check parentheses---\nfalse\n*&#x2F;</code></pre>","text":"栈（Stack）是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E7%9A%84%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">栈的一般操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">栈数据结构实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#push-amp-pop-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">push &amp; pop 操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E6%80%A7%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">扩展性操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Less-is-more\"><span class=\"toc-text\">Less is more</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E7%9A%84%E6%8C%91%E6%88%98\"><span class=\"toc-text\">栈的挑战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-1%EF%BC%9A%E5%9C%A8%E4%B8%8D%E9%80%82%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%8F%8D%E5%90%91%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%82\"><span class=\"toc-text\">Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-2%EF%BC%9A%E6%A3%80%E6%9F%A5%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1%E3%80%82%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89-%EF%BC%88-%E5%92%8C-%EF%BC%89-%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%B9%B3%E8%A1%A1%E7%9A%84%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E-true%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A\"><span class=\"toc-text\">Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 （ 和 ） 字符，如果字符串中的括号是平衡的，则返回 true。例如：</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#6\\ Linked List 挑战","uid":"87b78748d49eafbc45cf485f76a0100a","slug":"2019-12-05-Data-Structures-&-Algorithms-in-Swift-06","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2019-12-05-Data-Structures-&-Algorithms-in-Swift-06.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/6/cover.jpg","text":"本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。 Challenge 1：创建按照反向顺序打印链表元素的函数。&#x2F;&#x2F; LinkedList 1 -&gt; 2 -&...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#8\\ 队列的Swift实现与操作定义","uid":"69dccdbf9286082e902aaae1dff82001","slug":"2019-12-10-Data-Structures-&-Algorithms-in-Swift-08","date":"2023-05-13T14:48:40.640Z","updated":"2023-05-13T14:48:40.640Z","comments":true,"path":"api/articles/2019-12-10-Data-Structures-&-Algorithms-in-Swift-08.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/8/cover.jpg","text":"在生活中，人人都熟悉排队等待。无论你是在排队购买喜欢的电影的电影票，还是排队等待打印一份文件等等，这些都是队列（Queue）数据结构。在上文\\#7\\ Stack &amp; Stack Simple Challenges中已经提到过队列和栈属于基本的数据结构类型，但是其在应用层面...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}