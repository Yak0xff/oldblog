{"title":"\\#19\\ 基数排序（Radix Sort）","uid":"1eff6ae9330e74043f153497674d46df","slug":"2020-02-01-Data-Structures-&-Algorithms-in-Swift-19","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-02-01-Data-Structures-&-Algorithms-in-Swift-19.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/19/cover.jpg","content":"<p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p>\n<p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var array &#x3D; [88, 410, 1772, 20]</code></pre>\n\n<p>基数排序依赖于整数的位置表示法，如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png\"></p>\n<p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png\"></p>\n<p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">array &#x3D; [410, 20, 1772, 88]</code></pre>\n\n<p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png\"></p>\n<p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p>\n<p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png\"></p>\n<p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">array &#x3D; [20, 88, 410, 1772]</code></pre>\n\n<p>最后，在堆集合中的元素进行千位拆解：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png\"></p>\n<p>重新按照千位拆解结果进行排序，结果如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">array &#x3D; [20, 88, 410, 1772]</code></pre>\n\n<p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension Array where Element &#x3D;&#x3D; Int &#123;\n    public mutating func radixSort() &#123;\n        let base &#x3D; 10\n        var done &#x3D; false\n        var digits &#x3D; 1\n        while !done &#123;\n            &#x2F;&#x2F; more to come\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p>\n<ol>\n<li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li>\n<li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li>\n</ol>\n<p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p>\n<h3 id=\"Bucket-Sort\"><a href=\"#Bucket-Sort\" class=\"headerlink\" title=\"Bucket Sort\"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var buckets: [[Int]] &#x3D; .init(repeating: [], count: base)\n            \nforEach &#123;\n    number in\n    let remainingPart &#x3D; number &#x2F; digits\n    let digit &#x3D; remainingPart % base\n    buckets[digit].append(number)\n&#125;\n\ndigits *&#x3D; base\nself &#x3D; buckets.flatMap &#123; $0 &#125;</code></pre>\n\n<ol>\n<li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li>\n<li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li>\n<li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li>\n</ol>\n<p><strong>循环何时结束？</strong></p>\n<p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p>\n<ol>\n<li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li>\n<li>在forEach闭包结构中，增加如下语句：</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">if remainingPart &gt; 0 &#123;\n    done &#x3D; false\n&#125;</code></pre>\n\n<p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;radix sort&quot;) &#123;\n    var array &#x3D; [88, 410, 1772, 20]\n    print(&quot;Original: \\(array)&quot;)\n    array.radixSort()\n    print(&quot;Radix sorted: \\(array)&quot;)\n&#125;\n\n&#x2F;*\n---Example of radix sort---\nOriginal: [88, 410, 1772, 20]\nRadix sorted: [20, 88, 410, 1772]\n*&#x2F;</code></pre>\n\n<p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p>\n<p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p>\n</li>\n<li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p>\n</li>\n<li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p>\n</li>\n</ul>\n","text":"**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。 为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。 示例为了进行基数排序的工作方式，假设需要对如下的集合进行排序： var array &#...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bucket-Sort\"><span class=\"toc-text\">Bucket Sort</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#18\\ 归并排序（Merge Sort）","uid":"05deaa37bb6b9b668ab83d05b4918b64","slug":"2020-01-30-Data-Structures-&-Algorithms-in-Swift-18","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-01-30-Data-Structures-&-Algorithms-in-Swift-18.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/18/cover.jpg","text":"归并排序[Merge Sort]是最有效的排序算法之一，它的时间复杂度为O(n log n)，是所有通用排序算法中速度最快的一种。归并排序背后的思想是分而治之，即将一个大问题分解成多个更小、更易于解决的问题，然后将各个小问题的结果合并为最终结果。归并排序的终极秘诀是先拆分后合并。...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#20\\ 堆排序（Heap Sort）","uid":"b14270b802509aef1b418b7534f574dc","slug":"2020-02-03-Data-Structures-&-Algorithms-in-Swift-20","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-02-03-Data-Structures-&-Algorithms-in-Swift-20.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/20/cover.jpg","text":"**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看\\#15\\ 堆数据结构（The Heap Data Structure）中的介绍。 堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质： 在最...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}