{"title":"Runtime剖析03 --- “黑魔法” Method Swizzling","uid":"c17c44d6d8996ee062f87af24348061f","slug":"2020-06-30-iOS-runtime-method-swizzling","date":"2023-05-13T14:28:22.152Z","updated":"2023-05-13T14:28:22.152Z","comments":true,"path":"api/articles/2020-06-30-iOS-runtime-method-swizzling.json","keywords":null,"cover":null,"content":"<p>方法替换，又称为<strong>Method Swizzling</strong>，是Objective-C语言中比较流行的“黑魔法”。动态替换方法实现，大多数情况下使用在一些检测类的业务逻辑中，同时，方法替换也带给开发者更多可能的新的开发方式。在简单剖析**Method Swizzling **前，先看看方法替换场景中两种经常遇到的情况。</p>\n<ol>\n<li>需要替换的方法在目标类中有实现；</li>\n<li>需要替换的方法在目标类中没有实现，但再其父类中有实现。</li>\n</ol>\n<p>对于第一种情况，直接可以使用runtime提供的<strong>method_exchangeImplementations</strong>即可。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 方法定义\nOBJC_EXPORT void\nmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) \n    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);\n\n&#x2F;&#x2F; 方法实现\nvoid method_exchangeImplementations(Method m1, Method m2)\n&#123;\n    if (!m1  ||  !m2) return;\n    &#x2F;&#x2F; 加锁\n    mutex_locker_t lock(runtimeLock);\n    &#x2F;&#x2F; 方法交换\n    IMP m1_imp &#x3D; m1-&gt;imp;\n    m1-&gt;imp &#x3D; m2-&gt;imp;\n    m2-&gt;imp &#x3D; m1_imp;\n\n    &#x2F;&#x2F; 缓存清理\n    flushCaches(nil);\n    &#x2F;&#x2F; 设定标识\n    adjustCustomFlagsForMethodChange(nil, m1);\n    adjustCustomFlagsForMethodChange(nil, m2);\n&#125;</code></pre>\n\n<p>对于第二种情况，稍微复杂一点。由于在目标类中并没有待替换方法的实现，而再其父类中有实现，那么其实要交换的是目标类父类中的实现，但是这样一替换后，其他调用父类这个方法的地方，也会被转发到所替换的方法中，这样明显是不合理的。</p>\n<p>为了避免这种情况，在进行方法替换前，首先要检查目标类中是否有对应方法的实现，如果没有，则要将方法动态添加进当前类的方法列表中。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">+ (void)load &#123;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        &#x2F;&#x2F; When swizzling a Instance method, use the following:\n        Class class &#x3D; [self class];\n        \n        &#x2F;&#x2F; When swizzling a class method, use the following:\n        &#x2F;&#x2F; Class class &#x3D; object_getClass((id)self);\n        \n        SEL originalSelector &#x3D; @selector(systemMethod_PrintLog);\n        SEL swizzledSelector &#x3D; @selector(swizzledMethod_PrintLog);\n        \n        Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector);\n        \n        BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        \n        if (didAddMethod) &#123;\n            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));\n        &#125;else&#123;\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        &#125;\n    &#125;);\n&#125;</code></pre>\n\n<ul>\n<li>直接使用<strong>class_addMethod()<strong>检查目标class中是否有方法实现，如果目标类中没有对应方法的实现，</strong>didAddMethod</strong>会返回<strong>true</strong>，同时会将<strong>originalSelector</strong>添加到目标类中，如果目标类中已经有了方法的实现，<strong>didAddMethod</strong>会返回<strong>false</strong>，那么直接调用**method_exchangeImplementations()**交换即可；</li>\n<li>在进行<strong>class_addMethod()<strong>的时候，</strong>SEL</strong>传入的是待替换的<strong>originalSelector</strong>，但是<strong>IMP</strong>传入的是<strong>swizzledMethod</strong>的实现，在完成**class_addMethod()**后，即完成了方法实现的替换，即使用了替换方法的实现，替换了原始方法的实现。</li>\n<li>当<strong>class_addMethod()<strong>完成后，然后调用</strong>class_replaceMethod()<strong>对</strong>swizzledSelector</strong>的实现进行替换。在<strong>class_replaceMethod()<strong>的内部实现中，首先会尝试调用</strong>class_addMethod()<strong>，将方法添加到类中，如果添加失败，则说明class中已经有了该方法，此时会调用</strong>method_setImplementation</strong>设置方法的<strong>IMP</strong>。</li>\n</ul>\n<p>另外，<strong>class</strong>的获取，如果替换的是实例方法，则直接使用**Class class &#x3D; [self class];<strong>获取实例对象，如果替换的是类方法，则需要使用</strong>Class class &#x3D; object_getClass((id)self);**获取类对象。</p>\n<p>方法替换的时机一般情况下在**+ (void)load **方法中进行，因为该方法在runtime将class加载进内存时，其加载时机比较靠前，能够保证方法替换成功后，调用的逻辑符合预期。</p>\n<h2 id=\"Method-swizzling-如何工作的\"><a href=\"#Method-swizzling-如何工作的\" class=\"headerlink\" title=\"Method swizzling 如何工作的\"></a>Method swizzling 如何工作的</h2><p><strong>号称Objective-C中的黑魔法 — Method swizzling，其本质是基于runtime底层数据结构体的应用。</strong>  因此了解runtime底层数据结构有助于理解该黑魔法的工作原理等。</p>\n<h3 id=\"class-amp-object-getClass\"><a href=\"#class-amp-object-getClass\" class=\"headerlink\" title=\"class &amp; object_getClass\"></a>class &amp; object_getClass</h3><p>首先从上文中的<strong>class</strong>对象的获取说起：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">&#x2F;&#x2F; When swizzling a Instance method, use the following:\nClass class &#x3D; [self class];\n        \n&#x2F;&#x2F; When swizzling a class method, use the following:\nClass class &#x3D; object_getClass((id)self);</code></pre>\n\n<p><strong>class</strong></p>\n<p>在<strong>NSObject</strong>的定义中，<strong>class</strong>的定义有两个，一个是实例方法，一个是类方法。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">+ (Class)class &#123;\n    return self;\n&#125;\n\n- (Class)class &#123;\n    return object_getClass(self);\n&#125;</code></pre>\n\n<p>当调用者是类对象时，返回的是类对象本身，而调用者是实例对象时，会调用runtime的<strong>object_getClass</strong>方法，该方法中具体做了什么呢？</p>\n<p><strong>object_getClass</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Class object_getClass(id obj)\n&#123;\n    if (obj) return obj-&gt;getIsa();\n    else return Nil;\n&#125;</code></pre>\n\n<p><strong>object_getClass</strong>的内部实现非常简单，就是获取对象的<strong>isa</strong>指针。如果对象时<strong>实例对象</strong>，<strong>isa</strong>返回的是实例对象所对应的类对象；如果是<strong>类对象</strong>，<strong>isa</strong>返回的是类对象对应的<strong>元类对象</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>方法替换中，如果替换的是实例方法，则需要修改实例对象所对应的类对象的方法列表，如果是类方法，则需要修改类对象所对应的元类对象的方法列表。</strong></p></blockquote>\n<h2 id=\"class-getInstanceMethod\"><a href=\"#class-getInstanceMethod\" class=\"headerlink\" title=\"class_getInstanceMethod\"></a>class_getInstanceMethod</h2><p>在确认了目标类之后，接下来就是要准备方法替换的原始方法和替换方法：<strong>originalMethod</strong>、<strong>swizzledMethod</strong>。<strong>Method</strong>数据类型的定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct method_t *Method;\n\nstruct method_t &#123;\n    SEL name;  &#x2F;&#x2F; 方法名\n    const char *types; &#x2F;&#x2F; 方法返回值类型和参数类型，TypeEncoding\n    MethodListIMP imp; &#x2F;&#x2F; 方法实现\n\n    struct SortBySELAddress :\n        public std::binary_function&lt;const method_t&amp;,\n                                    const method_t&amp;, bool&gt;\n    &#123;\n        bool operator() (const method_t&amp; lhs,\n                         const method_t&amp; rhs)\n        &#123; return lhs.name &lt; rhs.name; &#125;\n    &#125;;\n&#125;;</code></pre>\n\n<p>在方法列表中，存储的既是<strong>method_t</strong>结构体类型。通过<strong>class_getInstanceMethod</strong>取出方法，既是通过<strong>SEL</strong>在指定类对象的方法列表中查找对应的<strong>Method</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Method class_getInstanceMethod(Class cls, SEL sel)\n&#123;\n    if (!cls  ||  !sel) return nil;\n\n    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.\n\n    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that \n    &#x2F;&#x2F; wants a Method instead of an IMP.\n        \n    &#x2F;&#x2F; Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);\n    return _class_getMethod(cls, sel);\n&#125;</code></pre>\n\n<p><strong>class_getInstanceMethod</strong>中调用了<strong>lookUpImpOrForward</strong>进行<strong>imp</strong>的搜索以及方法缓存构建，之后会调用**_class_getMethod<strong>方法，根据目标</strong>cls<strong>和</strong>sel<strong>查找对应的</strong>Method**。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static Method _class_getMethod(Class cls, SEL sel)\n&#123;\n    mutex_locker_t lock(runtimeLock);\n    return getMethod_nolock(cls, sel);\n&#125;\n\nstatic method_t *\ngetMethod_nolock(Class cls, SEL sel)\n&#123;\n    method_t *m &#x3D; nil;\n\n    runtimeLock.assertLocked();\n\n    &#x2F;&#x2F; fixme nil cls?\n    &#x2F;&#x2F; fixme nil sel?\n\n    ASSERT(cls-&gt;isRealized());\n\n    while (cls  &amp;&amp;  ((m &#x3D; getMethodNoSuper_nolock(cls, sel))) &#x3D;&#x3D; nil) &#123;\n        cls &#x3D; cls-&gt;superclass;\n    &#125;\n\n    return m;\n&#125;\n\nstatic method_t *\ngetMethodNoSuper_nolock(Class cls, SEL sel)\n&#123;\n    runtimeLock.assertLocked();\n\n    ASSERT(cls-&gt;isRealized());\n    &#x2F;&#x2F; fixme nil cls? \n    &#x2F;&#x2F; fixme nil sel?\n\n    auto const methods &#x3D; cls-&gt;data()-&gt;methods();\n    for (auto mlists &#x3D; methods.beginLists(),\n              end &#x3D; methods.endLists();\n         mlists !&#x3D; end;\n         ++mlists)\n    &#123;\n        &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;46904873&gt; getMethodNoSuper_nolock is the hottest\n        &#x2F;&#x2F; caller of search_method_list, inlining it turns\n        &#x2F;&#x2F; getMethodNoSuper_nolock into a frame-less function and eliminates\n        &#x2F;&#x2F; any store from this codepath.\n        method_t *m &#x3D; search_method_list_inline(*mlists, sel);\n        if (m) return m;\n    &#125;\n\n    return nil;\n&#125;</code></pre>\n\n<p><strong>_class_getMethod</strong>方法直接调用<strong>getMethod_nolock</strong>方法，在该方法中验证类的继承链，向上查找SEL对应对应的method，其搜索条件是通过cls和sel在cls的方法列表中，查找对应的method。</p>\n<h2 id=\"class-addMethod\"><a href=\"#class-addMethod\" class=\"headerlink\" title=\"class_addMethod\"></a>class_addMethod</h2><p>在获取到目标类和方法之后，首先尝试的是调用<strong>class_addMethod</strong>将<strong>swizzledMethod</strong>添加到目标类的方法列表中。</p>\n<p>目的在于，如果目标类中没有要替换的<strong>originalMethod</strong>，则直接将<strong>swizzledMethod</strong>作为<strong>originalMethod</strong>的实现添加到目标类中，如果目标类中存在<strong>originalMethod</strong>的实现，则<strong>class_addMethod</strong>方法会添加失败，返回<strong>false</strong>，此时调用<strong>method_exchangeImplementations</strong>直接替换<strong>originalMethod</strong>的实现为<strong>swizzledMethod</strong>的实现即可。</p>\n<p><strong>class_addMethod</strong>方法的实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BOOL \nclass_addMethod(Class cls, SEL name, IMP imp, const char *types)\n&#123;\n    if (!cls) return NO;\n\n    mutex_locker_t lock(runtimeLock);\n    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);\n&#125;\n\nstatic IMP \naddMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)\n&#123;\n    IMP result &#x3D; nil;\n\n    runtimeLock.assertLocked();\n\n    checkIsKnownClass(cls);\n    \n    ASSERT(types);\n    ASSERT(cls-&gt;isRealized());\n\n    method_t *m;\n    if ((m &#x3D; getMethodNoSuper_nolock(cls, name))) &#123;\n        &#x2F;&#x2F; already exists\n        if (!replace) &#123;\n            result &#x3D; m-&gt;imp;\n        &#125; else &#123;\n            result &#x3D; _method_setImplementation(cls, m, imp);\n        &#125;\n    &#125; else &#123;\n        auto rwe &#x3D; cls-&gt;data()-&gt;extAllocIfNeeded();\n\n        &#x2F;&#x2F; fixme optimize\n        method_list_t *newlist;\n        newlist &#x3D; (method_list_t *)calloc(sizeof(*newlist), 1);\n        newlist-&gt;entsizeAndFlags &#x3D; \n            (uint32_t)sizeof(method_t) | fixed_up_method_list;\n        newlist-&gt;count &#x3D; 1;\n        newlist-&gt;first.name &#x3D; name;\n        newlist-&gt;first.types &#x3D; strdupIfMutable(types);\n        newlist-&gt;first.imp &#x3D; imp;\n\n        prepareMethodLists(cls, &amp;newlist, 1, NO, NO);\n        rwe-&gt;methods.attachLists(&amp;newlist, 1);\n        flushCaches(cls);\n\n        result &#x3D; nil;\n    &#125;\n\n    return result;\n&#125;</code></pre>\n\n<p><strong>class_addMethod</strong>方法中调用<strong>addMethod</strong>方法，并设定参数<strong>replace</strong>为<strong>NO</strong>，即不进行替换，仅仅添加，这也揭示了为什么当存在method的实现时，该方法会返回false。</p>\n<p><strong>addMethod</strong>方法中，首先会检查锁提供的method是否在cls的方法列表中存在，如果存在则直接获取，如果不存在，则会根据现有方法列表的数据重新创建一个方法列表对象<strong>method_list_t</strong>，并将提供的method追加到该方法列表中，最后刷新设定类的方法列表，完成方法的添加。</p>\n<h2 id=\"class-replaceMethod\"><a href=\"#class-replaceMethod\" class=\"headerlink\" title=\"class_replaceMethod\"></a>class_replaceMethod</h2><p>如果上一步<strong>class_addMethod</strong>返回成功，则说明在目标类中添加SEL为<strong>originalMethod</strong>，IMP为<strong>swizzledMethod</strong>的方法，那么接下来就剩下对方法的实现进行替换了，此时调用<strong>class_replaceMethod</strong>。</p>\n<p><strong>class_replaceMethod</strong>方法中还是调用<strong>addMethod</strong>方法，但是参数<strong>replace</strong>设定为<strong>YES</strong>，表示执行替换的逻辑。并且此时，在方法列表中是确定存在对应的方法的，因此会直接调用**_method_setImplementation**方法，设定方法实现。</p>\n<h2 id=\"method-exchangeImplementations\"><a href=\"#method-exchangeImplementations\" class=\"headerlink\" title=\"method_exchangeImplementations\"></a>method_exchangeImplementations</h2><p>如果<strong>class_addMethod</strong>返回失败，说明目标类中的<strong>originalMethod</strong>已经存在，此时直接对其实现进行交换即可，交换方法的实现调用<strong>method_exchangeImplementations</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void method_exchangeImplementations(Method m1, Method m2)\n&#123;\n    if (!m1  ||  !m2) return;\n\n    mutex_locker_t lock(runtimeLock);\n\n    IMP m1_imp &#x3D; m1-&gt;imp;\n    m1-&gt;imp &#x3D; m2-&gt;imp;\n    m2-&gt;imp &#x3D; m1_imp;\n\n\n    &#x2F;&#x2F; RR&#x2F;AWZ updates are slow because class is unknown\n    &#x2F;&#x2F; Cache updates are slow because class is unknown\n    &#x2F;&#x2F; fixme build list of classes whose Methods are known externally?\n\n    flushCaches(nil);\n\n    adjustCustomFlagsForMethodChange(nil, m1);\n    adjustCustomFlagsForMethodChange(nil, m2);\n&#125;</code></pre>\n\n<p><strong>method_exchangeImplementations</strong>方法的核心其实就是交换两个方法的实现imp。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>在使用Method Swizzlings的时候，有几个要注意的地方：</p>\n<p><strong>1. 加载时机</strong></p>\n<p>swizzling应该只在**+load**中完成。 </p>\n<p>在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p>\n<p><strong>2. 单例</strong></p>\n<p>swizzling 应该只在 dispatch_once 中完成, 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次s。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。</p>\n<p><strong>3. _cmd调用</strong></p>\n<p>通常在swizzling交换后的方法中，还需要再调用一次本方法，这样做并不会产生递归调用，因为此时调用的已经是交换后的方法，而再次调用的目的是触发交换的方法实现执行。</p>\n","text":"方法替换，又称为Method Swizzling，是Objective-C语言中比较流行的“黑魔法”。动态替换方法实现，大多数情况下使用在一些检测类的业务逻辑中，同时，方法替换也带给开发者更多可能的新的开发方式。在简单剖析**Method Swizzling **前，先看看方法替...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Method-swizzling-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">Method swizzling 如何工作的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#class-amp-object-getClass\"><span class=\"toc-text\">class &amp; object_getClass</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-getInstanceMethod\"><span class=\"toc-text\">class_getInstanceMethod</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-addMethod\"><span class=\"toc-text\">class_addMethod</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-replaceMethod\"><span class=\"toc-text\">class_replaceMethod</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#method-exchangeImplementations\"><span class=\"toc-text\">method_exchangeImplementations</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"Runtime剖析02 --- 消息与消息发送机制","uid":"3007adc9b3f366505974b3565c38f1eb","slug":"2020-06-24-iOS-runtime-message-forward","date":"2023-05-13T14:28:22.152Z","updated":"2023-05-13T14:28:22.152Z","comments":true,"path":"api/articles/2020-06-24-iOS-runtime-message-forward.json","keywords":null,"cover":[],"text":"在Objective-C中，消息发送指Runtime会根据SEL查找对应的IMP，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。 消息相关数据结构SELSEL称之为消息选择器，相当于一个key，在类的...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"Runtime剖析04 --- 深入理解Category","uid":"c6997d59d32873c326b54f9cbde95646","slug":"2020-07-01-iOS-runtime-category","date":"2023-05-13T14:28:22.152Z","updated":"2023-05-13T14:28:22.152Z","comments":true,"path":"api/articles/2020-07-01-iOS-runtime-category.json","keywords":null,"cover":null,"text":"在Objective-C中，可以通过Category添加属性、方法、协议，在Runtime中Class和Category都是通过结构体实现的。和Category相似的还有Extension，二者的区别在于，Extension在编译期就直接和原类编译在一起，而Category是在运...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}