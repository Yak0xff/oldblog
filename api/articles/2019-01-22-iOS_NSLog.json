{"title":"iOS中Log同步获取与重定向","uid":"ea3e901619c09b0b5da7b4018126c113","slug":"2019-01-22-iOS_NSLog","date":"2023-05-13T14:52:09.990Z","updated":"2023-05-13T14:52:09.990Z","comments":true,"path":"api/articles/2019-01-22-iOS_NSLog.json","keywords":null,"cover":null,"content":"<p>在iOS开发的过程中，经常会使用<code>NSLog</code>作为调试和查看相关数据的输出口，该方法连接Xcode构建项目时能够实时输出开发者在代码线中打印的日志。但是在断开Xcode并使用真机测试的时候，经常会无法查看真机的实时日志，导致一些问题难以追查和确定，导致问题的定位与解决花费较长的时间，一定程度上影响了产品开发的进度和优化。面对诸如此类的问题，我们可以通过Log信息的重定向等技术，让相关的Log信息转存到一个我们能够提取的地方，方便开发人员在出现问题的时候，得到详细的Log信息，快速的识别出问题的原因并修复和优化等。</p>\n<h1 id=\"NSLog的输出到底在哪里？\"><a href=\"#NSLog的输出到底在哪里？\" class=\"headerlink\" title=\"NSLog的输出到底在哪里？\"></a>NSLog的输出到底在哪里？</h1><p>在iOS的系统API中，专门提供了一个上层函数<code>NSLog</code>以供开发者调用并打印相关的信息，<code>NSLog</code>本质上是一个C函数，它的声明如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">FOUNDATION_EXPORT void NSLog(NSString *format, ...)</code></pre>\n\n<p>系统对该函数的说明是：<code>Logs an error message to the Apple System Log facility</code>。简单的说就是用来输出信息到标准的Error控制台上，其内部其实是使用<code>Apple System Log（asl）</code>的API，至少iOS 10以前是这样。在调试阶段，日志会输出到Xcode中，而在真机上，会输出到系统的<code>/var/log/syslog</code>文件中。</p>\n<h1 id=\"Apple-System-Logger\"><a href=\"#Apple-System-Logger\" class=\"headerlink\" title=\"Apple System Logger\"></a>Apple System Logger</h1><p>我们可以通过<a href=\"https://developer.apple.com/documentation/foundation/1395074-nslogv?language=objc\">官方文档</a>了解到，OC中最常见的NSLog操作会同时将标准的Error输出到控制台和系统日志(syslog)中(C语言的printf系列函数并不会，swift的printf为了保证性能也只会在模拟器环境中输出)。其内部是使用Apple System Logger(简称ASL)去实现的，ASL是苹果自己实现的用于输出日志到系统日志库的一套API接口，有点类似于SQL操作。在iOS真机设备上，使用ASL记录的log被缓存在沙盒文件中，直到设备被重启。</p>\n<p>既然日志被写入系统的syslog中，那我们可以直接读取这些日志。从ASL读取日志的核心代码如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">#import &lt;asl.h&gt;\n&#x2F;&#x2F; 从日志的对象aslmsg中获取我们需要的数据\n+(instancetype)logMessageFromASLMessage:(aslmsg)aslMessage&#123;\n    SystemLogMessage *logMessage &#x3D; [[SystemLogMessage alloc] init];\n    const char *timestamp &#x3D; asl_get(aslMessage, ASL_KEY_TIME);\n    if (timestamp) &#123;\n        NSTimeInterval timeInterval &#x3D; [@(timestamp) integerValue];\n        const char *nanoseconds &#x3D; asl_get(aslMessage, ASL_KEY_TIME_NSEC);\n        if (nanoseconds) &#123;\n            timeInterval +&#x3D; [@(nanoseconds) doubleValue] &#x2F; NSEC_PER_SEC;\n        &#125;\n        logMessage.timeInterval &#x3D; timeInterval;\n        logMessage.date &#x3D; [NSDate dateWithTimeIntervalSince1970:timeInterval];\n    &#125;\n    const char *sender &#x3D; asl_get(aslMessage, ASL_KEY_SENDER);\n    if (sender) &#123;\n        logMessage.sender &#x3D; @(sender);\n    &#125;\n    const char *messageText &#x3D; asl_get(aslMessage, ASL_KEY_MSG);\n    if (messageText) &#123;\n        logMessage.messageText &#x3D; @(messageText);&#x2F;&#x2F;NSLog写入的文本内容\n    &#125;\n    const char *messageID &#x3D; asl_get(aslMessage, ASL_KEY_MSG_ID);\n    if (messageID) &#123;\n        logMessage.messageID &#x3D; [@(messageID) longLongValue];\n    &#125;\n    return logMessage;\n&#125;\n\n+ (NSMutableArray&lt;SystemLogMessage *&gt; *)allLogMessagesForCurrentProcess&#123;\n    asl_object_t query &#x3D; asl_new(ASL_TYPE_QUERY);\n    &#x2F;&#x2F; Filter for messages from the current process. \n    &#x2F;&#x2F; Note that this appears to happen by default on device, \n    &#x2F;&#x2F; but is required in the simulator.\n    NSString *pidString &#x3D; [NSString stringWithFormat:@&quot;%d&quot;, [[NSProcessInfo processInfo] processIdentifier]];\n    asl_set_query(query, ASL_KEY_PID, [pidString UTF8String], ASL_QUERY_OP_EQUAL);\n\n    aslresponse response &#x3D; asl_search(NULL, query);\n    aslmsg aslMessage &#x3D; NULL;\n\n    NSMutableArray *logMessages &#x3D; [NSMutableArray array];\n    while ((aslMessage &#x3D; asl_next(response))) &#123;\n        [logMessages addObject:[SystemLogMessage logMessageFromASLMessage:aslMessage]];\n    &#125;\n    asl_release(response);\n\n    return logMessages;\n&#125;</code></pre>\n\n<p>使用以上方法的好处是不会影响Xcode控制台的输出，可以用非侵入性的方式来读取日志。</p>\n<h1 id=\"ASL在iOS10后被弃用\"><a href=\"#ASL在iOS10后被弃用\" class=\"headerlink\" title=\"ASL在iOS10后被弃用\"></a>ASL在iOS10后被弃用</h1><p>但是Apple从iOS 10开始，为了减弱ASL对于日志系统的侵入性，直接废弃掉了ASL<a href=\"https://developer.apple.com/documentation/os/logging?language=objc\">link</a>，导致在iOS 10之后的系统版本中无法使用ASL相关的API。因此为了能够在iOS 10之后的版本中同样获取日志数据，我们寻找一种版本兼容的解决方案。</p>\n<h1 id=\"NSLog重定向\"><a href=\"#NSLog重定向\" class=\"headerlink\" title=\"NSLog重定向\"></a>NSLog重定向</h1><p>NSLog能输出到文件syslog中，靠的是文件IO的API的调用，那么在这些IO操作中，一定存在文件句柄。在C语言中，存在默认的三个文件句柄：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define stdin __stdinp \n#define stdout __stdoutp \n#define stderr __stderrp</code></pre>\n\n<p>其对应的三个iOS版本的文件句柄是(定义在<code>unistd.h</code>文件中):</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define\t STDIN_FILENO\t0\t&#x2F;* standard input file descriptor *&#x2F;\n#define\tSTDOUT_FILENO\t1\t&#x2F;* standard output file descriptor *&#x2F;\n#define\tSTDERR_FILENO\t2\t&#x2F;* standard error file descriptor *&#x2F;</code></pre>\n\n<p>在使用重定向之后，NSLog就不会写到系统的syslog中了。</p>\n<h2 id=\"dup2重定向\"><a href=\"#dup2重定向\" class=\"headerlink\" title=\"dup2重定向\"></a>dup2重定向</h2><p>通过重定向，可以直接截取<code>stdout,stderr</code>等标准输出的信息，然后保存在想要存储的位置，上传到服务器或者显示到View上。<br>要做到重定向，需要通过<code>NSPipe</code>创建一个管道，pipe有读端和写端，然后通过<code>dup2</code>将标准输入重定向到pipe的写端。再通过<code>NSFileHandle</code>监听pipe的读端，最后再处理读出的信息。<br>之后通过<code>printf</code>或者<code>NSLog</code>写数据，都会写到pipe的写端，同时pipe会将这些数据直接传送到读端，最后通过NSFileHandle的监控函数取出这些数据。<br>核心代码如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">- (void)redirectStandardOutput&#123;\n    &#x2F;&#x2F;记录标准输出及错误流原始文件描述符\n    self.outFd &#x3D; dup(STDOUT_FILENO);\n    self.errFd &#x3D; dup(STDERR_FILENO);\n#if BETA_BUILD\n    stdout-&gt;_flags &#x3D; 10;\n    NSPipe *outPipe &#x3D; [NSPipe pipe];\n    NSFileHandle *pipeOutHandle &#x3D; [outPipe fileHandleForReading];\n    dup2([[outPipe fileHandleForWriting] fileDescriptor], STDOUT_FILENO);\n    [pipeOutHandle readInBackgroundAndNotify];\n\n    stderr-&gt;_flags &#x3D; 10;\n    NSPipe *errPipe &#x3D; [NSPipe pipe];\n    NSFileHandle *pipeErrHandle &#x3D; [errPipe fileHandleForReading];\n    dup2([[errPipe fileHandleForWriting] fileDescriptor], STDERR_FILENO);\n    [pipeErrHandle readInBackgroundAndNotify];\n    [[NSNotificationCenter defaultCenter] addObserver:self \n                                            selector:@selector(redirectOutNotificationHandle:) \n                                            name:NSFileHandleReadCompletionNotification \n                                            object:pipeOutHandle];\n\n    [[NSNotificationCenter defaultCenter] addObserver:self \n                                            selector:@selector(redirectErrNotificationHandle:) \n                                            name:NSFileHandleReadCompletionNotification \n                                            object:pipeErrHandle];\n#endif\n&#125;\n\n-(void)recoverStandardOutput&#123;\n#if BETA_BUILD\n    dup2(self.outFd, STDOUT_FILENO);\n    dup2(self.errFd, STDERR_FILENO);\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n#endif\n&#125;\n\n&#x2F;&#x2F; 重定向之后的NSLog输出\n- (void)redirectOutNotificationHandle:(NSNotification *)nf&#123;\n#if BETA_BUILD\n    NSData *data &#x3D; [[nf userInfo] objectForKey:NSFileHandleNotificationDataItem];\n    NSString *str &#x3D; [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    &#x2F;&#x2F; YOUR CODE HERE...  保存日志并上传或展示\n#endif\n    [[nf object] readInBackgroundAndNotify];\n&#125;\n\n&#x2F;&#x2F; 重定向之后的错误输出\n- (void)redirectErrNotificationHandle:(NSNotification *)nf&#123;\n#if BETA_BUILD\n    NSData *data &#x3D; [[nf userInfo] objectForKey:NSFileHandleNotificationDataItem];\n    NSString *str &#x3D; [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    &#x2F;&#x2F; YOUR CODE HERE...  保存日志并上传或展示\n#endif\n    [[nf object] readInBackgroundAndNotify];\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>dup函数可以为我们复制一个文件描述符，传给该函数一个既有的描述符，它就会返回一个新的描述符，这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。<br>而dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。</p></blockquote>\n<h2 id=\"文件重定向\"><a href=\"#文件重定向\" class=\"headerlink\" title=\"文件重定向\"></a>文件重定向</h2><p>另一种重定向的方式是利用c语言的<code>freopen</code>函数进行重定向，将写往<code>stderr</code>的内容重定向到我们制定的文件中去，一旦执行了上述代码那么在这个之后的NSLog将不会在控制台显示了，会直接输出在指定的文件中。<br>在模拟器中，我们可以使用终端的<code>tail</code>命令(tail -f xxx.log)对这个文件进行实时查看，就如同我们在Xcode的输出窗口中看到的那样，你还可以结合<code>grep</code>命令进行实时过滤查看，非常方便在大量的日志信息中迅速定位到我们要的日志信息。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">FILE * freopen ( const char * filename, const char * mode, FILE * stream );</code></pre>\n\n<p>核心代码如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">NSArray *paths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsPath &#x3D; [paths objectAtIndex:0];\nNSString *loggingPath &#x3D; [documentsPath stringByAppendingPathComponent:@&quot;&#x2F;xxx.log&quot;];\n&#x2F;&#x2F;redirect NSLog\nfreopen([loggingPath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr);</code></pre>\n\n<p>这样我们就可以把可获取的日志文件发送给服务端或者通过itunes共享出来。但是由于iOS严格的沙盒机制，我们无法知道stderr原来的文件路径，也无法直接使用沙盒外的文件，所以freopen无法重定向回去，只能使用第1点所述的dup和dup2来实现。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 重定向\nint origin1 &#x3D; dup(STDERR_FILENO);\nFILE * myFile &#x3D; freopen([loggingPath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr);\n&#x2F;&#x2F; 恢复重定向\ndup2(origin1, STDERR_FILENO);</code></pre>\n\n<h2 id=\"使用GCD的dispatch-Source重定向方式\"><a href=\"#使用GCD的dispatch-Source重定向方式\" class=\"headerlink\" title=\"使用GCD的dispatch Source重定向方式\"></a>使用GCD的dispatch Source重定向方式</h2><p>具体代码如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">- (dispatch_source_t)_startCapturingWritingToFD:(int)fd  &#123;\n    int fildes[2];\n    pipe(fildes);  &#x2F;&#x2F; [0] is read end of pipe while [1] is write end\n    dup2(fildes[1], fd);  &#x2F;&#x2F; Duplicate write end of pipe &quot;onto&quot; fd (this closes fd)\n    close(fildes[1]);  &#x2F;&#x2F; Close original write end of pipe\n    fd &#x3D; fildes[0];  &#x2F;&#x2F; We can now monitor the read end of the pipe\n    char* buffer &#x3D; malloc(1024);\n    NSMutableData* data &#x3D; [[NSMutableData alloc] init];\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n    dispatch_source_t source &#x3D; dispatch_source_create(\n        DISPATCH_SOURCE_TYPE_READ, fd, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));\n    dispatch_source_set_cancel_handler(source, ^&#123;\n        free(buffer);\n    &#125;);\n    dispatch_source_set_event_handler(source, ^&#123;\n        @autoreleasepool &#123;\n\n            while (1) &#123;\n                ssize_t size &#x3D; read(fd, buffer, 1024);\n                if (size &lt;&#x3D; 0) &#123;\n                    break;\n                &#125;\n                [data appendBytes:buffer length:size];\n                if (size &lt; 1024) &#123;\n                    break;\n                &#125;\n            &#125;\n            NSString *aString &#x3D; [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n            &#x2F;&#x2F;printf(&quot;aString &#x3D; %s&quot;,[aString UTF8String]);\n            &#x2F;&#x2F;NSLog(@&quot;aString &#x3D; %@&quot;,aString);\n            &#x2F;&#x2F; Do something\n        &#125;\n    &#125;);\n    dispatch_resume(source);\n    return source;\n&#125;</code></pre>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>虽然上述的几个重定向的方法都能够获取到Log数据，但是弊端是当使用Log重定向之后，连接Xcode进行调试应用程序时，Xcode的Console中将不会打印任何Log信息，Log信息已经被重定向到了我们指定的文件中了。这些方法有一定的局限性，在具体使用的时候，需要视情况而定。当然还有其他的方式能够即重定向Log数据到指定文件，还能够在Xcode的Console中输出日志（pipe、dup2与GCD的相互协作），这样能够避免调试阶段无法实时查看日志的缺陷，进一步的提高开发调试和优化的效率。</p>\n<p>另外也可以开发一个在桌面或者网页端实时展示Log信息的应用，实时从重定向的位置读取Log信息，达到实时查看信息的目的等。</p>\n","text":"在iOS开发的过程中，经常会使用NSLog作为调试和查看相关数据的输出口，该方法连接Xcode构建项目时能够实时输出开发者在代码线中打印的日志。但是在断开Xcode并使用真机测试的时候，经常会无法查看真机的实时日志，导致一些问题难以追查和确定，导致问题的定位与解决花费较长的时间，...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NSLog%E7%9A%84%E8%BE%93%E5%87%BA%E5%88%B0%E5%BA%95%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F\"><span class=\"toc-text\">NSLog的输出到底在哪里？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Apple-System-Logger\"><span class=\"toc-text\">Apple System Logger</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ASL%E5%9C%A8iOS10%E5%90%8E%E8%A2%AB%E5%BC%83%E7%94%A8\"><span class=\"toc-text\">ASL在iOS10后被弃用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NSLog%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">NSLog重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dup2%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">dup2重定向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">文件重定向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8GCD%E7%9A%84dispatch-Source%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">使用GCD的dispatch Source重定向方式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"8大场景数据清洗Python代码","uid":"b1badcef23656fe021b375990b5cfa48","slug":"2019-01-22-data_cleaning","date":"2023-05-13T14:52:09.990Z","updated":"2023-05-13T14:52:09.990Z","comments":true,"path":"api/articles/2019-01-22-data_cleaning.json","keywords":null,"cover":null,"text":"数据清洗是进行数据分析和使用数据训练模型的必经之路，也是最为耗费数据科学家、程序员的地方。 在数据清洗的过程中，绝大多数的场景下，所进行的清洗工作都是相似甚至是重复的，因此有必要将数据清洗工作的场景进行总结并给出对应的清洗代码，以便形成可适用于多数工程项目的工具箱。 涵盖8大场景...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"机器学习","slug":"机器学习","count":10,"path":"api/categories/机器学习.json"}],"tags":[{"name":"机器学习 Python","slug":"机器学习-Python","count":1,"path":"api/tags/机器学习-Python.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"iOS虚拟内存管理","uid":"11480c51ae26bed2fd1029069074ca32","slug":"2019-01-22-iOS_VMManage","date":"2023-05-13T14:52:09.990Z","updated":"2023-05-13T14:52:09.990Z","comments":true,"path":"api/articles/2019-01-22-iOS_VMManage.json","keywords":null,"cover":"/images/vm/memory_manage.jpg","text":"虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}