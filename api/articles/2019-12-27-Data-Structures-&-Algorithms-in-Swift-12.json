{"title":"\\#12\\ 自平衡二叉搜索树（AVL Trees）","uid":"4085c41c06b2e3ba45ef163b731b2c76","slug":"2019-12-27-Data-Structures-&-Algorithms-in-Swift-12","date":"2023-05-14T11:04:02.186Z","updated":"2023-05-14T11:04:02.186Z","comments":true,"path":"api/articles/2019-12-27-Data-Structures-&-Algorithms-in-Swift-12.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/12/cover.png","content":"<p>在上文中，已经了解二叉搜索树的O(log n)性能特征，但是当二叉搜索树节点删除中，可能会出现不平衡的树，并降低树的性能到O(n)。这一文的内容将学习另一种改进了的二叉搜索树 — 自平衡二叉搜索树。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1962年，Georgy Adelson-Velsky和Evgenii Landis提出了第一个自平衡二进制搜索树：AVL树。</p></blockquote>\n<h2 id=\"理解什么是平衡\"><a href=\"#理解什么是平衡\" class=\"headerlink\" title=\"理解什么是平衡\"></a>理解什么是平衡</h2><p>自平衡二叉搜索树，简称平衡树，是在二叉搜索树的基础上改进的，首先了解一下平衡树的三种平衡状态。</p>\n<p><strong>完全平衡树</strong></p>\n<p>二叉搜索树的理想形式便是完全平衡状态，也就是说二叉搜索树的每个层级从上之下均存在节点。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/perfect-tree.png\"></p>\n<p>完全平衡树不仅仅整棵树是对称的，而且最底部的叶子都均存在节点。</p>\n<p><strong>“够好”的平衡树</strong></p>\n<p>尽管完全平衡是理想的平衡树状态，但是在现实中往往难以实现，要达到完全平衡的树结构，需要节点有确切的数量，才有可能达到完全平衡，因此只有一定数量的元素才能平衡。</p>\n<p>例如一棵树有1个、3个、4个节点的时候，是可以达到完全平衡的，但是当树有2个、4个、5个或6个节点的时候，却不能达到完全平衡，因为树的最后一层无法完全被填满。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/balance-tree.png\"></p>\n<p>平衡树的定义是树的每一个层级必须被填满（底部层级除外）。在大多数情况下，二叉树是可以做到的最好的结构。</p>\n<p><strong>不平衡树</strong></p>\n<p>最后一种状态是不平衡的状态，二叉搜索树的不平衡状态会带来各种等级的性能损失。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/unbanlance-tree.png\"></p>\n<p>保持树的平衡会带来查找、插入和移除元素操作O(log n)的时间复杂度。当树的结构不平衡是，AVL树会自动调整树的结构，使得树结构保持平衡，从而带来良好地时间复杂度等。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>AVL树和二叉搜索树有很多地方都是相同的实现，但是为了便于区分，我们将新建文件重新编写关于AVL树的实现。</p>\n<h3 id=\"平衡度衡量\"><a href=\"#平衡度衡量\" class=\"headerlink\" title=\"平衡度衡量\"></a>平衡度衡量</h3><p>要确保二叉树的平衡，就需要一种能够衡量二叉树是否平衡的方法。在AVL树中，每个节点都有一个 <strong>height</strong> 属性，该属性描述了当前节点到叶子节点的<strong>最长距离</strong>。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/node-marks-height.png\"></p>\n<p>我们新建AVLNode类，添加存储节点高度的变量：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public var height &#x3D; 0</code></pre>\n\n<p>在使用中，将使用节点的相对高度来确定节点是否平衡。</p>\n<p>AVL树中左节点和有节点的高度差最多相差1，这个差值称之为<strong>平衡因子</strong>。为了计算的方便，对节点增加如下变量：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public var balanceFactor: Int &#123;\n    return leftHeight - rightHeight\n&#125;\n    \npublic var leftHeight: Int &#123;\n    return leftChild?.height ?? -1\n&#125;\n    \npublic var rightHeight: Int &#123;\n    return rightChild?.height ?? -1\n&#125;</code></pre>\n\n<p><code>balanceFactor</code>平衡因子计算的是左树和右树的高度差，如果子节点为nil，则节点的高度为-1。例如：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/avl-tree-demo.png\"></p>\n<p>该树是一个平衡的二叉树，但是如果增加一个节点40的话，就会改变为不平衡的树：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/unbalance-tree.png\"></p>\n<p>从图中的平衡因子即可判断出该树处于一个不平衡的状态。为了使得不平衡树改变形态，而成为平衡树，需要进一步的操作。</p>\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p>应用于二叉搜索树，使得其平衡的操作称之为<strong>旋转</strong>。共有四种选装的操作，分别是<strong>左旋转</strong>、<strong>左-右旋转</strong>、<strong>右旋转</strong>、<strong>右-左旋转</strong>。</p>\n<p><strong>左旋转</strong></p>\n<p>例如上述不平衡的二叉树中，插入节点40导致树处于不平衡的状态，而是用左旋转可以解决此不平衡问题。左旋转的工作原理如下图：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/left-rotation.png\"></p>\n<p>树在旋转前后会由两点不同之处：</p>\n<ul>\n<li>树节点的有序遍历保持不变；</li>\n<li>旋转后，树的深度减少一级。</li>\n</ul>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func leftRotate(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n    let pivot &#x3D; node.rightChild!\n    node.rightChild &#x3D; pivot.leftChild\n    pivot.leftChild &#x3D; node\n    \n    node.height &#x3D; max(node.leftHeight, node.rightHeight) + 1\n    pivot.height &#x3D; max(pivot.leftHeight, pivot.rightHeight) + 1\n    \n    return pivot\n&#125;</code></pre>\n\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/left-rotation-done.png\"></p>\n<p><strong>右旋转</strong></p>\n<p>右旋转和左旋转类似，如果是由于左节点导致了树不平衡，则使用右旋转的方式，其原理如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/right-rotation.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func rightRotate(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n    let pivot &#x3D; node.leftChild!\n    node.leftChild &#x3D; pivot.rightChild\n    pivot.rightChild &#x3D; node\n        \n    node.height &#x3D; max(node.leftHeight, node.rightHeight) + 1\n    pivot.height &#x3D; max(pivot.leftHeight, pivot.rightHeight) + 1\n    \n    return pivot\n&#125;</code></pre>\n\n<p><strong>右-左旋转</strong></p>\n<p>左旋转和右旋转的操作都有一个特点是：均平衡了树的左节点或右节点。假设有如下的不平衡树：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/left-right-nodes-tree.png\"></p>\n<p>单纯使用左旋转不能得到平衡树，针对此种情况可以先进行右旋转，使得节点均有右节点，然后再使用左旋转，以达到平衡树状态。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/right-left-rotation.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func rightLeftRotate(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n    guard let rightChild &#x3D; node.rightChild else &#123;\n        return node\n    &#125;\n    \n    node.rightChild &#x3D; rightRotate(rightChild)\n    return leftRotate(node)\n&#125;</code></pre>\n\n<p><strong>左-右旋转</strong></p>\n<p>左-右旋转和右-左旋转针对的情形类似，当单纯使用左旋转无法达到平衡的时候，根据节点的情况，再次进行右旋转，以达到平衡状态。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/left-right-rotation.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func leftRightRotate(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n    guard let leftChild &#x3D; node.leftChild else &#123;\n        return node\n    &#125;\n    \n    node.leftChild &#x3D; leftRotate(leftChild)\n    return rightRotate(node)\n&#125;</code></pre>\n\n<h3 id=\"平衡\"><a href=\"#平衡\" class=\"headerlink\" title=\"平衡\"></a>平衡</h3><p>进行了树的节点旋转后，虽然形态上会达到平衡，但是某些节点可能破坏了二叉搜索树的特性，因此还需要根据不同的情形，对数的节点进行交换，这里交换的根据是根据节点的平衡因子进行不同的操作。算法结构如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func balanced(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n  switch node.balanceFactor &#123;\n  case 2:\n    &#x2F;&#x2F; ...\n  case -2:\n    &#x2F;&#x2F; ...\n  default:\n    return node\n  &#125;\n&#125;</code></pre>\n\n<p>该算法会根据三种情况进行节点的转换：</p>\n<ol>\n<li>平衡因子<em>balanceFactor</em>为2的时候，表示节点的左子节点多于右子节点，意味着节需要使用右旋或者左-右旋转；</li>\n<li>平衡因子<em>balanceFactor</em>为-2的时候，表示节点的右子节点多于左子节点，意味着需要使用左旋或者右-左旋转；</li>\n<li>除了这两种情况之外，表示当前节点处于平衡状态，不需要进行任何的转换。</li>\n</ol>\n<p>平衡因子<em>balanceFactor</em>符号能够确定需要使用单旋还是双旋。</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/12/balanceFactor-single-or-double-rotation.png\"></p>\n<p>完整的算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func balanced(_ node: AVLNode&lt;Element&gt;) -&gt; AVLNode&lt;Element&gt; &#123;\n    switch node.balanceFactor &#123;\n    case 2:\n        if let leftChild &#x3D; node.leftChild, leftChild.balanceFactor &#x3D;&#x3D; -1 &#123;\n            return leftRightRotate(node)\n        &#125; else &#123;\n            return rightRotate(node)\n        &#125;\n    case -2:\n        if let rightChild &#x3D; node.rightChild, rightChild.balanceFactor &#x3D;&#x3D; 1 &#123;\n            return rightLeftRotate(node)\n        &#125; else &#123;\n            return leftRotate(node)\n        &#125;\n    default:\n        return node\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"节点的插入\"><a href=\"#节点的插入\" class=\"headerlink\" title=\"节点的插入\"></a>节点的插入</h3><p>至此，节点调整，使得树平衡的工作已经完成了，而该平衡操作大部分情况下是在向树插入新的节点的时候进行的，因此完成插入算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public mutating func insert(_ value: Element) &#123;\n    root &#x3D; insert(from: root, value: value)\n&#125;\n    \nprivate func insert(from node: AVLNode&lt;Element&gt;?, value: Element) -&gt; AVLNode&lt;Element&gt; &#123;\n    guard let node &#x3D; node else &#123;\n        return AVLNode(value: value)\n    &#125;\n    if value &lt; node.value &#123;\n        node.leftChild &#x3D; insert(from: node.leftChild, value: value)\n    &#125; else &#123;\n        node.rightChild &#x3D; insert(from: node.rightChild, value: value)\n    &#125;\n        \n    let balancedNode &#x3D; balanced(node)\n    balancedNode.height &#x3D; max(balancedNode.leftHeight, balancedNode.rightHeight) + 1\n    return balancedNode\n&#125;</code></pre>\n\n<p>节点的插入算法也适用于新建一颗AVL树，例如：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;repeated insertions in sequence&quot;) &#123;\n    var tree &#x3D; AVLTree&lt;Int&gt;()\n    for i in 0 ..&lt; 15 &#123;\n        tree.insert(i)\n    &#125;\n    print(tree)\n&#125;\n\n&#x2F;*\n---Example of repeated insertions in sequence---\n  ┌──14\n ┌──13\n │ └──12\n┌──11\n│ │ ┌──10\n│ └──9\n│  └──8\n7\n│  ┌──6\n│ ┌──5\n│ │ └──4\n└──3\n │ ┌──2\n └──1\n  └──0\n*&#x2F;</code></pre>\n\n<h3 id=\"节点的移除\"><a href=\"#节点的移除\" class=\"headerlink\" title=\"节点的移除\"></a>节点的移除</h3><p>移除树中的节点，也会导致树不平衡，因此在移除算法中也需要对树的平衡性进行调整。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public mutating func remove(_ value: Element) &#123;\n    root &#x3D; remove(from: root, value: value)\n&#125;\n\nprivate func remove(from node: AVLNode&lt;Element&gt;?, value: Element) -&gt; AVLNode&lt;Element&gt;? &#123;\n    guard let node &#x3D; node else &#123;\n        return nil\n    &#125;\n        \n    if value &#x3D;&#x3D; node.value &#123;\n        if node.leftChild &#x3D;&#x3D; nil &amp;&amp; node.rightChild &#x3D;&#x3D; nil &#123;\n            return nil\n        &#125;\n        if node.leftChild &#x3D;&#x3D; nil &#123;\n            return node.rightChild\n        &#125;\n        if node.rightChild &#x3D;&#x3D; nil &#123;\n            return node.leftChild\n        &#125;\n        node.value &#x3D; node.rightChild!.min.value\n        node.rightChild &#x3D; remove(from: node.rightChild, value: node.value)\n    &#125; else if value &lt; node.value &#123;\n        node.leftChild &#x3D; remove(from: node.leftChild, value: value)\n    &#125; else &#123;\n        node.rightChild &#x3D; remove(from: node.rightChild, value: value)\n    &#125;\n        \n    let balancedNode &#x3D; balanced(node)\n    balancedNode.height &#x3D; max(balancedNode.leftHeight, balancedNode.rightHeight) + 1\n    return balancedNode\n&#125;</code></pre>\n\n<p>测试如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;removing a vaue&quot;) &#123;\n    var tree &#x3D; AVLTree&lt;Int&gt;()\n    tree.insert(15)\n    tree.insert(10)\n    tree.insert(16)\n    tree.insert(18)\n    print(tree)\n    \n    tree.remove(10)\n    print(tree)\n&#125;\n\n&#x2F;*\n---Example of removing a vaue---\n ┌──18\n┌──16\n│ └──nil \n15\n└──10\n\n┌──18\n16\n└──15\n*&#x2F;</code></pre>\n\n<p>移除了元素10之后，树进行了平衡调整（左旋），依然保持树的平衡性。由于节点的插入和移除操作同于二叉搜索树，因此其时间复杂度依然是O(log n)。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>自平衡树在节点的插入和移除过程中，增加平衡性调节操作，保持其执行效率不会降低；</li>\n<li>AVL树在树不平衡的情况下，通过重新调整树的部分节点，而使得树保持平衡。</li>\n</ul>\n","text":"在上文中，已经了解二叉搜索树的O(log n)性能特征，但是当二叉搜索树节点删除中，可能会出现不平衡的树，并降低树的性能到O(n)。这一文的内容将学习另一种改进了的二叉搜索树 — 自平衡二叉搜索树。 1962年，Georgy Adelson-Velsky和Evgenii Land...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1\"><span class=\"toc-text\">理解什么是平衡</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1%E5%BA%A6%E8%A1%A1%E9%87%8F\"><span class=\"toc-text\">平衡度衡量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\">旋转</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1\"><span class=\"toc-text\">平衡</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E7%9A%84%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">节点的插入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E7%9A%84%E7%A7%BB%E9%99%A4\"><span class=\"toc-text\">节点的移除</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#11\\ 二叉搜索树","uid":"1c072eaf9d0ebbcfebf6203a3cb43879","slug":"2019-12-25-Data-Structures-&-Algorithms-in-Swift-11","date":"2023-05-14T11:04:02.186Z","updated":"2023-05-14T11:04:02.186Z","comments":true,"path":"api/articles/2019-12-25-Data-Structures-&-Algorithms-in-Swift-11.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/11/cover.jpg","text":"二叉搜索树又称为二叉查找树（BST），是一种支持快速查找、插入和删除操作的树结构，例如下方的决策树，其中选择一方而放弃另一方的所有可能性，从而将问题减半。 在决策树中，一旦做出了决定并选择了某个分支，便不能回头，在选择的分支上一直查找直到叶子节点，得到最终决定。二叉搜索树在上一文...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#13\\ 字典树（Tries Tree）","uid":"7c0350b0f98d8a7fc26f52b6c73852fb","slug":"2020-01-06-Data-Structures-&-Algorithms-in-Swift-13","date":"2023-05-14T11:04:02.186Z","updated":"2023-05-14T11:04:02.186Z","comments":true,"path":"api/articles/2020-01-06-Data-Structures-&-Algorithms-in-Swift-13.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/13/cover.jpg","text":"Tries 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}