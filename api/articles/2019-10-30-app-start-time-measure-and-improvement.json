{"title":"关于iOS App启动时间的那些事","uid":"065e711203c90529e076df9f2cdf951d","slug":"2019-10-30-app-start-time-measure-and-improvement","date":"2023-05-19T09:57:19.841Z","updated":"2023-05-19T09:57:19.841Z","comments":true,"path":"api/articles/2019-10-30-app-start-time-measure-and-improvement.json","keywords":null,"cover":"/images/start-time/cover.jpg","content":"<p>在iOS应用程序的开发过程中，应用的启动时长可谓是影响应用程序用户体验的第一要素，过长的应用启动耗时，势必带来用户的长时间等待，直接让用户失去了对应用程序进一步体验的兴趣，影响应用程序在用户心中的印象。一般情况下，应用程序开发完成上线后，接下来就是针对架构、性能、业务进行进一步优化和调整的阶段，这个阶段也是检验一个iOS开发工程师内功的时候。</p>\n<h2 id=\"iOS应用启动方式\"><a href=\"#iOS应用启动方式\" class=\"headerlink\" title=\"iOS应用启动方式\"></a>iOS应用启动方式</h2><p>iOS应用程序的启动整体分为<strong>冷启动</strong>和<strong>热启动</strong>两种方式，两种启动方式具有不同的启动触发条件，也是在不同的业务场景模式下，最终导致应用启动，进而延续业务的方式。</p>\n<ul>\n<li><strong>冷启动：</strong>指的是当应用还没准备好运行时，必须从零开始加载和构建整个应用。包括设置屏幕底部的分栏菜单，确保用户是否被合适地登录，以及处理其他更多的事情。整个应用程序的入口是在*applicationDidFinishLaunching:withOptions:*方法中开始的。</li>\n<li><strong>热启动：</strong>指的是应用已经运行但是在后台被挂起（比如用户点击了 <code>home</code> 健）。在这种情况下，应用通过 <em>applicationWillEnterForeground:</em> 接收到回到前台的事件，接着应用恢复。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>另一种理解是，冷启动时App的进行不存在，系统需要为App分配进程等资源，以供App正确启动，而热启动时，App进程是存在的，只是App处于被挂起状态，热启动可以认为是App恢复形式的启动。</p></blockquote>\n<p>在应用启动时间的衡量和治理上，往往<strong>冷启动</strong>是重中之重，因为严格意义上，冷启动是包含热启动的（冷启动初始化应用程序并获取摘要，热启动仅获取摘要），另外，冷启动需要做的工作更多，其中包含了一些额外的初始化工作，也更加的耗时，因此，针对冷启动的治理更加有意义。</p>\n<h2 id=\"冷启动的定义\"><a href=\"#冷启动的定义\" class=\"headerlink\" title=\"冷启动的定义\"></a>冷启动的定义</h2><p>通常情况下，针对iOS的冷启动过程是从用户点击App图标开始到*applicationDidFinishLaunching:withOptions:*方法执行完毕为止，在这个过程中主要分为两个阶段：</p>\n<ul>\n<li>T1阶段：应用程序*main()<em>函数执行之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载和链接等工作，最后执行至App的</em>main()*函数。</li>\n<li>T2阶段：*main()<em>函数执行之后，即从</em>main()<em>函数开始，到</em>applicationDidFinishLaunching:withOptions:*方法执行完毕。</li>\n</ul>\n<p><img src=\"/images/start-time/code-start.jpg\"></p>\n<p>在T1阶段，通常也被称为<strong>pre-main</strong>阶段，在该阶段，主要的工作主角是操作系统，此时会执行如下几个工作：</p>\n<p><img src=\"/images/start-time/pre-main\"></p>\n<p>在<strong>pre-main</strong>阶段做进行的各个任务，其主要工作也不尽相同，操作系统采用分而治之的策略，并顺序执行（可能会有并行的情况）。</p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>工作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Load dylibs</td>\n<td>Dyld从主执行文件的header中获取到需要加载的所依赖动态库列表，然后找到动态库所对应的每个dylib，而应用所依赖的dylib文件还可能依赖其他的dylib，所以所需要加载的动态列表是一个递归依赖的集合。</td>\n</tr>\n<tr>\n<td>Rebase</td>\n<td>Rebase是在Image内部调整指针的指向。在历史OS中，会把动态库加载到指定的地址，所有指针和数据对应的代码都是正确的，而在随着OS的演进，指针和数据所对应的地址空间演变成了随机化的方式，所以需要在原来地址的基础上根据随机的地址偏移量进行指向修正。</td>\n</tr>\n<tr>\n<td>Bind</td>\n<td>Bind是把指针正确地指向Image外部的内容，这些指向外部的指针被符号（symbol）名称绑定，dyld需要去符号表里进行查找，找到symbol对应的实现。</td>\n</tr>\n<tr>\n<td>ObjC Setup</td>\n<td>- 注册ObjC类（class registration）  - 把category的定义插入到方法列表（category registration） - 保证每个selector的唯一性（selector uniquing）</td>\n</tr>\n<tr>\n<td>Initializers</td>\n<td>- ObjC的+load()函数   - C++的构造函数属性函数等  - 非基本类型的C++静态全局变量的创建（通常是类或结构体）</td>\n</tr>\n</tbody></table>\n<h2 id=\"pre-main阶段耗时统计\"><a href=\"#pre-main阶段耗时统计\" class=\"headerlink\" title=\"pre-main阶段耗时统计\"></a>pre-main阶段耗时统计</h2><p>对于pre-main阶段，Xcode提供了针对上述各个阶段耗时统计的功能，只需要开发者为项目添加特殊的环境变量即可。针对pre-main耗时统计的环境变量有两个，分贝是<strong>DYLD_PRINT_STATISTICS</strong>和<strong>DYLD_PRINT_STATISTICS_DETAILS</strong>，前者是各个阶段的整体耗时统计，后者会输出一些更加详细的参数。</p>\n<p>Xcode环境变量的添加位置在 <em>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Environment Variables</em>。</p>\n<p><img src=\"/images/start-time/var-env.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>DYLD_PRINT_STATISTICS</strong>和<strong>DYLD_PRINT_STATISTICS_DETAILS</strong>的值设置为1表示开启，0表示关闭，默认为0.</p></blockquote>\n<p>设置之后，重启App，则会在Xcode的console中看到如下的统计输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Total pre-main time: 216.18 milliseconds (100.0%)\n         dylib loading time:  61.15 milliseconds (28.2%)\n        rebase&#x2F;binding time: 126687488.9 seconds (372410141.8%)\n            ObjC setup time:  25.85 milliseconds (11.9%)\n           initializer time: 174.40 milliseconds (80.6%)\n           slowest intializers :\n             libSystem.B.dylib :  13.24 milliseconds (6.1%)\n   libBacktraceRecording.dylib :   7.55 milliseconds (3.4%)\n    libMainThreadChecker.dylib : 144.91 milliseconds (67.0%)\n                              ...</code></pre>\n\n<p>当然我们也可以获取更详细的时间，只需将环境变量 <strong>DYLD_PRINT_STATISTICS_DETAILS</strong> 设为 1 就可以得到更加详细的信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">total time: 966.57 milliseconds (100.0%)\n  total images loaded:  334 (327 from dyld shared cache)\n  total segments mapped: 21, into 370 pages\n  total images loading time: 710.13 milliseconds (73.4%)\n  total load time in ObjC:  20.68 milliseconds (2.1%)\n  total debugger pause time: 472.96 milliseconds (48.9%)\n  total dtrace DOF registration time:   0.15 milliseconds (0.0%)\n  total rebase fixups:  17,943\n  total rebase fixups time:   2.25 milliseconds (0.2%)\n  total binding fixups: 457,972\n  total binding fixups time: 188.15 milliseconds (19.4%)\n  total weak binding fixups time:   0.01 milliseconds (0.0%)\n  total redo shared cached bindings time: 201.78 milliseconds (20.8%)\n  total bindings lazily fixed up: 0 of 0\n  total time in initializers and ObjC +load:  45.17 milliseconds (4.6%)\n                         libSystem.B.dylib :   5.18 milliseconds (0.5%)\n               libBacktraceRecording.dylib :   5.59 milliseconds (0.5%)\n                            CoreFoundation :   1.99 milliseconds (0.2%)\n                libMainThreadChecker.dylib :  27.94 milliseconds (2.8%)\n                    libLLVMContainer.dylib :   1.89 milliseconds (0.1%)\ntotal symbol trie searches:    1109484\ntotal symbol table binary searches:    0\ntotal images defining weak symbols:  37\ntotal images using weak symbols:  92</code></pre>\n\n<p>有了以上信息，就可以对pre-main阶段的时间消耗进行一个度量和优化了。那么除了上述两个环境变量外，Xcode还支持dyld的其他一些环境变量，如下：</p>\n<table>\n<thead>\n<tr>\n<th>环境变量</th>\n<th>描述说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DYLD_PRINT_SEGMENTS</td>\n<td>日志段映射</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_INITIALIZERS</td>\n<td>日志图像初始化要求</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_BINDINGS</td>\n<td>日志符号绑定</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_APIS</td>\n<td>日志dyld API调用(例如，dlopen)</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_ENV</td>\n<td>打印启动环境变量</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_OPTS</td>\n<td>打印启动时命令行参数</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_LIBRARIES_POST_LAUNCH</td>\n<td>日志库加载，但仅在main运行之后</td>\n</tr>\n<tr>\n<td>DYLD_PRINT_LIBRARIES</td>\n<td>日志库加载</td>\n</tr>\n<tr>\n<td>DYLD_IMAGE_SUFFIX</td>\n<td>首先搜索带有这个后缀的库</td>\n</tr>\n</tbody></table>\n<h2 id=\"pre-main阶段的优化策略\"><a href=\"#pre-main阶段的优化策略\" class=\"headerlink\" title=\"pre-main阶段的优化策略\"></a>pre-main阶段的优化策略</h2><p>从上可知，在pre-mian阶段，应用程序会执行dylib loading、rebase&#x2F;binding、ObjC setup、initializers四个步骤，从每个阶段的主要工作分析得知：</p>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>优化策略</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Load dylibs</td>\n<td>1.尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大；2.合并已有的dylib和使用静态库（static archives），减少dylib的使用个数；3.懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多</td>\n</tr>\n<tr>\n<td>Rebase&amp;Bind</td>\n<td>1.减少ObjC类（class）、方法（selector）、分类（category）的数量；2.减少C++虚函数的的数量（创建虚函数表有开销）；3.使用Swift structs（内部做了优化，符号数量更少）</td>\n</tr>\n<tr>\n<td>ObjC Setup</td>\n<td>减少 Objective-C Class、Selector、Category 的数量，可以合并或者删减一些OC类</td>\n</tr>\n<tr>\n<td>Initializers</td>\n<td>1.少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize；2.减少构造器函数个数，在构造器函数里少做些事情；3.减少C++静态全局变量的个数）</td>\n</tr>\n</tbody></table>\n<p>简单概括就是</p>\n<ol>\n<li>应用程序所依赖的动态库越多，启动越慢；</li>\n<li>ObjC的类、方法越多，启动越慢；</li>\n<li>Objc的+load()越多，或+load()中有过多的逻辑，启动越慢；</li>\n<li>C的constructor函数越多，启动越慢；</li>\n<li>C++静态对象越多，启动越慢。</li>\n</ol>\n<p>以上是对iOS App启动（主要针对冷启动）耗时的一点总结性内容，在具体的项目开发过程中，开发人员应当追求更加简洁高效的代码实现，追求高内聚，低耦合的项目架构，并有意的进行代码优化，使得App的启动耗时控制在良好的范围内，只有高效的启动，才不会再App的第一关就被Pass掉，从而为后续的业务提供良好的开端。</p>\n<h2 id=\"工具集\"><a href=\"#工具集\" class=\"headerlink\" title=\"工具集\"></a>工具集</h2><p>在了解了如何进行pre-main阶段耗时治理的策略之后，你可以动手进行一系列的优化提升，这里不进行具体的代码展示，列出两个可使用的工具，有兴趣的小伙伴可以详细研读学习。</p>\n<ul>\n<li><a href=\"https://github.com/nst/objc_cover\">objc_cover</a>：一款通过对Mach-O文件进行解读，从中找到方法列表后，根据是否有对方法进行引用判定方法是否有用，可以用来删除项目中无用的方法。</li>\n<li><a href=\"https://github.com/jinshilaoyao/DynamicLoader/tree/5ef77c9ce819304009cf6c610b526668962dfa17\">DynamicLoader</a>：一款<em>项目自启动</em>技术，实现了可插拔的函数的注册和启动等。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/413/\">App Startup Time: Past, Present, and Future</a></li>\n<li><a href=\"https://github.com/izhangxb/GMTC/blob/master/%E5%85%A8%E7%90%83%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9AGMTC%202017%20PPT/%E6%89%8B%E6%B7%98iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%20.pdf\">手淘iOS性能优化探索</a></li>\n<li><a href=\"https://juejin.im/post/5ab47ca1518825611a406a39\">探秘 Mach-O 文件</a></li>\n</ul>\n","text":"在iOS应用程序的开发过程中，应用的启动时长可谓是影响应用程序用户体验的第一要素，过长的应用启动耗时，势必带来用户的长时间等待，直接让用户失去了对应用程序进一步体验的兴趣，影响应用程序在用户心中的印象。一般情况下，应用程序开发完成上线后，接下来就是针对架构、性能、业务进行进一步优...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"开发知识","slug":"开发知识","count":9,"path":"api/categories/开发知识.json"}],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iOS%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">iOS应用启动方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%B7%E5%90%AF%E5%8A%A8%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">冷启动的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pre-main%E9%98%B6%E6%AE%B5%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1\"><span class=\"toc-text\">pre-main阶段耗时统计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pre-main%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">pre-main阶段的优化策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E9%9B%86\"><span class=\"toc-text\">工具集</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"What is Event Modeling?","uid":"0eccc1a2eb6b2260157a3a0e333d43b7","slug":"2019-10-23-what-is-event-modeling","date":"2023-05-19T09:57:19.841Z","updated":"2023-05-19T09:57:19.841Z","comments":true,"path":"api/articles/2019-10-23-what-is-event-modeling.json","keywords":null,"cover":"/images/img/hero.jpg","text":"Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the clearest c...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"技术人生","slug":"技术人生","count":10,"path":"api/categories/技术人生.json"}],"tags":[{"name":"技术人生","slug":"技术人生","count":5,"path":"api/tags/技术人生.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"探索性数据分析入门","uid":"3158244125ce6cdd857a3a3ca56bd557","slug":"2019-11-04-simple-eda","date":"2023-05-19T09:57:19.841Z","updated":"2023-05-19T09:57:19.841Z","comments":true,"path":"api/articles/2019-11-04-simple-eda.json","keywords":null,"cover":"/images/simple-eda/cover.png","text":"在数据科学领域里，最具挑战的问题之一便是如何确定数据对特定问题带来价值。在使用机器学习或者深度学习之前，确定数据或者特征是否利于特定问题，是数据科学后续工作的重中之重。 因此，在进行数据科学问题之前，通常会对数据进行分析，洞察数据中所涵盖的深层特性是否利于特定问题，以及是否适用于...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据科学","slug":"数据科学","count":2,"path":"api/categories/数据科学.json"}],"tags":[{"name":"数据科学 Python","slug":"数据科学-Python","count":1,"path":"api/tags/数据科学-Python.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}