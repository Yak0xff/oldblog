{"title":"使用 SwiftUI 构建大型应用程序---模块化架构指南","uid":"08bdf0f69e5779f7a64223e85a9013a5","slug":"2023-05-13-build-large-scale-apps-swiftui","date":"2023-05-13T15:32:33.641Z","updated":"2023-05-13T15:32:33.641Z","comments":true,"path":"api/articles/2023-05-13-build-large-scale-apps-swiftui.json","keywords":null,"cover":"https://raw.githubusercontent.com/zycslog/assets-pro/main/fotis-fotopoulos-SyvsTmuuZyM-unsplash.jpg","content":"<p>软件架构始终是一个热门争论的话题，特别是当有这么多不同的选择时。在过去的 8-12 个月里，作者一直在尝试使用 MV 模式来构建客户端&#x2F;服务器应用程序，并在我最初的文章中写到了这一点 <a href=\"https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html\">SwiftUI 架构 - MV 模式方法的完整指南</a>。在本文中，作者将讨论如何将 MV 模式应用于构建大型客户端&#x2F;服务器应用程序。从SwiftUI本身的设计模式触发，探索SwiftUI在大型应用程序中如何使用MV模式来构建，以及其合理性等，很值得一读。</p>\n<hr>\n<p>Software architecture is always a topic for hot debate, specially when there are so many different choices. For the last 8-12 months, I have been experimenting with MV pattern to build client&#x2F;server apps and wrote about it in my original article <a href=\"https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html\">SwiftUI Architecture - A Complete Guide to MV Pattern Approach</a>. In this article, I will discuss how MV pattern can be applied to build large scale client&#x2F;server applications.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Architecture and patterns depends on the type of application you are building. No single architecture will work in all scenarios. Choose the best architecture suitable for your application needs.</p></blockquote>\n<p>The outline of this article is shown below:</p>\n<ul>\n<li>Modular Architecture</li>\n<li>Understanding the MV Pattern</li>\n<li>Screens vs Views</li>\n<li>Multiple Aggregate Models</li>\n<li>View Specific Logic</li>\n<li>Validation</li>\n<li>Navigation</li>\n<li>Grouping View Events</li>\n<li>Testing</li>\n</ul>\n<h2 id=\"Modular-Architecture\"><a href=\"#Modular-Architecture\" class=\"headerlink\" title=\"Modular Architecture\"></a>Modular Architecture</h2><p>Modular architecture in software refers to the design and organization of software systems into small, self contained modules or components. These modules can be tested and maintained independently of one another. Each module serves a specific purpose and solve a specific business requirement.</p>\n<p>Modular architecture also provides advantages when working on large projects consisting of multiple teams. Each team can work on a particular module, without interfering with each other.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>If you are working on a module that will be consumed or used by other teams then make sure that you are communicating with them and not creating the module in complete isolation. A lot of problems in software development exists solely because of lack of communication between teams.</p></blockquote>\n<p>Modularity can be achieved in several different ways. You can expose each module as a package (SPM), which can be imported into different applications. Modularity can also be achieved by structuring your app based on specific grouping or folder structure. Keep in mind that when using folders for modularity you have to pay special attention to separation of concerns and single responsibility principles.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The focus of this article is not Swift Package Manager, but how to achieve modularity by breaking the app based on the bounded context of the application. <strong>Swift Package Manager can be used to package those dependencies into reusable modules.</strong></p></blockquote>\n<h2 id=\"Understanding-the-MV-Pattern\"><a href=\"#Understanding-the-MV-Pattern\" class=\"headerlink\" title=\"Understanding the MV Pattern\"></a>Understanding the MV Pattern</h2><p>The main idea behind the MV Pattern is to allow views directly talk to the model. This eliminates the need for creating unnecessary view models for each view, which simply contribute to the size of the project but does not provide any additional benefits.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MV Pattern does not advocate putting all the logic in view. That particular pattern is known as <a href=\"https://www.patterns.dev/posts/presentational-container-pattern/\">Container Pattern</a>. I have also talked about it on my blog. You can read about it <a href=\"https://azamsharp.com/2023/01/24/introduction-to-container-pattern.html\">here</a>.</p></blockquote>\n<p>One of the most confusing things about SwiftUI are the views. I don’t blame you, I don’t think they should be called views. They should have been called Widgets (Flutter) or Components (React). The views in SwiftUI are not like traditional UIKit views. They are just the declaration of what you want to be displayed on the screen.</p>\n<p>The views in SwiftUI, reminds me of ReactJS JSX syntax. Let’s take a look at a very small example.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function App() &#123;\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;\n            &lt;button&gt;Save&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;</code></pre>\n\n<p>In the above ReactJS code, we have created a functional component called <code>App</code>. The App component returns a <code>&lt;div&gt;</code> element containing a <code>&lt;h1&gt;</code> and <code>&lt;button&gt;</code>. The thing to notice here is that those are not actual HTML elements. Those are virtual DOM (Document Object Model) elements managed by React framework. The main reason is that React needs to track changes to those elements so it can only render, what has changed. Once React finds out the changed elements using the diffing process, those virtual DOM elements are used to render real HTML elements on the screen.</p>\n<p>I believe SwiftUI uses the same concepts internally. The views in the body property are not actual views but the declaration of views. Eventually, those views gets converted to real views and then displayed on the screen. John Sundell also talked about it in his article <a href=\"https://www.swiftbysundell.com/articles/swiftui-views-versus-modifiers/\">SwiftUI views versus modifiers</a>.</p>\n<p>If you are interested in learning more about the concept of virtual DOM then check out this talk title <a href=\"https://youtu.be/GW0rj4sNH2w?t=301\">Tom Occhino and Jordan Walke: JS Apps at Facebook</a>. This is the talk, where Facebook introduced ReactJS to the public.</p>\n<p>Apple also talks about it in their article <a href=\"https://developer.apple.com/documentation/swiftui/model-data\">Model data</a> published on SwiftUI official documentation page.</p>\n<p>Ok now back to the MV pattern!</p>\n<p>In WWDC 2020 talk titled <a href=\"https://developer.apple.com/videos/play/wwdc2020/10040/\">Data Essentials in SwiftUI</a> Apple presented the following diagram.</p>\n<p><img src=\"https://azamsharp.com/images/single-source.png\" alt=\"ObservableObject as the data dependency surface\"></p>\n<p>The main idea is to provide view access to a single layer or surface that serves as the source of truth and allows access to all entities within the application.</p>\n<p>Apple sample projects, which includes <a href=\"https://developer.apple.com/documentation/swiftui/fruta_building_a_feature-rich_app_with_swiftui\">Fruta</a> and <a href=\"https://developer.apple.com/documentation/swiftui/food_truck_building_a_swiftui_multiplatform_app\">FoodTruck</a> applications demonstrated how to use this pattern against a hard-coded data source. But in WWDC video title <strong>“<a href=\"https://developer.apple.com/videos/play/wwdc2022/110360/\">Use Xcode for server-side development</a>“</strong> Apple showed how to update the existing FoodTruck app and consume the data from an API response.</p>\n<p>The screenshot below shows <code>FoodTruckModel</code> using the <code>DonutsServerClient</code> to retrieve list of donuts. DonutsServerClient is responsible for making an actual request to the server and downloading the donuts. Once the donuts are downloaded they are assigned to the serverDonuts property maintained by the FoodTruckModel.</p>\n<p><img src=\"https://azamsharp.com/images/xcode-server.png\" alt=\"Use Xcode for server-side development\"></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2022/110360/\">Use Xcode for server-side development</a></p>\n<p>Here is the updated diagram to support the networking layer.</p>\n<p><img src=\"https://azamsharp.com/images/aggregate-model-updated.001.jpeg\" alt=\"Aggregate Root\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I know what you are thinking. Are we going to take advice based on Apple’s code samples blindly? No! Never take any advice blindly. Always invest time and research and weigh the advantages and disadvantages of each approach. I have evaluated many different techniques and patterns and found this to be the best and simplest option when building client&#x2F;server apps using SwiftUI. <strong>Do your research!</strong>.</p></blockquote>\n<p>Based on Apple’s recommendation in their WWDC videos and code samples and my own personal experience, I have been implementing a single aggregate model, which holds the entire state of the application. For small and medium sized apps, a single aggregate model might be enough. For complicated apps, you can have multiple aggregate models which will group related entities together. Multiple aggregate models are discussed later in this article.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Once again keep in mind that this article is about client&#x2F;server apps. If you are using Core Data or anything else then you will have to do your research. For purely Core Data apps, I have been experimenting with Active Record Pattern. You can read about it <a href=\"https://azamsharp.com/2023/01/30/active-record-pattern-swiftui-core-data.html\">here</a>.</p></blockquote>\n<p>Following the pattern discussed in <a href=\"https://developer.apple.com/videos/play/wwdc2022/110360/\">Use Xcode for server-side development</a> talk, here is the StoreModel I have implemented for my application.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class StoreModel: ObservableObject &#123;\n    \n    private var storeHTTPClient: StoreHTTPClient\n    \n    init(storeHTTPClient: StoreHTTPClient) &#123;\n        self.storeHTTPClient &#x3D; storeHTTPClient\n    &#125;\n    \n    @Published var products: [Product] &#x3D; []\n    @Published var categories: [Category] &#x3D; []\n    \n    func addProduct(_ product: Product) async throws &#123;\n         try await storeHTTPClient.addProduct(product)\n    &#125;\n    \n    func populateProducts() async throws &#123;\n        self.products &#x3D; try await storeHTTPClient.loadProducts()\n    &#125;\n&#125;</code></pre>\n\n<p><code>StoreModel</code> is an aggregate model that centralizes all the data for the application. Views communicate directly with the StoreModel to perform queries and persistence operations. StoreModel also utilizes <code>StoreHTTPClient</code>, which is used to perform network operations. StoreHTTPClient is a stateless network layer. This means it can be used in other parts of the application that are not SwiftUI, meaning UIKit or even on a different platform (macOS).</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>In Domain-Driven Design (DDD), an aggregate is a cluster of related objects that are treated as a single unit of work for the purpose of data consistency and transactional boundaries. An aggregate model, then, is a representation of an aggregate in code, typically as a class or group of classes.</p></blockquote>\n<p>StoreModel can be used in a variety of different ways. You can use StoreModel as a @StateObject if you only want the data available to a particular view and if you want to tie the object with the lifetime of the view. But quite often I find myself adding StoreModel to @EnvironmentObject so that it can be available in the injected view and all of its sub views.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@main\nstruct StoreAppApp: App &#123;\n    var body: some Scene &#123;\n        WindowGroup &#123;\n            ContentView()\n                .environmentObject(StoreModel(client: StoreHTTPClient()))\n            \n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>After the StoreModel is injected through the @EnvironmentObject, you can access the <code>StoreModel</code> as shown in the implementation below.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ContentView: View &#123;\n\n    @EnvironmentObject private var model: StoreModel\n    \n    var body: some View &#123;\n        ProductListView(products: model.products)\n            .task &#123;\n                do &#123;\n                    try await model.populateProducts()\n                &#125; catch &#123;\n                    print(error.localizedDescription)\n                &#125;\n            &#125;\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>You might be tempted to use <code>@EnvironmentObject</code> inside all the views. Although, it will work as expected but for larger applications you need to make presentation views free of any dependencies. Presentation views are usually child views that are created for the purpose of reusability. It you try to access <code>@EnvironmentObject</code> inside the child views then it effects their reusability status and they become less useful. The main reason is that now they are dependent on the <code>@EnvironmentObject</code> to provide data to them. Instead we should follow the top-down approach, where the data is passed from the parent view to the child view. This is also known as the <a href=\"https://www.patterns.dev/posts/presentational-container-pattern/\">Container&#x2F;Presentation pattern</a>.</p></blockquote>\n<p>Apart from fetching and persistence, StoreModel can also provide sorting, filtering, searching and other operations directly to the view.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>If I was using the traditional MVVM pattern then I would create several view models to accommodate each screen. This can include <code>ProductListViewModel</code>, <code>ProductViewModel</code>, <code>AddProductViewModel</code>, <code>ProductDetailViewModel</code> and many more. Most of the time, these view models end up with one or two functions and maintaining a single source of truth can become very hard. In MV pattern, the view itself is the view model so we don’t need to create unnecessary view models for most of the time. The view, which is also a view model is simply going to ask model (Aggregate Model) for the data.</p></blockquote>\n<p><strong>The source of truth in a client&#x2F;server application is the server.</strong>. This means you should not be adding view models conforming to ObservableObject (new source of truth) protocol just because you added a new view. The source of truth for that view has not changed, it is still the server.</p>\n<p>A single StoreModel is ideal for small or even medium sized apps. But for larger apps it will be a good idea to introduce multiple aggregate models based on the bounded context of the application. In the next section, we will cover multiple aggregate models and how they benefit when working in large teams.</p>\n<h2 id=\"Multiple-Aggregate-Models\"><a href=\"#Multiple-Aggregate-Models\" class=\"headerlink\" title=\"Multiple Aggregate Models\"></a>Multiple Aggregate Models</h2><p>As you learned in the previous section, the purpose of an aggregate model is to expose data to your view. As Luca explained in <a href=\"https://developer.apple.com/videos/play/wwdc2020/10040/\">Data Essentials in SwiftUI WWDC 2020 (11:30)</a> “The aggregate model is an <code>ObservableObject</code>, which acts as your data dependency surface. This allows us to model the data using value type and manage its life cycle and side effects with a reference type.”</p>\n<p>As your business grows, a single aggregate model might not be enough to maintain the life cycle and side effects of an entire application. This is where we will introduce multiple aggregate models. These aggregate models are based on the bounded context of the application. Bounded context refers to a specific area of the system that has clear boundaries and is designed to serve a particular business purpose.</p>\n<p>In an e-commerce application, we can have several bounded contexts including checkout process, inventory management system, catalog, fulfillment, shipment, ordering, marketing and customer management modules.</p>\n<p>Defining bounded context is important in software development and it helps to break down the application into small manageable pieces. This also allows teams to work on different parts of the system without interfering with each other.</p>\n<p>Developers are usually not good in finding bounded context for software applications. The main reason is that their technical knowledge does not directly map to domain knowledge. Domain knowledge requires different set of skills and a domain expert is a better suited for this kind of role. A domain expert is a person, who may not be tech savvy but understands how the business or a particular domain works. In large projects, you may have multiple domain experts, each handling a different business domain. This is why it is extremely important for developers to communicate with domain experts and understand the domain before starting any development.</p>\n<p>Once, you have identified different bounded contexts associated with your application you can represent them in the form of aggregate models. This is shown in the diagram below.</p>\n<p><img src=\"https://azamsharp.com/images/aggregate-model-updated.002.jpeg\" alt=\"Multiple Aggregate Root\"></p>\n<p>The network layer can also be divided into multiple HTTP clients or you can use a single generic network layer for your entire application. This is shown in the following diagram.</p>\n<p><img src=\"https://azamsharp.com/images/aggregate-model-updated.003.jpeg\" alt=\"Multiple Aggregate Root\"></p>\n<p>The Catalog aggregate model will be responsible for providing views with all the entities associated with Catalog. This can include but not limited to:</p>\n<ul>\n<li>Product</li>\n<li>Category</li>\n<li>Brand</li>\n<li>Review</li>\n</ul>\n<p>The Ordering aggregate model will be responsible for providing views with all the ordering related entities. This can include but not limited to:</p>\n<ul>\n<li>Order</li>\n<li>OrderLineItem</li>\n<li>OrderStatus</li>\n<li>ShippingMethod</li>\n<li>Discount</li>\n</ul>\n<p>The <code>Catalog</code> and <code>Ordering</code> aggregate models will be reference types conforming to <code>ObservableObject</code> protocol. And all the entities they provide will be value types.</p>\n<p>The outline of <code>Catalog</code> aggregate model and <code>Product</code> entity is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nstruct Product: Codable &#123;\n    let productId: Int\n    let name: String\n    let category: Category\n    let price: Double\n    let description: String\n    let reviews: [Review]?\n&#125;\n\n@MainActor \nclass Catalog: ObservableObject &#123;\n    \n    &#x2F;&#x2F; designated or generic HTTP client \n    let storeHTTPClient: StoreHTTPClient\n    \n    @Published var products: [Product]\n    @Published var categories: [Category]\n    \n    init(storeHTTPClient: StoreHTTPClient) &#123;\n        self.storeHTTPClient &#x3D; storeHTTPClient\n    &#125;\n    \n    func loadProducts() &#123;\n         products &#x3D; storeHTTPClient.loadProducts\n    &#125;\n    \n    func getProductById(_ productId: Int) -&gt; Product? &#123;\n        &#x2F;&#x2F; fetch product by id \n    &#125;\n    \n    func getProductsByCategory(_ categoryId: Int) -&gt; [Product] &#123;\n       &#x2F;&#x2F; get products by category\n    &#125;\n    \n    func getCategories() -&gt; [Category] &#123;\n        categories &#x3D; storeHTTPClient.loadCategories()\n    &#125;\n&#125;</code></pre>\n\n<p>Catalog and Ordering aggregate models are injected into the application as an environment object. You can inject them directly in your application root view or the root view of each section of the application. The later is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@main\nstruct StoreApp: App &#123;\n    \n    var body: some Scene &#123;\n        WindowGroup &#123;\n            ContentView()\n                .environmentObject(Catalog(client: CatalogHTTPClient()))\n                .environmentObject(Ordering(client: OrderingHTTPClient()))\n            \n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Now, inside a view you can use Catalog or Ordering models by accessing it through <code>@EnvironmentObject</code>. The implementation is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct CatalogListScreen: View &#123;\n    \n    @EnvironmentObject private var catalog: Catalog\n    \n    var body: some View &#123;\n        List(catalog.products) &#123; product in\n            Text(product.name)\n        &#125;.task &#123;\n            do &#123;\n                try await catalog.loadProducts()\n            &#125; catch &#123;\n                print(error.localizedDescription)\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>If your view needs to access ordering information then it can utilize the Ordering aggregate model too.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct AdminDashboardScreen: View &#123;\n    \n    @EnvironmentObject private var catalog: Catalog\n    @EnvironmentObject private var ordering: Ordering\n    \n    var body: some View &#123;\n        VStack &#123;\n            List(catalog.products) &#123; product in\n                Text(product.name)\n            &#125;\n            List(ordering.allOrders) &#123; order in\n                Text(order.status)\n            &#125;\n        &#125;.task &#123;\n            do &#123;\n                try await catalog.loadProducts()\n                try await ordering.loadOrders()\n            &#125; catch &#123;\n                print(error.localizedDescription)\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>There are scenarios when your aggregate model will need to access information from another aggregate model. In those cases, your aggregate model will simply use the network service to fetch the information that is needs.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>It is important that your caching layer is called from within the network layer and not from aggregate models. This will allow aggregate models to take advantage of caching through the network layer, instead of implementing it on their own. By accessing caching layer from inside the network layer, all your aggregate models can benefit from faster response through the use of cached resources.</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>As mentioned earlier for small or even medium sized apps, you may only need a single aggregate model. For larger apps you can introduce new aggregate models. Make sure to consult with a domain expert before creating application boundaries.</p></blockquote>\n<p>The concept of domain boundaries can also be applied to user interfaces. This allows us to reuse user interface elements in other applications.</p>\n<p><img src=\"https://azamsharp.com/images/user-interface.png\" alt=\"Factor out common pieces\"></p>\n<ul>\n<li>Permission has been granted from the original author of the image to use it in this article.</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>You can factor out common interface elements using Swift Package Manager and import those packages into other applications.</p></blockquote>\n<p>Let’s go ahead and zoom out and see how our architecture looks like with all the pieces in place.</p>\n<p><img src=\"https://azamsharp.com/images/architecture-model-updated.jpeg\" alt=\"Architecture\"></p>\n<ul>\n<li>This image has been updated and the permission has been granted from the original author of the image to use it in this article.</li>\n</ul>\n<p>As discussed earlier, each bounded context is represented by its own module. These modules can be represented by a folder or a package dependency.</p>\n<p><strong>CatalogUI:</strong> Represents user interface associated with catalog. This can include all the catalog specific stuff like AddCatalogScreen, UpdateCatalogScreen etc.</p>\n<p><strong>Catalog:</strong> Represents the models associated with catalog. This will contain the aggregate model and all the entities exposed by the aggregate model.</p>\n<p><strong>MyStoreKit</strong>: Represents the HTTP client for performing network calls.</p>\n<p><strong>Foundation Core</strong>: Represents resources used by all modules. This can include helper classes&#x2F;structs, reusable views, images, icons and even preview content used for testing.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Each module like Shipping, Inventory, Ordering etc can be represented by a folder structure or a package dependency. This really depends on your needs and if you wish to reuse your modules in other projects.</p></blockquote>\n<p>Using this architecture, future business requirements and data access services can be added without interfering with existing ones. This also allows more collaborative environment as different teams can work on different modules without interfering with each other.</p>\n<h2 id=\"View-Specific-Logic\"><a href=\"#View-Specific-Logic\" class=\"headerlink\" title=\"View Specific Logic\"></a>View Specific Logic</h2><p>In this last section, I talked about how aggregate models can serve as a single source of truth and provide required data to the views. But what about view specific logic? Where should that logic be placed and what options do we have to perform testing on that logic.</p>\n<p>In the code below, we want to filter the products based on the minimum and maximum price. The implementation is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ContentView: View &#123;\n    \n    let httpClient: HTTPClientProtocol\n    @State private var products: [Product] &#x3D; []\n    @State private var min: Double?\n    @State private var max: Double?\n    @State private var filteredProducts: [Product] &#x3D; []\n    \n    private func filterProducts() &#123;\n        \n        guard let min &#x3D; min,\n              let max &#x3D; max else &#123; return &#125;\n        \n        filteredProducts &#x3D; products.filter &#123;\n            $0.price &gt;&#x3D; min &amp;&amp; $0.price &lt;&#x3D; max\n        &#125;\n    &#125;\n    \n    private var isFormValid: Bool &#123;\n        \n        guard let min &#x3D; min,\n              let max &#x3D; max else &#123; return false &#125;\n        \n        return min &lt; max\n    &#125;\n    \n    var body: some View &#123;\n        VStack &#123;\n            HStack &#123;\n                TextField(&quot;Min&quot;, value: $min, format: .number)\n                    .textFieldStyle(.roundedBorder)\n                TextField(&quot;Max&quot;, value: $max, format: .number)\n                    .textFieldStyle(.roundedBorder)\n            &#125;\n            Text(&quot;Max must be larger than min.&quot;)\n                .frame(maxWidth: .infinity, alignment: .leading)\n                .font(.caption)\n                .padding([.bottom], 20)\n            \n            Button(&quot;Apply&quot;) &#123;\n                filterProducts()\n            &#125;\n            \n            .disabled(!isFormValid)\n          \n            List(filteredProducts.isEmpty ? products: filteredProducts) &#123; product in\n                HStack &#123;\n                    Text(product.title)\n                    Spacer()\n                    Text(product.price, format: .currency(code: &quot;USD&quot;))\n                &#125;\n            &#125;\n            .task &#123;\n                do &#123;\n                    products &#x3D; try await httpClient.loadProducts()\n                &#125; catch &#123;\n                    print(error)\n                &#125;\n        &#125;\n        &#125;.padding()\n    &#125;\n&#125;\n\nstruct ContentView_Previews: PreviewProvider &#123;\n    static var previews: some View &#123;\n        ContentView(httpClient: HTTPClientStub())\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>If filterProducts or similar functions will be involved in any model logic then you can also put it inside the aggregate root model, instead of the view.</p></blockquote>\n<p>Please note that instead of invoking the real service, we are using a stubbed version of the HTTPClient that returns pre-configured response. Another good option would be to create separate JSON files for each response and read data from those files, when using Xcode previews. I covered that in one of my YouTube video, <a href=\"https://youtu.be/EycwLxTU-EA\">Building SwiftUI Xcode Previews Using JSON File</a>.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Keep in mind that in the above scenario, if no results are found during filtering then the original products array is returned.</p></blockquote>\n<p>We have two pieces of code in the view that constitute as logic, <code>isFormValid</code> and <code>filterProducts</code>. If we want to test that code we have number of ways.</p>\n<p>Use Xcode previews! I know this does not sound fancy but I encourage you to use Xcode previews to test your view based logic. Xcode previews is extremely fast (depending on the machine you are using) and it gives you the same feeling as Red&#x2F;Green&#x2F;Refactor cycle. For this particular scenario, Xcode previews will be my first choice.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Xcode previews is not the answer to everything. If you are dealing with complicated view logic then it will be a good idea to move out all the logic into a separate struct and then write unit tests for that piece of code. Remember, one of the important aspects of why we test is to <a href=\"https://azamsharp.com/2023/02/15/testing-is-about-confidence.html\">gain confidence about our code</a>.</p></blockquote>\n<p>Another option is to extract the logic from the view and then write unit tests against it. This is shown in the implementation below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ProductFilterForm &#123;\n    \n    var min: Double?\n    var max: Double?\n    \n    func filterProducts(_ products: [Product]) -&gt; [Product] &#123;\n        \n        guard let min &#x3D; min,\n              let max &#x3D; max else &#123; return [] &#125;\n        \n        return products.filter &#123;\n            $0.price &gt;&#x3D; min &amp;&amp; $0.price &lt;&#x3D; max\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><code>ProductFilterForm</code> can now be unit tested in isolation. The unit test is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nfunc test_user_can_filter_products_by_price() throws &#123;\n        \n        self.continueAfterFailure &#x3D; false\n      \n        let products &#x3D; [\n            Product(id: 1, title: &quot;Product 1&quot;, price: 10),\n            Product(id: 2, title: &quot;Product 2&quot;, price: 100),\n            Product(id: 3, title: &quot;Product 3&quot;, price: 200),\n            Product(id: 4, title: &quot;Product 4&quot;, price: 500)\n        ]\n        \n        let expectedFilteredProducts &#x3D; [\n            Product(id: 2, title: &quot;Product 2&quot;, price: 100),\n            Product(id: 3, title: &quot;Product 3&quot;, price: 200),\n            Product(id: 4, title: &quot;Product 4&quot;, price: 500)\n        ]\n        \n        let productFilterForm &#x3D; ProductFilterForm(min: 100, max: 500)\n        let filteredProducts &#x3D; productFilterForm.filterProducts(products)\n        \n        for expectedProduct in expectedFilteredProducts &#123;\n            \n            let product &#x3D; filteredProducts.first &#123; $0.id &#x3D;&#x3D; expectedProduct.id &#125;\n            \n            XCTAssertNotNil(product)\n            XCTAssertEqual(product!.title, expectedProduct.title)\n            XCTAssertEqual(product!.price, expectedProduct.price)\n        &#125;\n        \n    &#125;\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Unit testing view’s logic in isolation as shown above can be beneficial for complicated user interfaces. Keep in mind that just because your unit test passes, does not mean that your user interface is working as expected.</p></blockquote>\n<p>And the final kind of test you can write is an end-to-end test. E2E tests are great because they test the app from user’s point of view and they are best against regression. The downside is that E2E tests are slower then running unit tests. The main reason they are slower is because they are testing the complete application instead of small units. Most of the issues in software exists because the application was tested at unit level and not at system level. I encourage you to spend some time writing meaningful E2E tests.</p>\n<p>Here is an implementation of an E2E test for the above scenario.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func test_user_can_filter_products_based_on_price() &#123;\n      \n      let app &#x3D; XCUIApplication()\n      app.launchEnvironment &#x3D; [&quot;ENV&quot;: &quot;TEST&quot;]\n      app.launch()\n      \n      app.textFields[&quot;minTextField&quot;].tap()\n      app.textFields[&quot;minTextField&quot;].typeText(&quot;100&quot;)\n      \n      app.textFields[&quot;maxTextField&quot;].tap()\n      app.textFields[&quot;maxTextField&quot;].typeText(&quot;500&quot;)\n      \n      app.buttons[&quot;applyButton&quot;].tap()\n      \n      &#x2F;&#x2F; assert that the count is correct\n      XCTAssertEqual(3, app.collectionViews[&quot;productList&quot;].cells.count)\n      &#x2F;&#x2F; assert that the items are correct\n      XCTAssertEqual(&quot;Product 2&quot;, app.collectionViews[&quot;productList&quot;].staticTexts[&quot;Product 2&quot;].label)\n      XCTAssertEqual(&quot;Product 3&quot;, app.collectionViews[&quot;productList&quot;].staticTexts[&quot;Product 3&quot;].label)\n      XCTAssertEqual(&quot;Product 4&quot;, app.collectionViews[&quot;productList&quot;].staticTexts[&quot;Product 4&quot;].label)\n  &#125;</code></pre>\n\n<p>In the end you will have to decide where in <a href=\"https://martinfowler.com/articles/practical-test-pyramid.html\">testing pyramid</a> you want to invest your time to get the best return on your investment.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>If you want to learn more about testing then you can check out my course <a href=\"https://www.udemy.com/course/test-driven-development-in-ios-using-swift/?referralCode=07649C41E6E184CE86B3\">Test Driven Development in iOS Using Swift</a>.</p></blockquote>\n<h2 id=\"Screens-vs-Views\"><a href=\"#Screens-vs-Views\" class=\"headerlink\" title=\"Screens vs Views\"></a>Screens vs Views</h2><p>When I was working with Flutter, I observed a common pattern for organizing the widgets. Flutter developers were separating the widgets based on whether the widgets represents an entire screen of just a reusable control. Since React, Flutter and SwiftUI are extremely similar in nature we can apply the same principles when building SwiftUI applications.</p>\n<p>For example when displaying details of a movie, instead of calling that view MovieDetailView, you can call it MovieDetailScreen. This will make it clear that the detail view is an actual screen and not some reusable child view. Here are few more examples.</p>\n<p><strong>Screens</strong></p>\n<ul>\n<li>MovieDetailScreen</li>\n<li>HomeScreen</li>\n<li>LoginScreen</li>\n<li>RegisterScreen</li>\n<li>SettingsScreen</li>\n</ul>\n<p><strong>Views</strong></p>\n<ul>\n<li>RatingsView</li>\n<li>MessageView</li>\n<li>ReminderListView</li>\n<li>ReminderCellView</li>\n</ul>\n<p>I find that it is always a good idea to keep a close eye on our friendly neighbors React and Flutter. You never know what ideas you will bring from other declarative frameworks into SwiftUI.</p>\n<h2 id=\"Validation\"><a href=\"#Validation\" class=\"headerlink\" title=\"Validation\"></a>Validation</h2><p>There is a famous saying in software development, garbage in, garbage out. This means if you allow users to enter incorrect information (garbage) through the user interface then that garbage will eventually end up in your database. And usually when this happens, it becomes extremely difficult and time consuming to clean the database.</p>\n<p>You must take necessary steps to prevent users from submitting incorrect information in the first place.</p>\n<p>Consider a simple <code>LoginScreen</code> view with username and password TextFields. If we want to enable the login Button only when the view is validated correctly, we can use the implementation below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct LoginScreen: View &#123;\n    \n    @State private var username: String &#x3D; &quot;&quot;\n    @State private var password: String &#x3D; &quot;&quot;\n    \n    private var isFormValid: Bool &#123;\n        !username.isEmptyOrWhiteSpace &amp;&amp; !password.isEmptyOrWhiteSpace\n    &#125;\n    \n    var body: some View &#123;\n        Form &#123;\n            TextField(&quot;Username&quot;, text: $username)\n            TextField(&quot;Password&quot;, text: $password)\n            Button(&quot;Login&quot;) &#123;\n                \n            &#125;.disabled(!isFormValid)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>For such trivial logic, you can use Xcode Previews to quickly perform manual testing and validate the outcome.</p>\n<p>If you are working on a more complicated form, then it is advised to extract it into its own struct. This concept is shown in the implementation below.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct LoginFormConfig &#123;\n    \n    var username: String &#x3D; &quot;&quot;\n    var password: String &#x3D; &quot;&quot;\n    \n    var isFormValid: Bool &#123;\n        !username.isEmptyOrWhiteSpace &amp;&amp; !password.isEmptyOrWhiteSpace\n    &#125;\n&#125;\n\nstruct LoginScreen: View &#123;\n    \n    @State private var loginFormConfig: LoginFormConfig &#x3D; LoginFormConfig()\n    \n    var body: some View &#123;\n        Form &#123;\n            TextField(&quot;Username&quot;, text: $loginFormConfig.username)\n            TextField(&quot;Password&quot;, text: $loginFormConfig.password)\n            Button(&quot;Login&quot;) &#123;\n                \n            &#125;.disabled(!loginFormConfig.isFormValid)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><code>LoginFormConfig</code> encapsulates the form validation. This also allows us to write unit tests against the LoginFormConfig. Few unit tests are shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final class LearnTests: XCTestCase &#123;\n\n    func test_login_form_validates_successfully() &#123;\n        \n        let expectedOutputs: [[String: Any]] &#x3D; [\n            [&quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot;password&quot;, &quot;isFormValid&quot;: true],\n            [&quot;username&quot;: &quot;&quot;, &quot;password&quot;: &quot;password&quot;, &quot;isFormValid&quot;: false],\n            [&quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot; &quot;, &quot;isFormValid&quot;: false],\n            [&quot;username&quot;: &quot;&quot;, &quot;password&quot;: &quot; &quot;, &quot;isFormValid&quot;: false],\n            [&quot;username&quot;: &quot;   &quot;, &quot;password&quot;: &quot;password&quot;, &quot;isFormValid&quot;: false],\n            [&quot;username&quot;: &quot; johndoe&quot;, &quot;password&quot;: &quot; password&quot;, &quot;isFormValid&quot;: true]\n        ]\n        \n        for expectedOutput in expectedOutputs &#123;\n            let username &#x3D; expectedOutput[&quot;username&quot;] as! String\n            let password &#x3D; expectedOutput[&quot;password&quot;] as! String\n            let isFormValid &#x3D; expectedOutput[&quot;isFormValid&quot;] as! Bool\n            \n            let loginFormConfig &#x3D; LoginFormConfig(username: username, password: password)\n            XCTAssertEqual(loginFormConfig.isFormValid, isFormValid)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>In the end extracting the form validation into a separate struct and writing unit tests for it depends on your level of confidence. Simple forms can be tested easily through Xcode Previews and do not require additional structure or even unit tests.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Validation helper functions like isEmptyOrWhiteSpace, isNumeric, isEmail, isLessThan can be moved into a separate Swift package. This will promote reusability and other projects can also benefit from using it.</p></blockquote>\n<p>I covered few different ways of handling and displaying validation errors in one of my previous articles that you can read <a href=\"https://azamsharp.com/2022/08/09/intro-to-mv-state-pattern.html\">here</a>.</p>\n<h2 id=\"Displaying-Errors\"><a href=\"#Displaying-Errors\" class=\"headerlink\" title=\"Displaying Errors\"></a>Displaying Errors</h2><p>Displaying errors is an integral part of any application.</p>\n<p>In SwiftUI, we can centralize displaying errors to a single place. This will prevent us from writing repetitive code and also provide a single point in codebase to change the layout and appearance.</p>\n<p>We can start by creating an ErrorWrapper, which will be responsible for wrapping the actual error and also providing guidance to the user on the next steps.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ErrorWrapper: Identifiable &#123;\n    let id &#x3D; UUID()\n    let error: Error\n    let guidance: String\n&#125;</code></pre>\n\n<p>ErrorWrapper will be used by ErrorView. ErrorView will be responsible for displaying the details of the error in a visual format. You can find basic implementation of an ErrorView below.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ErrorView: View &#123;\n    \n    let errorWrapper: ErrorWrapper\n    \n    var body: some View &#123;\n        VStack &#123;\n            Text(&quot;Error has occured in the application.&quot;)\n                .font(.headline)\n                .padding([.bottom], 10)\n            Text(errorWrapper.error.localizedDescription)\n            Text(errorWrapper.guidance)\n                .font(.caption)\n        &#125;.padding()\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ErrorView is simply a view and you can customize it as much as you want.</p></blockquote>\n<p>In order to set the error wrapper from any part of our application, we will add an ErrorState as an ObservableObject and inject it in an EnvironmentObject.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class ErrorState: ObservableObject &#123;\n    @Published var errorWrapper: ErrorWrapper?\n&#125;\n\n@main\nstruct StoreApp: App &#123;\n    \n    @StateObject private var errorState &#x3D; ErrorState()\n    \n    var body: some Scene &#123;\n        WindowGroup &#123;\n            ContentView()\n                .environmentObject(errorState)\n                .sheet(item: $errorState.errorWrapper) &#123; errorWrapper in\n                    ErrorView(errorWrapper: errorWrapper)\n                &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<p>Whenever the errorState changes, a sheet will be displayed with the latest error. Once again, you are free to use a different method of displaying the error instead of a sheet.</p>\n<p>This technique allows you to have a single point in your codebase, which is responsible for displaying errors.</p>\n<h2 id=\"Grouping-View-Events\"><a href=\"#Grouping-View-Events\" class=\"headerlink\" title=\"Grouping View Events\"></a>Grouping View Events</h2><p>One way to create reusable views in SwiftUI is to delegate the events to the parent view. This allows views to be used in different scenarios and without tying them to a particular logic. One way to accomplish this is to use closures.</p>\n<p>Consider a <code>ReminderCellView</code>, which allows the user to perform check&#x2F;uncheck and delete operations. The implementation is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ReminderCellView: View &#123;\n    \n    let index: Int\n    let onChecked: (Int) -&gt; Void\n    let onDelete: (Int) -&gt; Void\n\n    var body: some View &#123;\n        HStack &#123;\n            Image(systemName: &quot;square&quot;)\n                .onTapGesture &#123;\n                    onChecked(index)\n                &#125;\n            Text(&quot;ReminderCellView \\(index)&quot;)\n            Spacer()\n            Image(systemName: &quot;trash&quot;)\n                .onTapGesture &#123;\n                    onDelete(index)\n                &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><code>ReminderCellView</code> exposes <code>onChecked</code> and <code>onDelete</code> closures. The caller can use these closures to perform a particular task. The calling side is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ContentView: View &#123;\n\n    var body: some View &#123;\n        List(1...20, id: \\.self) &#123; index in\n            ReminderCellView(index: index, onChecked: &#123; index in\n                &#x2F;&#x2F; do something\n            &#125;, onDelete: &#123; index in\n                &#x2F;&#x2F; do something\n            &#125;)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>As the complexity of <code>ReminderCellView</code> increases and it exposes more events then the calling side will become more complicated.</p>\n<p>We can fix this issue by grouping all the events into a simple enum. This is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">enum ReminderCellEvents &#123;\n    case onChecked(Int)\n    case onDelete(Int)\n&#125;</code></pre>\n\n<p>The <code>ReminderCellView</code> can be updated to use <code>ReminderCellEvents</code>. This is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ReminderCellView: View &#123;\n    \n    let index: Int\n    let onEvent: (ReminderCellEvents) -&gt; Void\n    \n    var body: some View &#123;\n        HStack &#123;\n            Image(systemName: &quot;square&quot;)\n                .onTapGesture &#123;\n                    onEvent(.onChecked(index))\n                &#125;\n            Text(&quot;ReminderCellView \\(index)&quot;)\n            Spacer()\n            Image(systemName: &quot;trash&quot;)\n                .onTapGesture &#123;\n                    onEvent(.onDelete(index))\n                &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Now, instead of dealing with multiple closures we are only handling a single enum based event structure. The calling site also looks much cleaner.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ContentView: View &#123;\n\n    var body: some View &#123;\n        List(1...20, id: \\.self) &#123; index in\n            ReminderCellView(index: index) &#123; event in\n                switch event &#123;\n                    case .onChecked(let index):\n                        print(index)\n                    case .onDelete(let index):\n                        print(index)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>In the end you will have to decide when you want to group events into an enum and when you want to use them individually (multiple closures). I tend to prefer using enum events if I have more than two closures exposed by the view.</p>\n<h2 id=\"Navigation\"><a href=\"#Navigation\" class=\"headerlink\" title=\"Navigation\"></a>Navigation</h2><p>SwiftUI introduced NavigationStack in iOS 16, which allowed developers to configure global routes for their application.</p>\n<p>There are several different ways to handle routing in SwiftUI. One possible approach is to handle all the routes in the root view of the application. We will start by creating the Routes enum, which will setup the routes for entire application. The implementation is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nenum Routes: Hashable &#123;\n    case catalog(CatalogRoutes)\n    case inventory(InventoryRoutes)\n    \n    enum CatalogRoutes: Hashable &#123;\n        case home\n        case detail(Category)\n                \n    &#125;\n    \n    enum InventoryRoutes: Hashable &#123;\n        case home\n        case detail(Product)\n    &#125;\n&#125;</code></pre>\n\n<p>The <code>Routes</code> enum represents the root routes for each section of the screen. This includes <code>catalog</code>, <code>inventory</code>, <code>shipping</code> etc. The routes for each section are declared inside their corresponding route enums (<code>CatalogRoutes</code>, <code>InventoryRoutes</code>).</p>\n<p>For programmatic navigation, we added <code>NavigationState</code>. NavigationState keep tracks of all the routes and will be injected into the app through the <code>@EnvironmentObject</code>.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class NavigationState: ObservableObject &#123;\n    @Published var routes: [Routes] &#x3D; []\n&#125;</code></pre>\n\n<p>Finally, we handle all the routes in our root view of the application. This is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@main\nstruct LearnApp: App &#123;\n    \n    @StateObject private var navigationState &#x3D; NavigationState()\n    \n    var body: some Scene &#123;\n        WindowGroup &#123;\n            NavigationStack(path: $navigationState.routes) &#123;\n                ContentView()\n                    .navigationDestination(for: Routes.self) &#123; route in\n                        switch route &#123;\n                            case .catalog(let catalogRoutes):\n                                switch catalogRoutes &#123;\n                                    case .home:\n                                        Text(&quot;Home View&quot;)\n                                    case .detail(let category):\n                                        &#x2F;&#x2F; show category detail view\n                                        Text(category.name)\n                                &#125;\n                            case .inventory(let inventoryRoutes):\n                                switch inventoryRoutes &#123;\n                                    case .home:\n                                        &#x2F;&#x2F; show home view\n                                        Text(&quot;Home View&quot;)\n                                    case .detail(let product):\n                                        &#x2F;&#x2F; show product details View\n                                        Text(product.name)\n                                &#125;\n                        &#125;\n                    &#125;\n            &#125;.environmentObject(navigationState)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>The above approach works but, it can quickly get messy because we are putting all the routes of our application in a single place. One way to control this problem is to create separate routers for each section of the screen and allow routers to handle specific routing behavior. The implementation of <code>CatalogRouter</code> is shown below. CatalogRouter is responsible for handling all the routes related to the catalog screens.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct CatalogRouter &#123;\n    \n    let routes: CatalogRoutes\n\n    @ViewBuilder\n    func configure() -&gt; some View &#123;\n        switch routes &#123;\n            case .detail(let category):\n                return Text(category.name)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Similarly, we can add router for Inventory.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct InventoryRouter &#123;\n    let routes: InventoryRoutes\n    \n    &#x2F;&#x2F; view builder\n    @ViewBuilder\n    func configure() -&gt; some View &#123;\n        switch routes &#123;\n            case .detail(let product):\n                Text(product.name)\n            case .home:\n                Text(&quot;Home&quot;)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Now, our navigationDestination looks much cleaner.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@main\nstruct LearnApp: App &#123;\n    \n    @StateObject private var navigationState &#x3D; NavigationState()\n    \n    var body: some Scene &#123;\n        WindowGroup &#123;\n            NavigationStack(path: $navigationState.routes) &#123;\n                ContentView()\n                    .navigationDestination(for: Routes.self) &#123; route in\n                        switch route &#123;\n                            case .catalog(let routes):\n                                CatalogRouter(routes: routes).configure()\n                            case .inventory(let routes):\n                                InventoryRouter(routes: routes).configure()\n                        &#125;\n                    &#125;\n            &#125;.environmentObject(navigationState)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>If you need to call a certain route, you can append the route in <code>NavigationState</code>. This is shown in the implementation below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ContentView: View &#123;\n    \n    @EnvironmentObject private var navigationState: NavigationState\n    \n    var body: some View &#123;\n       \n        VStack &#123;\n            \n            Button(&quot;Go to Catalog&quot;) &#123;\n                navigationState.routes.append(.catalog(.detail(Category(name: &quot;Category 1&quot;))))\n            &#125;\n            \n            Button(&quot;Go to Inventory&quot;) &#123;\n                navigationState.routes.append(.inventory(.detail(Product(name: &quot;Product 1&quot;))))\n            &#125;\n           \n        &#125; .padding()\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I am sure there are other ways of handling navigation in SwiftUI. Send me a <a href=\"https://gist.github.com/\">Gist</a> of your suggestion on <a href=\"https://twitter.com/azamsharp\">Twitter</a> and I will be more than happy to review it.</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I also wrote a book on Navigation API in SwiftUI. If you are interested, you can download it free of charge from <a href=\"https://azamsharp.com/books\">here</a>.</p></blockquote>\n<h2 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>This section of the article is taken from my post <a href=\"https://azamsharp.com/2012/12/23/pragmatic-unit-testing.html\">Pragmatic Testing and Avoiding Common Pitfalls</a></p></blockquote>\n<p>The main purpose of writing tests is to make sure that the software works as expected. Tests also gives you confidence that a change you make in one module is not going to break stuff in the same or other modules.</p>\n<p>Not all applications requires writing tests. If you are building a basic application with a straight forward domain then you can test the complete app using manual testing. Having said that in most professional environments, you are working with a complicated domain with business rules. These business rules form the basis on which company operates and generates revenue.</p>\n<p>In this article, I will discuss different techniques of writing tests and how a developer can write good tests to get the most return on their investment.</p>\n<h2 id=\"Not-all-tests-are-created-equal\"><a href=\"#Not-all-tests-are-created-equal\" class=\"headerlink\" title=\"Not all tests are created equal\"></a>Not all tests are created equal</h2><p>Consider a scenario that you are writing an application for a bank. One of the business rules is to charge overdraft fees in case of insufficient funds. Banks generate <a href=\"https://www.depositaccounts.com/blog/banks-income-fees.html\">billions of dollars income by just fees</a> alone. As a developer, you must write good quality tests to make sure that overdraft fee calculation works as expected.</p>\n<p>In the same bank app, you may have features like rendering templates for emails or logging certain interactions. These features are important but may not produce the same return on investment as compared to charging overdraft fees. This means if the email template is not in the correct format then the banks are not going to loose millions of dollars and you will not receive a call in the middle of the night. If the logging is meant for developers then in most cases you don’t even need to write tests for it. It is just an implementation detail.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>If you are building a logging framework then it is essential that you thoroughly test the public API exposed by your framework.</p></blockquote>\n</blockquote>\n<p>Next time you are writing a test, ask yourself how important this feature is for the business. If it is an integral part of the business then make sure to test it thoroughly and go for high code coverage.</p>\n<h2 id=\"Test-behavior-not-implementation\"><a href=\"#Test-behavior-not-implementation\" class=\"headerlink\" title=\"Test behavior not implementation\"></a>Test behavior not implementation</h2><p>One of the biggest mistakes developers make is to focus on writing tests against the implementation details instead of the behavior of the application.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>A trigger to add a new test is the requirement, not a class or a function.</p></blockquote>\n</blockquote>\n<p>Just because you added a new class or a function does not mean that you will start writing tests. That is just an implementation detail which can change overtime. Your tests should target the business requirements and not the implementation details.</p>\n<p>Here are few examples of behaviors, derived from business requirements:</p>\n<ol>\n<li>When a customer withdraw amount and has insufficient funds then charge an overdraft fee.</li>\n<li>The number of stocks specified by customer are submitted for trade at a specified price, once the limit has reached.</li>\n</ol>\n<p>The behavior stems from the requirement of the project. Tests that checks the implementation details instead of the behavior tends to be very brittle and can easily break when the implementation changes even though the behavior remains the same.</p>\n<p>Let’s consider a scenario, where you are building an application to display a list of products on the screen. The products are fetched from a JSON API and rendered using SwiftUI framework, following the principles of MVVM design pattern.</p>\n<p>First we will look at a common way of testing the above scenario that is adopted by most developers and then later we will implement tests in a more <strong>pragmatic</strong> way.</p>\n<p>The complete app might look like the implementation below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Webservice &#123;\n    \n    func fetchProducts() async throws -&gt; [Product] &#123;\n        &#x2F;&#x2F; ignore the hard-coded URL. We can inject the URL from using test configuration. \n        let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;test.store.com&#x2F;api&#x2F;v1&#x2F;products&quot;)!\n        let (data, _) &#x3D; try await URLSession.shared.data(from: url)\n        return try JSONDecoder().decode([Product].self, from: data)\n    &#125;\n    \n&#125;\n\nclass ProductListViewModel: ObservableObject &#123;\n    \n    @Published var products: [ProductViewModel] &#x3D; []\n    \n    func populateProducts() async &#123;\n        do &#123;\n            let products &#x3D; try await Webservice().fetchProducts()\n            self.products &#x3D; products.map(ProductViewModel.init)\n        &#125; catch &#123;\n            print(error)\n        &#125;\n    &#125;\n    \n&#125;\n\nstruct ProductViewModel: Identifiable &#123;\n    \n    private let product: Product\n    \n    init(product: Product) &#123;\n        self.product &#x3D; product\n    &#125;\n    \n    var id: Int &#123;\n        product.id\n    &#125;\n    \n    var title: String &#123;\n        product.title\n    &#125;\n&#125;\n\n\nstruct ProductListScreen: View &#123;\n    \n    @StateObject private var vm &#x3D; ProductListViewModel()\n    \n    var body: some View &#123;\n        List(vm.products) &#123; product in\n            Text(product.title)\n        &#125;.task &#123;\n            await vm.populateProducts()\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>The above application works as expected and produces the expected result. Instead of testing the concrete implementation of the <code>Webservice</code>, we will introduce an interface&#x2F;contract&#x2F;protocol just so that we can inject a mock. The sole purpose of creating the protocol is to satisfy the tests, even though there is only one concrete implementation that conforms to that protocol&#x2F;interface.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>This is called <a href=\"https://dhh.dk/2014/test-induced-design-damage.html\"><strong>Test Induced Damage</strong></a>. The tests are dictating that we should add dependencies so you can mock out the service. The only purpose of introducing a protocol&#x2F;contract&#x2F;interface is so you can eventually mock it. Keep in mind there is nothing wrong with using protocols&#x2F;contracts in your application. They do serve a very important purpose to hide the implementation details from the user and providing abstraction, but just to add contracts to satisfy testing goals in not a good practice as it complicates the implementation and your tests are directed away from testing the actual behavior of the app.</p></blockquote>\n</blockquote>\n<p>In the code below we have introduced a WebserviceProtocol. Both Webservice and the newly created MockedWebservice conforms to the WebserviceProtocol as shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">protocol WebserviceProtocol &#123;\n    func fetchProducts() async throws -&gt; [Product]\n&#125;\n\nclass Webservice: WebserviceProtocol &#123;\n    \n    func fetchProducts() async throws -&gt; [Product] &#123;\n        \n        let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;test.store.com&#x2F;api&#x2F;v1&#x2F;products&quot;)!\n        let (data, _) &#x3D; try await URLSession.shared.data(from: url)\n        return try JSONDecoder().decode([Product].self, from: data)\n    &#125;\n&#125;\n\nclass MockedWebService: WebserviceProtocol &#123;\n    func fetchProducts() async throws -&gt; [Product] &#123;\n        return [Product(id: 1, title: &quot;Product 1&quot;), Product(id: 2, title: &quot;Product 2&quot;)]\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>You should probably use a better name, instead of calling it WebserviceProtocol. The main reason, I am calling it WebserviceProtocol is just for the sake of simplicity and convenience.</p></blockquote>\n</blockquote>\n<p>The webservice is now injected as a dependency to our ProductListViewModel. This is shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class ProductListViewModel: ObservableObject &#123;\n    \n    private let webservice: WebserviceProtocol\n    @Published var products: [ProductViewModel] &#x3D; []\n    \n    init(webservice: WebserviceProtocol) &#123;\n        self.webservice &#x3D; webservice\n    &#125;\n    \n    func populateProducts() async &#123;\n        do &#123;\n            let products &#x3D; try await Webservice().fetchProducts()\n            self.products &#x3D; products.map(ProductViewModel.init)\n        &#125; catch &#123;\n            print(error)\n        &#125;\n    &#125;\n    \n&#125;</code></pre>\n\n<p>The view, ProductListScreen is also updated to reflect the change.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ProductListScreen: View &#123;\n    \n    @StateObject private var vm &#x3D; ProductListViewModel(webservice: WebserviceFactory.create())\n    \n    var body: some View &#123;\n        List(vm.products) &#123; product in\n            Text(product.title)\n        &#125;.task &#123;\n            await vm.populateProducts()\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>WebserviceFactory is responsible for either returning the Webservice or MockedWebservice, depending on the application environment.</p></blockquote>\n</blockquote>\n<p>Now, let’s go ahead and check out the test.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final class ProductsTests: XCTestCase &#123;\n    \n    func test_populate_products() async throws &#123;\n        \n        let mockedWebService &#x3D; MockedWebService()\n        let productListVM &#x3D; ProductListViewModel(webservice: mockedWebService)\n        \n        await productListVM.populateProducts()\n        \n        &#x2F;&#x2F; This line is verifying the implementation detail.\n        &#x2F;&#x2F; Implementation details can change\n        &#x2F;&#x2F; fetchProducts can change to getProducts and the test will fail. \n        verify(mockedWebService.fetchProducts()).wasCalled()\n        \n        XCTAssertEqual(2, productListVM.products.count)\n    &#125;\n&#125;</code></pre>\n\n<p>We created an instance of <code>MockedWebservice</code> inside our test and pass it to the <code>ProductListViewModel</code>. Next, we invoke the <code>populateProducts</code> function on the view model and then check to make sure that the <code>fetchProducts</code> on the mockedWebservice instance was called. Finally, the test checks the products property of the ````ProductListViewModel``` instance to make sure that is is populated correctly.</p>\n<p>The problem with the above test is that it is not testing the behavior but the implementation. The following line of code is an implementation detail.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">verify(mockedWebService.fetchProducts()).wasCalled()</code></pre>\n\n<p>This means if you decide to refactor your code and rename the function <code>fetchProducts</code> to <code>getProducts</code> then your test will fail. These kind of tests are often known as brittle tests as they break when the internal implementation changes even though the functionality&#x2F;behavior provided by the API remains the same. This is also the main reason that your test should validate the behavior instead of the implementation.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The code that you write is a liability, including tests. When writing tests, focus on the quality of the tests instead of the quantity. Remember, you are not only responsible for writing tests but also maintaining them.</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>If you are using MVVM pattern then your VM may have logic. It is perfectly fine to write unit tests against the logic contained in the view model.</p></blockquote>\n<h2 id=\"End-to-End-Testing\"><a href=\"#End-to-End-Testing\" class=\"headerlink\" title=\"End to End Testing\"></a>End to End Testing</h2><p>In the previous section, you learned that and mocking in most scenarios does not provide the return on your investment. Tests written that use mocking usually end up being too brittle and can fail because of refactoring, breaking all the dependent tests even though the behavior remained the same.</p>\n<p>Human psychology also plays an important role when writing tests. As software developers we want fast feedback with small amounts of dopamine hit along the way. There is nothing wrong with receiving fast feedback. Fast feedback is one of the important characteristics of a unit test. Unfortunately, sometimes we are going too fast to realize that we were on the wrong path. We start behaving like a test addict, who wants to see green checkmarks alongside the tests instantly.</p>\n<p>As explained earlier adding tests that test the implementation details instead of behavior does not provide any benefit to your project. It may even work against you in the long run since now you will be responsible for maintaining those test cases and anytime the implementation detail changes, all your test will break even though the functionality remained the same.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I am not proposing that you should not write unit tests. Unit tests are great when you are testing small units of code. I am proposing that you must make sure that you are testing the behavior of the code and not implementation details. This means if you want to write unit tests for your view models, you can.</p></blockquote>\n<p>Apart from unit tests and integration tests, end to end tests are best against regression. A good end to end will test one complete story&#x2F;behavior. Below you can find the implementation of an end to end test.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final class ProductTests: XCTestCase &#123;\n    \n    private var webservice: Webservice!\n    &#x2F;&#x2F; products\n    let products &#x3D; [Product(id: 1, title: &quot;Handmade Fresh Table&quot;),Product(id: 2, title: &quot;Durable Water Bottle&quot;)]\n    \n    override func setUp() &#123;\n        &#x2F;&#x2F; make sure the Webservice is using the TEST server endpoints and not PRODUCTION\n        webservice &#x3D; Webservice()\n        \n        &#x2F;&#x2F; add few products &#x2F;&#x2F; seeding the database\n        for product in products &#123;\n            await webservice.addProduct(product: product)\n        &#125;\n    &#125;\n    \n    func test_display_list_of_all_products() async &#123;\n        \n        let app &#x3D; XCUIApplication()\n        app.launch()\n        \n        let productList &#x3D; app.tables[&quot;productList&quot;]\n        \n        &#x2F;&#x2F; check if the item numbers is correct\n        XCTAssertEqual(productList.tables.cells.count, 2)\n        \n        &#x2F;&#x2F; check if the correct items are displayed\n        for(index, product) in products.enumerated() &#123;\n            let cell &#x3D; productList.cells.element(boundBy: index)\n            XCTAssertEqual(cell.staticTexts[&quot;productTitle&quot;].label, product.title)\n        &#125;\n        \n    &#125;\n    \n    override func tearDown() async throws &#123;\n        &#x2F;&#x2F; make sure to delete ALL records from the database so future test results are not influenced\n        await webservice.deleteProductById(productId: 1)\n        await webservice.deleteProductById(productId: 2)\n    &#125;\n    \n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>Developers can run E2E tests locally on their development machine. This will require initial setup such as testing framework, test environment, dependencies (database, services). E2E tests can be time-consuming, as a result developers may choose to run E2E tests less frequently than unit tests or other types of tests.</p></blockquote>\n</blockquote>\n<p>E2E tests are slower than the previous tests discussed earlier in the section but the main reason they are slower is because they tests all layers of the application. E2E tests are complete test and targets a particular behavior of the app.</p>\n<p>End to end tests also requires some initial setup that will allow your test to run database migrations, insert seed data, simulate user interface events and then rolling back changes after the tests are completed.</p>\n<p>End to end tests are NOT replacement of your domain model tests. You MUST write tests against your domain models, specially if your app is domain heavy and consists of lots of business rules.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>You will have to find the right balance as to how often to run end to end tests. If you run it with each code check-in then your continuous integration server will always be running 100% of the time. If you run it once every couple of days then you will be notified of failures much later than expected. Keep in mind that you can run E2E tests locally on your machine. Once you get the desired outcome, the CI server can run all the tests during the code check-in process.</p></blockquote>\n</blockquote>\n<h2 id=\"What-about-Integration-Testing\"><a href=\"#What-about-Integration-Testing\" class=\"headerlink\" title=\"What about Integration Testing\"></a>What about Integration Testing</h2><p>Integration tests are performed to make sure that two different systems can work together. These systems can be external dependencies like database or API but it can also be different modules within the same system.</p>\n<p>Dependencies can be classified as managed and unmanaged dependencies. A managed dependency includes database, file systems etc. For managed dependencies, it is important that you use real instance and not a mock. Unmanaged dependencies include SMTP server, payment gateway etc. For unmanaged dependencies use mocks to verify their behavior.</p>\n<p>Let’s check out a sample integration test for a network service for user login operation.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; This test is generated by ChatGPT AI \nimport XCTest\n\nclass IntegrationTests: XCTestCase &#123;\n    func testLogin() &#123;\n        &#x2F;&#x2F; Set up the URL for the login endpoint\n        let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;api.example.com&#x2F;login&quot;)!\n\n        &#x2F;&#x2F; Create a URL request\n        var request &#x3D; URLRequest(url: url)\n        request.httpMethod &#x3D; &quot;POST&quot;\n        request.addValue(&quot;application&#x2F;json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)\n\n        &#x2F;&#x2F; Set the body of the request to a JSON object with the login credentials\n        let body &#x3D; [&quot;username&quot;: &quot;user123&quot;, &quot;password&quot;: &quot;password&quot;]\n        request.httpBody &#x3D; try! JSONSerialization.data(withJSONObject: body)\n\n        &#x2F;&#x2F; Create a URLSession and send the request\n        let session &#x3D; URLSession.shared\n        let task &#x3D; session.dataTask(with: request) &#123; data, response, error in\n            &#x2F;&#x2F; Make sure there is no error\n            XCTAssertNil(error)\n\n            &#x2F;&#x2F; Check the response status code\n            let httpResponse &#x3D; response as! HTTPURLResponse\n            XCTAssertEqual(httpResponse.statusCode, 200)\n\n            &#x2F;&#x2F; Check the response data\n            XCTAssertNotNil(data)\n            let responseBody &#x3D; try! JSONSerialization.jsonObject(with: data!, options: []) as! [String: Any]\n            XCTAssertEqual(responseBody[&quot;status&quot;], &quot;success&quot;)\n        &#125;\n        task.resume()\n    &#125;\n&#125;\n</code></pre>\n\n<p>The above integration test makes sure that the HTTP client layer is working as expected. The integration is between the network client and the server. The client is making sure that the response is correct and valid for a successful login operation.</p>\n<p>Unmanaged dependencies like payment gateway, SMTP clients etc can be mocked out during integration tests. For managed dependencies, use the concrete implementations.</p>\n<h2 id=\"Code-Coverage\"><a href=\"#Code-Coverage\" class=\"headerlink\" title=\"Code Coverage\"></a>Code Coverage</h2><p>Code coverage is a metric that calculates how much of your code is covered under test. Let’s take a very simple example. In the code below we have a <code>BankAccount</code> class, which consists of <code>deposit</code> and <code>withdraw</code> functions.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>Keep in mind that in real world scenario, a bank account is not implemented as a calculator. A bank account is recorded in a ledger, where all financial transactions are persisted.</p></blockquote>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class BankAccount &#123;\n    \n    private(set) var balance: Double\n    \n    init(balance: Double) &#123;\n        self.balance &#x3D; balance\n    &#125;\n    \n    func deposit(_ amount: Double) &#123;\n        self.balance +&#x3D; amount\n    &#125;\n    \n    func withdraw(_ amount: Double) &#123;\n        self.balance -&#x3D; amount\n    &#125;\n    \n&#125;</code></pre>\n\n<p>One possible test for the BankAccount may check if the account is successfully deposited.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final class BankAccountTests: XCTestCase &#123;\n    \n    func test_deposit_amount() &#123;\n        \n        let bankAccount &#x3D; BankAccount(balance: 0)\n        bankAccount.deposit(100)\n        XCTAssertEqual(100, bankAccount.balance)\n        \n    &#125;\n&#125;</code></pre>\n\n<p>If this is the only test we have in our test suite then our code coverage is not 100%. This means not all paths&#x2F;functions are under test. This is true because we never implemented the test for <code>withraw</code> function.</p>\n<p>You may be wondering that should you always have 100% code coverage. The simple answer is NO. But it also depends on the apps that you are working on. If you are writing code for NASA, where it will be responsible for landing rover on Mars then you better make sure that every single line is tested and your code coverage is 100%.</p>\n<p>If you are implementing an app for a pace maker device that helps to regulate the heartbeat then you better make sure that your code coverage is 100%. One line of missed and untested code can result in someones life… literally.</p>\n<p>So, what is the ideal code coverage number. It really depends on the app but any number above 70% is considered a decent code coverage.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>When calculating code coverage make sure to ignore the third party libraries&#x2F;frameworks as their code coverage is not your responsibility.</p></blockquote>\n</blockquote>\n<h2 id=\"Unit-Testing-Data-Access-and-File-Access\"><a href=\"#Unit-Testing-Data-Access-and-File-Access\" class=\"headerlink\" title=\"Unit Testing, Data Access and File Access\"></a>Unit Testing, Data Access and File Access</h2><p>Most developers that I have talked to believe that a unit test cannot access a database or a file system. <strong>That is incorrect and plain wrong</strong>. A unit test CAN access a database or a file system.</p>\n<p>It is very important to understand that <code>Unit test is the isolation, not the thing under test</code>. This is so important that I am going to repeat it again.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>Unit test is the isolation, not the thing under test</p></blockquote>\n</blockquote>\n<p>One of the valid reasons of not accessing a database or a file system during unit tests is that a test may leave data behind which may cause other tests to behave in unexpected manner. The solution is to make sure that the database is always reverted to an initial state after each test is completed so that future tests gets a clean database without any side effects.</p>\n<p>Some frameworks also allows you to construct in-memory databases. Core Data for instance uses SQLite by default but it can be configured to use an in-memory database as shown below:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">storeDescription.type &#x3D; NSInMemoryStoreType</code></pre>\n\n<p>In-memory database provides several benefits including:</p>\n<ul>\n<li>No removal of test data</li>\n<li>Run faster</li>\n<li>Can be initialized before each test run</li>\n</ul>\n<p>Even thought these benefits looks appealing, I personally do not recommend using in-memory database for testing purposes. The main reason is that in-memory databases does not represent an actual production environment. This means you may not encounter the same issues during tests, which you may witness when using an actual database.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><blockquote>\n<p>It is always a good idea to to make sure that your test environment and production environment are nearly identical in nature.</p></blockquote>\n</blockquote>\n<h2 id=\"Testing-View-Model-Does-NOT-Validate-the-User-Interface\"><a href=\"#Testing-View-Model-Does-NOT-Validate-the-User-Interface\" class=\"headerlink\" title=\"Testing View Model Does NOT Validate the User Interface\"></a>Testing View Model Does NOT Validate the User Interface</h2><p>Couple of weeks ago, I was having a discussion with another developer, who was mentioning that they test their <strong>user interface</strong> through View Models in SwiftUI. I was not sure what he meant so I checked the source code and found that they had lot of unit tests for their View Models and they were just assuming that if the View Model tests are passing then the user interface will automatically work.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Please keep in mind that I am not suggesting that you should not write unit tests for your View Models. I am simply saying that your View Model unit tests does not validate that the user interface is working as expected.</p></blockquote>\n<p>Let’s take a very simple example of building a counter application.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class CounterViewModel: ObservableObject &#123;\n    \n    @Published var count: Int &#x3D; 0\n    \n    func increment() &#123;\n        count +&#x3D; 1\n    &#125;\n&#125;\n\nstruct ContentView: View &#123;\n    \n    @StateObject private var counterVM &#x3D; CounterViewModel()\n    \n    var body: some View &#123;\n        VStack &#123;\n            Text(&quot;\\(counterVM.count)&quot;)\n            Button(&quot;Increment&quot;) &#123;\n                counterVM.increment()\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>When the increment button is pressed, we call the increment function on the CounterViewModel instance and increment the count. Since count property is decorated with @Published property wrapper, it notifies the view to reevaluate and eventually rerender.</p>\n<p>In order to test that the count is incremented and displayed on the screen, the following unit test was written.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import XCTest\n@testable import Learn\n\nfinal class LearnTests: XCTestCase &#123;\n\n    func test_user_updated_count() &#123;\n        let vm &#x3D; CounterViewModel()\n        vm.increment()\n        XCTAssertEqual(1, vm.count)\n    &#125;\n\n&#125;</code></pre>\n\n<p>This is a perfectly <strong>valid</strong> unit test but it does not verify that the count has been updated and displayed on the screen. Let me repeat it again. <strong>A View Model unit test does not verify that the count is successfully displayed on the screen. This is a unit test not a UI test.</strong></p>\n<p>To prove that a View Model unit test does not verify user interface elements, simply remove the Button view or even the Text view from the ContentView. The unit test will still pass. This can give you false confidence that your interface is working.</p>\n<p>A better way to verify that a user interface is working as expected is to implement a UI test. Take a look at the following implementation.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final class LearnUITests: XCTestCase &#123;\n\n    func testExample() throws &#123;\n        &#x2F;&#x2F; UI tests must launch the application that they test.\n        let app &#x3D; XCUIApplication()\n        app.launch()\n\n        app.buttons[&quot;incrementButton&quot;].tap()\n        XCTAssertEqual(&quot;1&quot;, app.staticTexts[&quot;countLabel&quot;].label)\n    &#125;\n&#125;</code></pre>\n\n<p>This test will launch the app in a simulator and verify that when the button is pressed, label is updated correctly.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Depending on the complexity of the behavior you are testing, you may not even need to write a user interface test. I have found that most of the user interfaces can be tested quickly using Xcode Previews.</p></blockquote>\n<p>So what is the right balance? How many unit tests should you have for your View Model as compared to UI tests.</p>\n<p>The answer is <strong>it depends</strong>. If you have complicated logic in your View Model then unit test can help. UITest (E2E) tests provide the best defense against regression. For each story, you can write couple of long happy path user interface tests and couple of edge cases. Once again, this really depends on the story and the complexities associated with the story.</p>\n<p>In the end <a href=\"https://azamsharp.com/2023/02/15/testing-is-about-confidence.html\">testing is all about <strong>confidence</strong></a>. Sometimes you can gain confidence by writing fewer or no tests and other times you have to write more tests to achieve the level of confidence.</p>\n<h2 id=\"The-Ideal-test\"><a href=\"#The-Ideal-test\" class=\"headerlink\" title=\"The Ideal test\"></a>The Ideal test</h2><p>We talked about several different types of tests. You may be wondering what is the best kind of test to write. What is the ideal test?</p>\n<p>Unfortunately, there is no ideal test. It all depends on your project and requirements. If your project is domain heavy then you should have more domain level tests. If your project is UI heavy then your should have end to end tests. Finally, if your project integrates with managed and unmanaged dependencies then integration tests will be more suitable in those scenarios.</p>\n<p>Remember to test the public API exposed by the module and not the implementation details. This way you can write useful quality tests, which will also help you to catch errors.</p>\n<p>Don’t create protocols&#x2F;interfaces&#x2F;contracts with the sole purpose of mocking. If a protocol consists of a single concrete implementation then use the concrete implementation and remove the interface&#x2F;contract. Your architecture should be based on current business needs and not on what if scenarios that may never happen. Remember YAGNI (You aren’t going to need it). Less code is better than more code.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>Application architecture is a complicated subject and in the end the best architecture for a project depends on many factors. These factors can include the size and complexity of the project, the team’s skills and experience, the project’s goals and requirements.</p>\n<p>Ultimately, the key to a successful application architecture is to choose a pattern that fits the project’s unique needs, and to constantly evaluate and adjust the architecture as the project evolves.</p>\n<p>By investing time and resources into designing a thoughtful and effective application architecture, teams can ensure that their codebase is maintainable, scalable, and flexible enough to adapt to changing requirements and technology trends.</p>\n<h2 id=\"Origin-Link\"><a href=\"#Origin-Link\" class=\"headerlink\" title=\"Origin Link\"></a>Origin Link</h2><ul>\n<li><a href=\"http://azamsharp.com/\">AzamSharp</a></li>\n</ul>\n","feature":true,"text":"软件架构始终是一个热门争论的话题，特别是当有这么多不同的选择时。在过去的 8-12 个月里，作者一直在尝试使用 MV 模式来构建客户端&#x2F;服务器应用程序，并在我最初的文章中写到了这一点 SwiftUI 架构 - MV 模式方法的完整指南。在本文中，作者将讨论如何将 MV ...","link":"","photos":[],"count_time":{"symbolsCount":"73k","symbolsTime":"1:06"},"categories":[{"name":"Swift Learning","slug":"Swift-Learning","count":1,"path":"api/categories/Swift-Learning.json"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","count":1,"path":"api/tags/SwiftUI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Modular-Architecture\"><span class=\"toc-text\">Modular Architecture</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Understanding-the-MV-Pattern\"><span class=\"toc-text\">Understanding the MV Pattern</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Multiple-Aggregate-Models\"><span class=\"toc-text\">Multiple Aggregate Models</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#View-Specific-Logic\"><span class=\"toc-text\">View Specific Logic</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Screens-vs-Views\"><span class=\"toc-text\">Screens vs Views</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Validation\"><span class=\"toc-text\">Validation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Displaying-Errors\"><span class=\"toc-text\">Displaying Errors</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Grouping-View-Events\"><span class=\"toc-text\">Grouping View Events</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Navigation\"><span class=\"toc-text\">Navigation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Testing\"><span class=\"toc-text\">Testing</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Not-all-tests-are-created-equal\"><span class=\"toc-text\">Not all tests are created equal</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Test-behavior-not-implementation\"><span class=\"toc-text\">Test behavior not implementation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#End-to-End-Testing\"><span class=\"toc-text\">End to End Testing</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#What-about-Integration-Testing\"><span class=\"toc-text\">What about Integration Testing</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Code-Coverage\"><span class=\"toc-text\">Code Coverage</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Unit-Testing-Data-Access-and-File-Access\"><span class=\"toc-text\">Unit Testing, Data Access and File Access</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Testing-View-Model-Does-NOT-Validate-the-User-Interface\"><span class=\"toc-text\">Testing View Model Does NOT Validate the User Interface</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#The-Ideal-test\"><span class=\"toc-text\">The Ideal test</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Conclusion\"><span class=\"toc-text\">Conclusion</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Origin-Link\"><span class=\"toc-text\">Origin Link</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{},"next_post":{"title":"《大道至简---软件工程实践者的思想》  读书笔记","uid":"5ea20968d8e7130fecf289d5412e680c","slug":"2022-10-29-dadaozhijian","date":"2023-05-13T15:32:33.641Z","updated":"2023-05-13T15:32:33.641Z","comments":true,"path":"api/articles/2022-10-29-dadaozhijian.json","keywords":null,"cover":"https://raw.githubusercontent.com/zycslog/assets-pro/main/ryosuke-nasu--Pn_23L3OEs-unsplash.jpg","text":"内容提要本书提出了审视软件工程的全新视角和软件工程的 体系模型(EHM，软件工程层状模型)。本书用非工 程的方式重新解析软件工程现象，全面、细致而深 刻地分析了工程中各个环节的由来、价值及其内在 关系，综合论述开发、工程二者的现状。全书语言 轻快，可读性强，薄且有味。 本书作者周...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"技术人生","slug":"技术人生","count":9,"path":"api/categories/技术人生.json"}],"tags":[{"name":"读书笔记","slug":"读书笔记","count":1,"path":"api/tags/读书笔记.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"feature":true}}