{"title":"Runtime剖析04 --- 深入理解Category","uid":"c6997d59d32873c326b54f9cbde95646","slug":"2020-07-01-iOS-runtime-category","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-07-01-iOS-runtime-category.json","keywords":null,"cover":null,"content":"<p>在Objective-C中，可以通过<strong>Category</strong>添加属性、方法、协议，在Runtime中<strong>Class</strong>和<strong>Category</strong>都是通过结构体实现的。和<strong>Category</strong>相似的还有<strong>Extension</strong>，二者的区别在于，<strong>Extension</strong>在编译期就直接和原类编译在一起，而<strong>Category</strong>是在运行时动态添加到原类中的。</p>\n<h2 id=\"Category的数据结构\"><a href=\"#Category的数据结构\" class=\"headerlink\" title=\"Category的数据结构\"></a>Category的数据结构</h2><p>在Runtime中，Category的数据结构是基本的结构体，其定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct category_t *Category;\n\nstruct category_t &#123;\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n    &#x2F;&#x2F; Fields below this point are not always present on disk.\n    struct property_list_t *_classProperties;\n\n    method_list_t *methodsForMeta(bool isMeta) &#123;\n        if (isMeta) return classMethods;\n        else return instanceMethods;\n    &#125;\n\n    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);\n    \n    protocol_list_t *protocolsForMeta(bool isMeta) &#123;\n        if (isMeta) return nullptr;\n        else return protocols;\n    &#125;\n&#125;;</code></pre>\n\n<p><strong>Category</strong>的定义中，为每一种可添加的元素提供了属性，添加实例方法的<strong>instanceMethods</strong>、添加类方法的<strong>classMethods</strong>、添加协议的<strong>protocols</strong>、添加实例属性的<strong>instanceProperties</strong>，并且提供了添加方法、属性和协议的可行性判断方法。</p>\n<h2 id=\"Category的加载\"><a href=\"#Category的加载\" class=\"headerlink\" title=\"Category的加载\"></a>Category的加载</h2><p>首先，Category数据会被保存在Mach-O中的**__data<strong>段，当Objective-C被dyld加载的时候，Objective-C开始进入其入口函数</strong>_objc_init()**。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void _objc_init(void)\n&#123;\n    static bool initialized &#x3D; false;\n    if (initialized) return;\n    initialized &#x3D; true;\n    \n    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    static_init();\n    runtime_init();\n    exception_init();\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);\n\n#if __OBJC2__\n    didCallDyldNotifyRegister &#x3D; true;\n#endif\n&#125;</code></pre>\n\n<p>在入口函数**_objc_init()<strong>中，会进行各种初始化操作，例如runtime、exception、cache等等的初始化，其中</strong>_dyld_objc_notify_register()**注册函数会向dyld注册监听Mach-O中Objective-C相关的section被载入和载出内存的事件。该函数有三个回调事件：</p>\n<ol>\n<li>对应&amp;map_images回调**_dyld_objc_notify_mapped**：当dyld已经将images加载进内存时；</li>\n<li>对应load_images回调**_dyld_objc_notify_init**：当dyld初始化image后；</li>\n<li>对应unmap_image回调**_dyld_objc_notify_unmapped**：当dyld将image移除内存时。</li>\n</ol>\n<p>将Category写入到目标类的方法列表，发生在**_dyld_objc_notify_mapped<strong>，即Mach-O相关的sections都加载到内存之后发生。此时的回调函数为</strong>map_images<strong>，该函数中最终调用的是</strong>_read_images**：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (hCount &gt; 0) &#123;\n     _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);\n&#125;\n\n&#x2F;&#x2F; objc&#x2F;Source&#x2F;objc-os.mm</code></pre>\n\n<p>在**_read_images**中，又调取了</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (didInitialAttachCategories) &#123;\n    for (EACH_HEADER) &#123;\n        load_categories_nolock(hi);\n    &#125;\n&#125;\n &#x2F;&#x2F; objc&#x2F;Source&#x2F;objc-runtime-new.mm</code></pre>\n\n<p>最终，关于Category的读取转向了函数<strong>load_categories_nolock</strong>，在这个函数中，将对Category的属性、方法、协议等进行读取，最终通过<strong>unattachedCategories</strong>方法添加到目标类的方法列表中。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void load_categories_nolock(header_info *hi) &#123;\n    bool hasClassProperties &#x3D; hi-&gt;info()-&gt;hasCategoryClassProperties();\n\n    size_t count;\n    auto processCatlist &#x3D; [&amp;](category_t * const *catlist) &#123;\n        for (unsigned i &#x3D; 0; i &lt; count; i++) &#123;\n            category_t *cat &#x3D; catlist[i];\n            Class cls &#x3D; remapClass(cat-&gt;cls);\n            locstamped_category_t lc&#123;cat, hi&#125;;\n\n            if (!cls) &#123;\n                &#x2F;&#x2F; Category&#39;s target class is missing (probably weak-linked).\n                &#x2F;&#x2F; Ignore the category.\n                if (PrintConnecting) &#123;\n                    _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot;\n                                 &quot;missing weak-linked target class&quot;,\n                                 cat-&gt;name, cat);\n                &#125;\n                continue;\n            &#125;\n\n            &#x2F;&#x2F; Process this category.\n            if (cls-&gt;isStubClass()) &#123;\n                &#x2F;&#x2F; Stub classes are never realized. Stub classes\n                &#x2F;&#x2F; don&#39;t know their metaclass until they&#39;re\n                &#x2F;&#x2F; initialized, so we have to add categories with\n                &#x2F;&#x2F; class methods or properties to the stub itself.\n                &#x2F;&#x2F; methodizeClass() will find them and add them to\n                &#x2F;&#x2F; the metaclass as appropriate.\n                if (cat-&gt;instanceMethods ||\n                    cat-&gt;protocols ||\n                    cat-&gt;instanceProperties ||\n                    cat-&gt;classMethods ||\n                    cat-&gt;protocols ||\n                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))\n                &#123;\n                    objc::unattachedCategories.addForClass(lc, cls);\n                &#125;\n            &#125; else &#123;\n                &#x2F;&#x2F; First, register the category with its target class.\n                &#x2F;&#x2F; Then, rebuild the class&#39;s method lists (etc) if\n                &#x2F;&#x2F; the class is realized.\n                if (cat-&gt;instanceMethods ||  cat-&gt;protocols\n                    ||  cat-&gt;instanceProperties)\n                &#123;\n                    if (cls-&gt;isRealized()) &#123;\n                        attachCategories(cls, &amp;lc, 1, ATTACH_EXISTING);\n                    &#125; else &#123;\n                        objc::unattachedCategories.addForClass(lc, cls);\n                    &#125;\n                &#125;\n\n                if (cat-&gt;classMethods  ||  cat-&gt;protocols\n                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))\n                &#123;\n                    if (cls-&gt;ISA()-&gt;isRealized()) &#123;\n                        attachCategories(cls-&gt;ISA(), &amp;lc, 1, ATTACH_EXISTING | ATTACH_METACLASS);\n                    &#125; else &#123;\n                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;;\n\n    processCatlist(_getObjc2CategoryList(hi, &amp;count));\n    processCatlist(_getObjc2CategoryList2(hi, &amp;count));\n&#125;</code></pre>\n\n<ol>\n<li>首先调用**_getObjc2CategoryList<strong>读取</strong>__objc_catlist** section下所有记录的<strong>category</strong>，并存放在**category_t * const *catlist**数组中；</li>\n<li>遍历**category_t * const *catlist**数组；</li>\n<li>对每一个<em>*category_t *cat &#x3D; catlist[i];<strong>，先调用</strong>remapClass**获取</em>*Category**所属的类；</li>\n<li>找到Category对应的类对象<strong>cls</strong>后，开始对<strong>cls</strong>进行修改工作。首先，如果category中有实例方法、协议，以及实例属性的话，则直接对<strong>cls</strong>进行操作，如果category中包含了类方法、协议或属性之一的话，还需要对<strong>cls</strong>所对应的<strong>元类（cls-&gt;ISA()）</strong>进行操作；</li>\n<li>无论是对cls还是cls的元类进行操作，都调用方法<strong>attachCategories</strong>，修改class的方法列表结构。</li>\n</ol>\n<h2 id=\"attachCategories\"><a href=\"#attachCategories\" class=\"headerlink\" title=\"attachCategories\"></a>attachCategories</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static void\nattachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,\n                 int flags)\n&#123;\n    if (slowpath(PrintReplacedMethods)) &#123;\n        printReplacements(cls, cats_list, cats_count);\n    &#125;\n    if (slowpath(PrintConnecting)) &#123;\n        _objc_inform(&quot;CLASS: attaching %d categories to%s class &#39;%s&#39;%s&quot;,\n                     cats_count, (flags &amp; ATTACH_EXISTING) ? &quot; existing&quot; : &quot;&quot;,\n                     cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? &quot; (meta)&quot; : &quot;&quot;);\n    &#125;\n\n    &#x2F;*\n     * Only a few classes have more than 64 categories during launch.\n     * This uses a little stack, and avoids malloc.\n     *\n     * Categories must be added in the proper order, which is back\n     * to front. To do that with the chunking, we iterate cats_list\n     * from front to back, build up the local buffers backwards,\n     * and call attachLists on the chunks. attachLists prepends the\n     * lists, so the final result is in the expected order.\n     *&#x2F;\n    constexpr uint32_t ATTACH_BUFSIZ &#x3D; 64;\n    method_list_t   *mlists[ATTACH_BUFSIZ];\n    property_list_t *proplists[ATTACH_BUFSIZ];\n    protocol_list_t *protolists[ATTACH_BUFSIZ];\n\n    uint32_t mcount &#x3D; 0;\n    uint32_t propcount &#x3D; 0;\n    uint32_t protocount &#x3D; 0;\n    bool fromBundle &#x3D; NO;\n    bool isMeta &#x3D; (flags &amp; ATTACH_METACLASS);\n    auto rwe &#x3D; cls-&gt;data()-&gt;extAllocIfNeeded();\n\n    for (uint32_t i &#x3D; 0; i &lt; cats_count; i++) &#123;\n        auto&amp; entry &#x3D; cats_list[i];\n\n        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);\n        if (mlist) &#123;\n            if (mcount &#x3D;&#x3D; ATTACH_BUFSIZ) &#123;\n                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n                rwe-&gt;methods.attachLists(mlists, mcount);\n                mcount &#x3D; 0;\n            &#125;\n            mlists[ATTACH_BUFSIZ - ++mcount] &#x3D; mlist;\n            fromBundle |&#x3D; entry.hi-&gt;isBundle();\n        &#125;\n\n        property_list_t *proplist &#x3D;\n            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);\n        if (proplist) &#123;\n            if (propcount &#x3D;&#x3D; ATTACH_BUFSIZ) &#123;\n                rwe-&gt;properties.attachLists(proplists, propcount);\n                propcount &#x3D; 0;\n            &#125;\n            proplists[ATTACH_BUFSIZ - ++propcount] &#x3D; proplist;\n        &#125;\n\n        protocol_list_t *protolist &#x3D; entry.cat-&gt;protocolsForMeta(isMeta);\n        if (protolist) &#123;\n            if (protocount &#x3D;&#x3D; ATTACH_BUFSIZ) &#123;\n                rwe-&gt;protocols.attachLists(protolists, protocount);\n                protocount &#x3D; 0;\n            &#125;\n            protolists[ATTACH_BUFSIZ - ++protocount] &#x3D; protolist;\n        &#125;\n    &#125;\n\n    if (mcount &gt; 0) &#123;\n        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);\n        rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);\n        if (flags &amp; ATTACH_EXISTING) flushCaches(cls);\n    &#125;\n\n    rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);\n\n    rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);\n&#125;</code></pre>\n\n<p>在该方法中，会完成对category中方法、协议、属性的加载，最终添加到对应class的方法、协议以及属性列表中。最终会调用<strong>attachLists</strong>方法，进行原类和分类列表的合并。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;\n    if (addedCount &#x3D;&#x3D; 0) return;\n\n    if (hasArray()) &#123;\n        &#x2F;&#x2F; many lists -&gt; many lists\n        uint32_t oldCount &#x3D; array()-&gt;count;\n        uint32_t newCount &#x3D; oldCount + addedCount;\n        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n        array()-&gt;count &#x3D; newCount;\n        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, \n                oldCount * sizeof(array()-&gt;lists[0]));\n        memcpy(array()-&gt;lists, addedLists, \n               addedCount * sizeof(array()-&gt;lists[0]));\n    &#125;\n    else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;\n        &#x2F;&#x2F; 0 lists -&gt; 1 list\n        list &#x3D; addedLists[0];\n    &#125; \n    else &#123;\n        &#x2F;&#x2F; 1 list -&gt; many lists\n        List* oldList &#x3D; list;\n        uint32_t oldCount &#x3D; oldList ? 1 : 0;\n        uint32_t newCount &#x3D; oldCount + addedCount;\n        setArray((array_t *)malloc(array_t::byteSize(newCount)));\n        array()-&gt;count &#x3D; newCount;\n        if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;\n        memcpy(array()-&gt;lists, addedLists, \n               addedCount * sizeof(array()-&gt;lists[0]));\n    &#125;\n&#125;</code></pre>\n\n\n<p>在合并的时候，会采用<strong>头插法</strong>将新的列表插入到原始列表中，也就是新的列表会位于原始列表的头部位置。这也就解释了为什么category中的方法，会<code>覆盖</code>class的原始方法。严格说并不是覆盖，而是因为category中定义的方法会排列在方法列表的前面，在进行方法查找的时候，会优先被找到，从而调用，而原始方法位置相对靠后，导致没有查找到，因此没有被调动。</p>\n<h2 id=\"Category和-load方法\"><a href=\"#Category和-load方法\" class=\"headerlink\" title=\"Category和+load方法\"></a>Category和+load方法</h2><p><strong>+load</strong>方法在Objective-C中被调用的时机相对较早，因此Category中定义的方法需要在调用**+load**方法之前就被附加到类的方法列表中，否则可能导致调用无效的情况，实际上，Runtime中也是真么保证的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void _objc_init(void)\n&#123;\n    static bool initialized &#x3D; false;\n    if (initialized) return;\n    initialized &#x3D; true;\n    \n    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    static_init();\n    runtime_init();\n    exception_init();\n    cache_init();\n    _imp_implementationWithBlock_init();\n\n    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);\n    \n    didCallDyldNotifyRegister &#x3D; true;\n&#125;</code></pre>\n\n<p>在**_dyld_objc_notify_register<strong>中，runtime向dyld中注册了三个事件监听：</strong>map_images、load_images、unmap_image<strong>。在</strong>map_images<strong>事件中，runtime会读取Mach-O文件中的oc sections，并根据这些信息初始化runtime环境，在这一步包含了category的加载等。之后当runtime环境初始化完成后，会进行dyld的</strong>load_images<strong>，这一步会调用</strong>+load**方法。</p>\n<h2 id=\"Category-Associate\"><a href=\"#Category-Associate\" class=\"headerlink\" title=\"Category Associate\"></a>Category Associate</h2><p>在项目开发中，经常会使用到<strong>Category</strong>，有时候会遇到向<strong>Category</strong>中添加属性的需求，但是在<strong>Category</strong>中不能直接添加属性，而是要借助Runtime提供的<strong>Associated</strong>相关的API，例如：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">&#x2F;&#x2F; 声明\n@interface NSObject (TestCategory)\n@property (nonatomic, strong) NSObject *object;\n@end\n\n&#x2F;&#x2F; 实现\n#import &lt;objc&#x2F;runtime.h&gt;\n\nstatic void *const kAssociatedObjectKey &#x3D; (void *)&amp;kAssociatedObjectKey;\n\n@implementation NSObject (TestCategory)\n\n\n- (NSObject *)object&#123;\n    return objc_getAssociatedObject(self, kAssociatedObjectKey);\n&#125;\n\n- (void)setObject:(NSObject *)object&#123;\n    objc_setAssociatedObject(self, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n&#125;\n\n@end</code></pre>\n\n<p>在<strong>Category</strong>中添加属性后，默认是没有实现方法的，如果调用属性会发生崩溃，而且还会提示如下警告。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Property &#39;object&#39; requires method &#39;object&#39; to be defined - use @dynamic or provide a method implementation in this category\n\nProperty &#39;object&#39; requires method &#39;setObject:&#39; to be defined - use @dynamic or prov ide a method implementation in this category</code></pre>\n\n<p>这里提出<strong>objc_getAssociatedObject</strong>的runtime源码，如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">id\n_object_get_associative_reference(id object, const void *key)\n&#123;\n    ObjcAssociation association&#123;&#125;;\n\n    &#123;\n        AssociationsManager manager;\n        AssociationsHashMap &amp;associations(manager.get());\n        AssociationsHashMap::iterator i &#x3D; associations.find((objc_object *)object);\n        if (i !&#x3D; associations.end()) &#123;\n            ObjectAssociationMap &amp;refs &#x3D; i-&gt;second;\n            ObjectAssociationMap::iterator j &#x3D; refs.find(key);\n            if (j !&#x3D; refs.end()) &#123;\n                association &#x3D; j-&gt;second;\n                association.retainReturnedValue();\n            &#125;\n        &#125;\n    &#125;\n\n    return association.autoreleaseReturnedValue();\n&#125;</code></pre>\n\n<p>从源码中可以看到，所有通过<strong>Associated</strong>添加的属性，都被存储在一个全局单独的<strong>AssociationsHashMap</strong>哈希表中，<strong>objc_getAssociatedObject</strong>和<strong>objc_setAssociatedObject</strong>本质都是在操作这个哈希表，通过对哈希表进行映射来存储对象。</p>\n<p>在<strong>Associated</strong>的API中还有一些内存管理相关的关键字，例如<strong>OBJC_ASSOCIATION_ASSIGN</strong>，这些关键字用来指定对象的内存管理方式，在runtime中会根据这些关键字进行不同的内存管理。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;\n    OBJC_ASSOCIATION_ASSIGN &#x3D; 0,           &#x2F;**&lt; Specifies a weak reference to the associated object. *&#x2F;\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC &#x3D; 1, &#x2F;**&lt; Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. *&#x2F;\n    OBJC_ASSOCIATION_COPY_NONATOMIC &#x3D; 3,   &#x2F;**&lt; Specifies that the associated object is copied. \n                                            *   The association is not made atomically. *&#x2F;\n    OBJC_ASSOCIATION_RETAIN &#x3D; 01401,       &#x2F;**&lt; Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. *&#x2F;\n    OBJC_ASSOCIATION_COPY &#x3D; 01403          &#x2F;**&lt; Specifies that the associated object is copied.\n                                            *   The association is made atomically. *&#x2F;\n&#125;;</code></pre>\n\n","text":"在Objective-C中，可以通过Category添加属性、方法、协议，在Runtime中Class和Category都是通过结构体实现的。和Category相似的还有Extension，二者的区别在于，Extension在编译期就直接和原类编译在一起，而Category是在运...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Category%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Category的数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Category%E7%9A%84%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">Category的加载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#attachCategories\"><span class=\"toc-text\">attachCategories</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Category%E5%92%8C-load%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Category和+load方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Category-Associate\"><span class=\"toc-text\">Category Associate</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"Runtime剖析03 --- “黑魔法” Method Swizzling","uid":"c17c44d6d8996ee062f87af24348061f","slug":"2020-06-30-iOS-runtime-method-swizzling","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-06-30-iOS-runtime-method-swizzling.json","keywords":null,"cover":null,"text":"方法替换，又称为Method Swizzling，是Objective-C语言中比较流行的“黑魔法”。动态替换方法实现，大多数情况下使用在一些检测类的业务逻辑中，同时，方法替换也带给开发者更多可能的新的开发方式。在简单剖析**Method Swizzling **前，先看看方法替...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"Runtime剖析05 --- 再议iOS内存管理","uid":"e756f728cc576c6fe02245695ebbf9dd","slug":"2020-07-13-iOS-memory-manager","date":"2023-05-19T08:33:48.030Z","updated":"2023-05-19T08:33:48.030Z","comments":true,"path":"api/articles/2020-07-13-iOS-memory-manager.json","keywords":null,"cover":[],"text":"我们都知道，iOS中进行内存管理的管理模型是引用计数，但是这属于上层应用的范畴，在系统底层，iOS会根据不同的数据结构或者不同的数据类型，进行系统内存的分区，在不同的分区中，管理着自己的内存，另外，iOS的内存管理并不直接管理硬件内存，而是管理着硬件内存之上的一个过渡内存—虚拟内...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}