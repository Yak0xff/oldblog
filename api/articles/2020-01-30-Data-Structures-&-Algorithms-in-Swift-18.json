{"title":"\\#18\\ 归并排序（Merge Sort）","uid":"05deaa37bb6b9b668ab83d05b4918b64","slug":"2020-01-30-Data-Structures-&-Algorithms-in-Swift-18","date":"2023-05-13T14:28:22.148Z","updated":"2023-05-13T14:28:22.148Z","comments":true,"path":"api/articles/2020-01-30-Data-Structures-&-Algorithms-in-Swift-18.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/18/cover.jpg","content":"<p><strong>归并排序[Merge Sort]<strong>是最有效的排序算法之一，它的时间复杂度为O(n log n)，是所有通用排序算法中速度最快的一种。归并排序背后的思想是</strong>分而治之</strong>，即将一个大问题分解成多个更小、更易于解决的问题，然后将各个小问题的结果合并为最终结果。<strong>归并排序的终极秘诀是先拆分后合并。</strong></p>\n<p>例如，有如下未排序的扑克牌：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/18/eg-1.png\"></p>\n<p>针对上述问题，归并排序的工作原理如下：</p>\n<ul>\n<li>对扑克牌进行对半拆分，拆分后会有两大部分：</li>\n</ul>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/18/eg-2.png\"></p>\n<ul>\n<li>对上一步的拆分结果继续进行拆分：</li>\n</ul>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/18/eg-3.png\"></p>\n<p>直到无法再拆分为止</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/18/eg-4.png\"></p>\n<ul>\n<li>最后，将拆分的每一部分进行反向的合并，每次合并时，将不同的部分按照顺序进行排序。</li>\n</ul>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/18/eg-5.png\"></p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><p>归并排序的思想是分而治之，因此首先要进行问题的拆解，之后再进行合并。</p>\n<h3 id=\"拆分\"><a href=\"#拆分\" class=\"headerlink\" title=\"拆分\"></a>拆分</h3><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func mergeSort&lt;Element&gt;(_ array: [Element]) -&gt; [Element] where Element: Comparable &#123;\n    let middle &#x3D; array.count &#x2F; 2\n    let left &#x3D; Array(array[..&lt;middle])\n    let right &#x3D; Array(array[middle...])\n    \n    &#x2F;&#x2F; ... more to come\n&#125;</code></pre>\n\n<p>首先对待排序集合进行了对半拆分，但是仅仅一次拆分并不能满足归并排序的思想，需要持续拆分，直到集合再无法进行拆分为止，因此更新上述代码如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func mergeSort&lt;Element&gt;(_ array: [Element]) -&gt; [Element] where Element: Comparable &#123;\n    guard array.count &gt; 1 else &#123;\n        return array\n    &#125;\n    \n    let middle &#x3D; array.count &#x2F; 2\n    let left &#x3D; mergeSort(Array(array[..&lt;middle]))\n    let right &#x3D; mergeSort(Array(array[middle...]))\n    \n    &#x2F;&#x2F; ... more to come\n&#125;</code></pre>\n\n<ul>\n<li>首先确定算法可进入的条件，如果不符合基本的条件，则算法退出。这里的退出条件是待排序集合中仅有一个元素或无元素时，算法退出；</li>\n<li>使用递归的方式进行拆分，直至无法再次拆分为止。</li>\n</ul>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>完全拆分后，则进入到了归并排序的最后一步，将所拆分的左右部分进行合并，此时新建函数<em>merge</em>进行合并操作：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">private func merge&lt;Element&gt;(_ left: [Element], _ right: [Element]) -&gt; [Element] where Element: Comparable &#123;\n    var leftIndex &#x3D; 0\n    var rightIndex &#x3D; 0\n    var result: [Element] &#x3D; []\n    \n    while leftIndex &lt; left.count &amp;&amp; rightIndex &lt; right.count &#123;\n        let leftElement &#x3D; left[leftIndex]\n        let rightElement &#x3D; right[rightIndex]\n        \n        if leftElement &lt; rightElement &#123;\n            result.append(leftElement)\n            leftIndex +&#x3D; 1\n        &#125; else if leftElement &gt; rightElement &#123;\n            result.append(rightElement)\n            rightIndex +&#x3D; 1\n        &#125; else &#123;\n            result.append(leftElement)\n            leftIndex +&#x3D; 1\n            result.append(rightElement)\n            rightIndex +&#x3D; 1\n        &#125;\n    &#125;\n    if leftIndex &lt; left.count &#123;\n        result.append(contentsOf: left[leftIndex...])\n    &#125;\n    if rightIndex &lt; right.count &#123;\n        result.append(contentsOf: right[rightIndex...])\n    &#125;\n    return result\n&#125;</code></pre>\n\n<ol>\n<li><em>leftIndex</em>和<em>rightIndex</em>两个变量用于对遍历过程进行索引追踪；</li>\n<li><em>result</em>变量为最终的合并结果；</li>\n<li>使用<em>while</em>循环对左右集合进行遍历和元素比较，直到到达集合末尾位置；</li>\n<li>在遍历过程中，对元素进行比较，更小的元素或相等的元素均将追加到结果<em>result</em>并对索引进行移动；</li>\n<li><em>while</em>循环结束后，<em>left</em>和<em>right</em>两个集合均是已经排序了的，确保了剩下的元素都是大于或等于<em>result</em>中已存在的元素。此种情况下，可以直接将其追加到结果集合中。</li>\n</ol>\n<h3 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h3><p>合并工作使用了单独的函数完成，此时整合拆分和合并，最终归并排序算法如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public func mergeSort&lt;Element&gt;(_ array: [Element]) -&gt; [Element] where Element: Comparable &#123;\n    guard array.count &gt; 1 else &#123;\n        return array\n    &#125;\n    \n    let middle &#x3D; array.count &#x2F; 2\n    let left &#x3D; mergeSort(Array(array[..&lt;middle]))\n    let right &#x3D; mergeSort(Array(array[middle...]))\n    return merge(left, right)\n&#125;</code></pre>\n\n<p>总结一下归并排序的关键流程：</p>\n<ol>\n<li>归并排序的核心思想是分而治之，即将大问题拆分成多个小问题，依次对各个小问题进行求解，最后在合并各个结果；</li>\n<li>归并排序算法有两个核心的职责：一个是递归拆分初始集合的方法，另一个是合并两个集合的方法；</li>\n<li>合并函数应该使用两个排序的数组并生成一个排序的数组。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;merge sort&quot;) &#123;\n    let array &#x3D; [7, 2, 6, 3, 9]\n    print(&quot;Original: \\(array)&quot;)\n    print(&quot;Merge sorted: \\(mergeSort(array))&quot;)\n&#125;\n\n&#x2F;*\n---Example of merge sort---\nOriginal: [7, 2, 6, 3, 9]\nMerge sorted: [2, 3, 6, 7, 9]\n*&#x2F;</code></pre>\n\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>归并排序有着并不太坏的时间复杂度，其最好、最坏和平均时间复杂度为O(n log n)。</p>\n<ul>\n<li>在递归的时候，需要将一个集合拆分成更小的集合，这意味着大小为2的集合需要一次递归，大小为4的集合需要两次递归，大小为8的集合需要三次递归等等。一般情况下，如果集合的大小为n，则要拆分的层级数就是log2(n)；</li>\n<li>一个递归级别将合并n个元素。不管合并的规模是大是小;每一层合并的元素数量仍然是n。这意味着一个递归的代价是O(n)。</li>\n</ul>\n<p>那么拆分和合并的总体消耗为 *O(log n) x O(n) &#x3D; O(n log n)*。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>归并排序的核心思想是<strong>分而治之</strong>的原则；</li>\n<li>归并排序算法的实现由多种方式，不同的实现可能带来不同的性能体现。</li>\n</ul>\n","text":"归并排序[Merge Sort]是最有效的排序算法之一，它的时间复杂度为O(n log n)，是所有通用排序算法中速度最快的一种。归并排序背后的思想是分而治之，即将一个大问题分解成多个更小、更易于解决的问题，然后将各个小问题的结果合并为最终结果。归并排序的终极秘诀是先拆分后合并。...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%86%E5%88%86\"><span class=\"toc-text\">拆分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">合并</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%90%88\"><span class=\"toc-text\">整合</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#17\\ 排序算法O(n^2)","uid":"8ac62db54bf242691e8bc332c52f0b5b","slug":"2020-01-15-Data-Structures-&-Algorithms-in-Swift-17","date":"2023-05-13T14:28:22.148Z","updated":"2023-05-13T14:28:22.148Z","comments":true,"path":"api/articles/2020-01-15-Data-Structures-&-Algorithms-in-Swift-17.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/17/cover.jpg","text":"**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。 在本文中，将学习饿三种不同的、O(n^2)时间...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#19\\ 基数排序（Radix Sort）","uid":"1eff6ae9330e74043f153497674d46df","slug":"2020-02-01-Data-Structures-&-Algorithms-in-Swift-19","date":"2023-05-13T14:28:22.148Z","updated":"2023-05-13T14:28:22.148Z","comments":true,"path":"api/articles/2020-02-01-Data-Structures-&-Algorithms-in-Swift-19.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/19/cover.jpg","text":"**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。 为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。 示例为了进行基数排序的工作方式，假设需要对如下的集合进行排序： var array &#...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}