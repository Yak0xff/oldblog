{"title":"\\#2\\ 认识 Array & Dictionary","uid":"c0089ea14d61cc249075e2e9c2241913","slug":"2019-12-01-Data-Structures-&-Algorithms-in-Swift-02","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-01-Data-Structures-&-Algorithms-in-Swift-02.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/2/cover.jpg","content":"<p>在 <strong>Swift Standard Library</strong> 中包含了Swift语言的核心组件。在标准库框架中你可以发现很多可用于应用程序开发的同居和类型，在开始设计自己的数据结构前，了解Swift语言本身的语言特性是设计良好数据结构和算法设计的基础。</p>\n<p>在此篇内容中，着重了解 Swift Standard Library 中的两大数据结构：<strong>Array &amp; Dictionary</strong>。</p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p><strong>Array</strong> 是一个通用型的容器组件，用于存储元素的有序集合，在Swift语言中被大量使用。<strong>Swift Standard Library</strong>中的 <strong>Array</strong> 可以使用任意的数据类型创建数组。例如使用文字创建数据时，文字使用用逗号分隔，方括号括起来，如下：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var people &#x3D; [&quot;Brian&quot;, &quot;Stanley&quot;, &quot;Ringo&quot;]</code></pre>\n\n<p>在Swift中，Array的定义是通过协议定义的，不同的协议层给Array提供了不同的能力。例如，数组是一个**序列(Sequence)<strong>，至少可以遍历它一次。它也是一个</strong>集合(Collection)<strong>，又可以被多次遍历，而且不具有破坏性，并且可以使用下标运算符访问它。数组也是一个</strong>随机访问集合(RandomAccessCollection)**，它保证了效率。</p>\n<p>上文提到，Swift中的Array是一个通用型的数据结构，意味着你可以在数据中使用任何数据类型。事实上，在Swift标准库中有大量的通用型代码。</p>\n<p>对于任何数据结构，都会有一些显著性的特征值的关注，对于Array来说，首先需要关注的是 — <strong>顺序</strong>。</p>\n<h5 id=\"顺序（Order）\"><a href=\"#顺序（Order）\" class=\"headerlink\" title=\"顺序（Order）\"></a>顺序（Order）</h5><p>Array中的元素（Element）具有显性的顺序，例如上述<code>people</code>数组，”Brian” 会出现在 “Stanley” 的前面。</p>\n<p>数据中的所有元素都有一个明确的基于0开始的整数类型下标。例如上述例子中，数组中包含了三个元素，每一个下标将对应唯一的一个元素，可以通过下标的方式获取具体的某个元素。例如：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">people[0] &#x2F;&#x2F; &quot;Brian&quot;\npeople[1] &#x2F;&#x2F; &quot;Stanley&quot;\npeople[2] &#x2F;&#x2F; &quot;Ringo&quot;</code></pre>\n\n<p>数据中的元素顺序是显著性的，该顺序也是数组的数据结构所定义的，但是需要注意的是并不是所有的集合类型都有显著性的顺序。例如<strong>Dictionary</strong>，并没有显著性的顺序，仅有有一个弱化的顺序的概念。</p>\n<h5 id=\"随机访问权限（Random-access）\"><a href=\"#随机访问权限（Random-access）\" class=\"headerlink\" title=\"随机访问权限（Random-access）\"></a>随机访问权限（Random-access）</h5><p><strong>随机访问权限</strong>是数组的数据结构所定义的特性，表示在数组可以在恒定的时间内完成数据元素的检索。例如在上述数组中，”Brian”元素的获取总是在恒定的时间内。同样地，并不是所有的集合类型都是如此，例如链表、树并没有随机访问权限，元素的获取也不会有恒定的时间。</p>\n<h3 id=\"数组的性能\"><a href=\"#数组的性能\" class=\"headerlink\" title=\"数组的性能\"></a>数组的性能</h3><p>随机访问权限的另一个影响是数组操作的<strong>性能</strong>。对于一个开发者而言，对于数组的各种操作，了解其在数据量持续增大的情况下性能的变更，是影响程序是否高效的关键因素之一。而对于数组而言，影响其性能的因素主要有两个：</p>\n<h5 id=\"插入位置（Insertion-location）\"><a href=\"#插入位置（Insertion-location）\" class=\"headerlink\" title=\"插入位置（Insertion location）\"></a>插入位置（Insertion location）</h5><p>在Swift中，数组的插入操作大多数高效的规则是进行数据元素的追加，也就是在现有数据上使用追加的方式，在数据末尾添加新的元素：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">people.append(&quot;Charles&quot;)\nprint(people)  &#x2F;&#x2F; [&quot;Brian&quot;, &quot;Stanley&quot;, &quot;Ringo&quot;, &quot;Charles&quot;]</code></pre>\n\n<p>上述示例中使用<code>append</code>方法，在数组的末尾位置插入了新的元素”Charles”，这个操作的耗时是恒定的，也意味着不论原数组中的元素有多少，在该数组的末尾插入新的元素并不会带来额外的时间消耗。但是如果在原数组的除了末尾位置之外的其他既定位置插入元素，例如在数组的中间位置插入新的元素，会带来更多的时间消耗。</p>\n<p>举个例子，人们正在按秩序排队进行结账，此时来了一个新的顾客，在不妨碍其他任何人的情况下，新顾客应该直接在队伍的尾部加入队伍，也不会引起其他人的反感等，而如果该新顾客非要走到队伍中间位置插队，那么该位置后面的每一个人都需要向后挪动，这样至少给原有队伍中一半的人带来的愤怒。</p>\n<p>有一条经验是，<strong>如果在开发工作中，你需要在原有的集合类型数据结构中，频繁的在集合的头部或者非末尾位置进行元素的插入，那你可能需要重新设计你的数据结构了。</strong></p>\n<h5 id=\"数组容量（Capacity）\"><a href=\"#数组容量（Capacity）\" class=\"headerlink\" title=\"数组容量（Capacity）\"></a>数组容量（Capacity）</h5><p>影响数组性能的另一个因素便是<strong>数组的容量</strong>，这里所说的容量是数组的预制容量。Swift中的数组是根据数组中的元素总量来进行内存空间的预开辟的。如果数组的容量已经达到了预设定的最大值，那么数组必须重构自己来为新的元素增加空间。这一步操作是底层帮你完成的，系统会拷贝所有原有的元素并在内存中新建一个更大容量的数组，这将带来性能和时间的消耗，因为数组中的每一个元素都需要被访问到并进行拷贝。</p>\n<p>也就意味着，数组的插入操作，除了在数组的末尾进行追加式插入新元素外，其他的插入操作都会使得数组进行 <em>n</em>（数组大小） 步才能完整操作。</p>\n<h2 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h2><p><strong>Dictionary</strong> 是另一种集合类型的数据结构，存储<strong>key-value对</strong>数据。例如：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">var scores: [String: Int] &#x3D; [&quot;Eric&quot;: 9, &quot;Mark&quot;: 12, &quot;Wayne&quot;: 1]</code></pre>\n\n<p>在字典中没有任何既定的顺序，也不能通过索引插入。在Swift中，字典的必备条件是key值必须是<code>Hashable</code>的。幸运的是，在最近几个版本的Swift中，几乎所有的标准类型都遵循<code>Hashable</code>协议，开发者不用自己去实现<code>Hashable</code>了。</p>\n<p>在字典中插入新的数据，一般情况下，通过如下的句法进行：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">scores[&quot;Andrew&quot;] &#x3D; 0</code></pre>\n\n<p>这样底层实现会创建一个新的<code>key-value</code>对，并添加到字典中：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">[&quot;Eric&quot;: 9, &quot;Andrew&quot;: 0, &quot;Mark&quot;: 12, &quot;Wayne&quot;: 1]</code></pre>\n\n<p>可以看到字典是无序的集合类型。对于同一个字典，新数据的插入，会访问到字典中的每一个键值对，其消耗的时间是相同的，直到集合被改变。对于字典而言，并不需要关心数据插入和获取的时间消耗问题，每次操作都是字典中数据量的总访问时间。但是相对于数组来说，字典的数据获取会更高效。</p>\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>每一种数据结构都有其优点和缺点，了解数据结构的优缺点，能够为高效的软件性能提供帮助；</li>\n<li>数组是有序的集合。数组的插入操作会影响数组的操作耗时，末尾追加除外。如果在软件开发中，需要在数组的非末尾位置频繁的进行插入，可能需要重新设计数据结构，例如链表等；</li>\n<li>字典是无序的集合。字典为了快速插入和搜索而牺牲了保持元素顺序的能力。</li>\n</ul>\n","text":"在 Swift Standard Library 中包含了Swift语言的核心组件。在标准库框架中你可以发现很多可用于应用程序开发的同居和类型，在开始设计自己的数据结构前，了解Swift语言本身的语言特性是设计良好数据结构和算法设计的基础。 在此篇内容中，着重了解 Swift S...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Array\"><span class=\"toc-text\">Array</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%EF%BC%88Order%EF%BC%89\"><span class=\"toc-text\">顺序（Order）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88Random-access%EF%BC%89\"><span class=\"toc-text\">随机访问权限（Random-access）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">数组的性能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88Insertion-location%EF%BC%89\"><span class=\"toc-text\">插入位置（Insertion location）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F%EF%BC%88Capacity%EF%BC%89\"><span class=\"toc-text\">数组容量（Capacity）</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Dictionary\"><span class=\"toc-text\">Dictionary</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#1\\ 为什么要学习数据结构与算法","uid":"e90242255f8181a299a4107cc70159e8","slug":"2019-12-01-Data-Structures-&-Algorithms-in-Swift-01","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-01-Data-Structures-&-Algorithms-in-Swift-01.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/1/cover.jpg","text":"随机网络上有大量的程序员应该学习数据结构和算法的文章。还记得实在大学时代的时候，系统的学习过数据结构、算法相关的课程，而后几乎没有系统学习过了。工作后从一开始的各种业务逻辑的开发，慢慢深入了解到系统底层，了解了代码的执行效率以及对硬件设备资源的消耗基本上都是由数据结构和算法决定的...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#3\\ 关于时间复杂度和大O符号","uid":"ed1a650be4c536b8ed544197809a0599","slug":"2019-12-02-Data-Structures-&-Algorithms-in-Swift-03","date":"2023-05-13T15:08:12.965Z","updated":"2023-05-13T15:08:12.965Z","comments":true,"path":"api/articles/2019-12-02-Data-Structures-&-Algorithms-in-Swift-03.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/3/cover.jpg","text":"算法复杂度的衡量问题在软件开发的诞生早起就已经被提出来，并且有多个方面具体的问题。例如，从系统的架构来看，可伸缩性的架构设计和算法实现，应用程序是如何在数据特征增加的情况下被合理有效地激活的；从数据库的角度来看，数据库的处理能力是否能够应对越来越多的数据和用户行为等。 对于算法而...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}