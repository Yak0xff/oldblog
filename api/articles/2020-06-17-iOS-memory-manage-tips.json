{"title":"iOS内存管理小结","uid":"efbbbd2e93d0b6b1478e69b9a9de5940","slug":"2020-06-17-iOS-memory-manage-tips","date":"2023-05-30T09:56:42.583Z","updated":"2023-05-30T09:56:42.583Z","comments":true,"path":"api/articles/2020-06-17-iOS-memory-manage-tips.json","keywords":null,"cover":null,"content":"<p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，但是ARC并不是万能的，有些框架中和某些使用到C语言的场景中还是需要开发者手动对内存进行管理。</p>\n<h2 id=\"iOS-中的内存管理模型\"><a href=\"#iOS-中的内存管理模型\" class=\"headerlink\" title=\"iOS 中的内存管理模型\"></a>iOS 中的内存管理模型</h2><p>对于<strong>面向过程</strong>的C语言而言，在内存管理的设计上也较为直接，内存的申请和释放都由开发者手动管理。这种管理方式虽然简单，但是大大的增加了编码的工作量，也增加了代码的复杂度。</p>\n<p>在<strong>面向对象</strong>语言中，内存管理通常会由<strong>模型机制</strong>来完成，常见的内存管理模型机制有<strong>垃圾回收机制</strong>和<strong>引用计数机制</strong>两种，Objective-C语言采用的则是引用计数的内存管理模型。</p>\n<p>内存的管理其实就是管理程序代码和相关数据对内存的消耗，在iOS中，内存通常被分为5个特定的功能性区域：</p>\n<ul>\n<li><strong>栈区</strong>：存储局部变量，或自动变量，在作用域结束后内存会被回收；栈区也保存了函数调用的现场；</li>\n<li><strong>堆区</strong>：存储OC对象，需要开发者手动申请和释放，通常使用malloc、realloc、alloc等函数控制的变量，均存储在堆上，堆在所有的线程，共享库和动态加载的模块中被共享使用；</li>\n<li><strong>BSS区</strong>：即Block Started by Symbol，用来存储未初始化的全局变量和静态变量；</li>\n<li><strong>数据区</strong>：用来存储已经初始化的全局变量、静态变量和常量；</li>\n<li><strong>代码区</strong>：加载程序代码。</li>\n</ul>\n<p>在5个内存区域中，除了堆区需要开发者手动进行内存的管理外，其他区域均由系统自动进行管理。</p>\n<p>引用计数是Objective-C语言提供的内存管理技术，每一个Objective-C对象都有一个<strong>retainCount</strong>属性，该属性便是引用计数机制的根本。一个Objective-C对象是否应该被释放，取决于retainCount是否为0。</p>\n<h3 id=\"关于MRC\"><a href=\"#关于MRC\" class=\"headerlink\" title=\"关于MRC\"></a>关于MRC</h3><p>MRC内存管理有如下两个原则：</p>\n<ul>\n<li>谁持有对象，谁负责释放，不是自己持有的不能释放；</li>\n<li>当对象不再被需要时，需要主动释放。</li>\n</ul>\n<p>在OC中，会对对象进行持有的方法有alloc、new、copy、mutableCopy、retain。其中retain是对当前对象进行持有，使得引用计数加1，其余四个是创建新的对象，创建后引用计数加1。</p>\n<h3 id=\"关于ARC\"><a href=\"#关于ARC\" class=\"headerlink\" title=\"关于ARC\"></a>关于ARC</h3><p>ARC是Xcode编译器的功能，ARC并没有改变MRC内存管理的两个原则，也并没有在运行时增加新的特性，ARC仅仅是在编译时帮助开发者将retain和release方法给补上。</p>\n<p>ARC下，有几个关键的修饰符：**__strong、__weak、__unsafe_unretained、__autoreleasing<strong>，被称为</strong>所有权修饰符<strong>，在开发中，开发者所使用的指针默认使用</strong>__strong**修饰符。</p>\n<p>__strong修饰符通常是对变量进行强引用，主要有三方面的作用：</p>\n<ol>\n<li>使用__strong修饰的变量如果是自己生成的，则会被添加进自动释放池，在作用域结束后，会被release一次；</li>\n<li>使用__strong修饰的变量如果不是自己生成的，则会被强引用，即会被持有使其引用计数加1，在离开作用域之后，会被release一次；</li>\n<li>使用__strong修饰的变量如果重新赋值或者置为nil，则变量会被release一次。</li>\n</ol>\n<p>__weak修饰符通常用来对变量进行弱引用，最大的用途是避免ARC环境下的循环引用问题。<strong>循环引用</strong>问题是ARC中造成内存泄漏的主要问题。__weak修饰符主要有两个作用：</p>\n<ol>\n<li>被__weak修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会被添加到自动释放池，会在离开作用域是被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作；</li>\n<li>被__weak修饰的变量指针，变量如果失效，则指针会被自动置为nil，否则可能会造成<code>野指针</code>异常。</li>\n</ol>\n<p>__unsafe_unretained修饰符是不全安的，该修饰符的作用也是对变量进行弱引用，和__weak不同的是，当变量失效后，其指针不会被自动置为nil。__unsafe_unretained修饰符的主要作用：</p>\n<ol>\n<li>被__unsafe_unretained修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会在离开作用域后release一次，如果不是自己生成的，则在离开作用域后，不进行release操作；</li>\n<li>被__unsafe_unretained修饰的变量，当变量失效后，被修饰指针不会被安全处理为nil，即旧地址依然保存。</li>\n</ol>\n<p>__autoreleasing修饰符与自动释放池有关。</p>\n<p>在使用ARC时，有以下几条原则：</p>\n<ul>\n<li>不能使用retain、release、autorelease函数，不可访问retainCount属性</li>\n<li>不能调用dealloc函数，可以覆写dealloc函数，但是在其视线中不可调用父类的dealloc函数</li>\n<li>不能使用NSAutoreleasePool，可以使用@autoreleasepool代替</li>\n<li>对象类型变量不能作为C语言的结构体</li>\n</ul>\n<h3 id=\"属性修饰符\"><a href=\"#属性修饰符\" class=\"headerlink\" title=\"属性修饰符\"></a>属性修饰符</h3><p><strong>类是属性和方法的集合。属性用来存储类中的数据，方法用来描述类的行为。</strong></p>\n<p>属性在声明时会默认添加修饰符。在MRC环境下，默认的属性修饰符为<strong>atomic，readWrite，retain</strong>，在ARC下，默认的属性修饰符为<strong>atomic，readWrite，strong\\assign</strong>。</p>\n<p>通常情况下，在声明属性时会使用@property，此时编译器或自动帮助声明和实现属性的Setter方法和Getter方法。</p>\n<p>关于内存管理相关的属性修饰符有如下几种：</p>\n<table>\n        <tr>\n            <th>修饰符</th>\n            <th>作用</th>\n        </tr>\n        <tr>\n            <th>assign</th>\n            <th>直接赋值，和引用计数无关，用来声明简单数据类型的属性，例如int</th>\n        </tr>\n        <tr>\n            <th>retain</th>\n            <th>对旧对象进行释放，并强引用新的对象，使其引用计数加1，用在MRC中</th>\n        </tr>\n        <tr>\n            <th>strong</th>\n            <th>对新对象进行强引用，释放旧对象，使其引用计数加1，作用与retain相似，用在ARC中</th>\n        </tr>\n        <tr>\n            <th>copy</th>\n            <th>在实现Setter方法时，采用copy函数，会生成新的对象，并被自己持有</th>\n        </tr>\n        <tr>\n            <th>weak</th>\n            <th>弱引用，不对所赋值的对象进行持有，但是是安全的，对对象不可用时，会被置为nil，用在ARC中</th>\n        </tr>\n        <tr>\n            <th>unsafe_unreatined</th>\n            <th>弱引用，和weak不同的是，如果引用的对象不可用，则当前指针不会被置为nil，会产生野指针</th>\n        </tr>\n    </table>\n\n<h2 id=\"自动释放内存\"><a href=\"#自动释放内存\" class=\"headerlink\" title=\"自动释放内存\"></a>自动释放内存</h2><p>在iOS中，对象的创建除了使用alloc、new等函数创建外，还可使用对象的对象方法来创建，但此时对象的创建方式并不符合“谁持有对象，谁负责释放”的原则，此类方式创建的对象在内存管理上，则将管理权移交给了自动释放池。</p>\n<p>我们知道，release函数的作用是对当前对象进行一次引用计数减1，当引用计数为0时，才真实释放对象所使用的内存。而autorelease，其本质上是使release函数的调用进行延迟调用了。可以简单的把autorelease方法的对象成为自动释放对象，自动释放对象的内存管理是提交给自动释放池处理的。</p>\n<h3 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h3><p>@autoreleasepool{}标识就是自动释放池，当自动释放池操作结束后，其会向被添加进自动释放池的所有对象发送release消息。@autoreleasepool{}的写法是ARC下的下发，在MRC坏境下，需要创建自动释放池对象，然后进行使用。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">NSAutoreleasePool *pool &#x3D; [[NSAutoreleasePool alloc] init];\n&#x2F;&#x2F; 添加进自动释放池的对象\n[pool release];</code></pre>\n\n<p>另外，在iOS系统运行应用程序时，会自动创建一些线程，每个线程都默认拥有自己的自动释放池。还有，在每次执行时间循环时，都活将其自动释放池清空。因此，在大多数情况下，开发者不需要手动创建自动释放池，例外的是，系统的自动释放池会在每次时间循环结束后清空，如果代码中有大量的循环，会生成大量的自动释放对象，则可能会导致内存消耗瞬时增长。</p>\n<h2 id=\"杜绝内存泄漏\"><a href=\"#杜绝内存泄漏\" class=\"headerlink\" title=\"杜绝内存泄漏\"></a>杜绝内存泄漏</h2><p><strong>内存泄漏的核心问题是循环引用。</strong></p>\n<p><strong>循环引用：在OC设计中，对象会对其内部的属性进行持有，当一个对象的引用计数为0，将其内存回收时，这个对象会向其内的所有属性发送release消息，让其中的属性对象进行释放。如果对象内的某个属性再次对当前的对象进行了持有，则会产生循环引用。</strong></p>\n<h3 id=\"Block与循环引用\"><a href=\"#Block与循环引用\" class=\"headerlink\" title=\"Block与循环引用\"></a>Block与循环引用</h3><p>Block是OC中一种十分强大的语法。使用Block，可以将代码块作为属性、参数以及变量来使用，并且可以灵活地执行这块代码。Block的实质是一段可执行的代码块，对于Block类型的属性和变量，可以对其进行赋值。但究其根本，Block的本质还是对象。</p>\n<p>对于Block的使用，有一些有趣的地方，在Block中访问Block外的数据时没有问题的，无论是对象数据还是基本数据类型数据，但是如果要在Block中修改Block外的数据，可能会发生异常，可变字符串等外部数据的修改不会发生异常。</p>\n<p>其实并不是Block对外部数据修改有什么特殊的设计，而是因为在Block中，任何外部数据都是不允许被修改的，可变类型数据能够被修改，是因为对象指针所指向的内存存放的只是对象数据的地址，并不是对象数据本身，只要地址不被修改，只修改对象的数据是没有问题的。</p>\n<p><strong>在Block内部无法修改外部数据的根本原因在于，Block中访问外部变量时，都会对其进行拷贝和强引用，这里的拷贝是直接拷贝，如果在Block外部和内部分别打印对象，会看到对象的地址是不同的。</strong></p>\n<p>如果要保证在Block内部可以自由修改外部的数据，OC提供了__block关键字，使用该关键字修饰的变量，可以在Block中直接访问原始变量，而没有拷贝。</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">self.myblock &#x3D; ^BOOL(int param)&#123;\n    NSLog(@&quot;%@&quot;, self);\n    return YES;\n&#125;;</code></pre>\n<p>上述代码是Block中循环引用的经典例子。其中myblock和self之间产生的循环引用。要解决Block中的循环引用，只需要在Block中使用弱引用的指针即可，这样在Block的作用域结束后，其对外部变量的引用也会自然切换，避免循环引用。</p>\n<h3 id=\"代理与循环引用\"><a href=\"#代理与循环引用\" class=\"headerlink\" title=\"代理与循环引用\"></a>代理与循环引用</h3><p>代理是另一种可能会产生循环引用的场景。在iOS中，除了系统的一些原生的组件需要通过代理函数来进行回调外，开发者也经常使用<strong>代理来进行传值、逻辑回调、组件配置</strong>等。有时，开发者会使用代理来进行<strong>反向传值</strong>，而反向传值的时候需要在视图控制器中设置代理，如果代理属性采用了strong修饰符，则视图控制器对代理对象是强应用，而定义代理的类可能又是视图控制器的属性，造成了循环引用，造成内存泄漏，因此在使用代理模式的时候，设置代理属性一般采用如下修饰符：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">@property (nonatomic, weak) id&lt;CustomeDelegate&gt; delegate;</code></pre>\n\n\n<h3 id=\"定时器引起的内存泄漏\"><a href=\"#定时器引起的内存泄漏\" class=\"headerlink\" title=\"定时器引起的内存泄漏\"></a>定时器引起的内存泄漏</h3><p>定时器通产个用来进行循环任务的执行，NSTimer是iOS中极易产生循环引用的一个类。通常在使用定时器时，会定义一个定时器对象如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">@property (nonatomic, strong) NSTimer * timer;</code></pre>\n\n<p>再具体使用定时器时，如下：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval: 1 target: self selector:@selector(timerRun) userinfo: nil repeat: YES];</code></pre>\n\n<p>当定时器对象所在的视图控制器被dismiss之后，视图控制器并没有执行dealloc函数，原因在于定时器对象实际上持有了视图控制器，只有当定时器失效后，其才会释放所持有的视图控制器。因此，在视图控制器返回前，开发者可以手动调用invalidate方法使得定时器失效，已避免循环引用。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>iOS 10 SDK 中已经提供了避免循环引用的NSTimer 新 API。</p></blockquote>\n<h2 id=\"“僵尸”对象\"><a href=\"#“僵尸”对象\" class=\"headerlink\" title=\"“僵尸”对象\"></a>“僵尸”对象</h2><p>首先，<strong>僵尸对象和内存泄漏无任何关系。</strong>但是产生僵尸对象也属于内存管理问题。当一个对象被释放后，如果其指针没有置空，则这个指针就变成了野指针，此时该对象被称为僵尸对象。</p>\n<h3 id=\"僵尸对象的捕获\"><a href=\"#僵尸对象的捕获\" class=\"headerlink\" title=\"僵尸对象的捕获\"></a>僵尸对象的捕获</h3><p>在OC中，内存的使用包含如下几个阶段：</p>\n<ul>\n<li>请求创建对象，向系统申请一块内存空间，在申请完成后，这块内存空间不能在做他用；</li>\n<li>对象被释放，此时这块内存空间变为闲置，可以被再次申请使用；</li>\n<li>在此块内存重新被申请使用之前，这块内存中的数据依然存在；</li>\n<li>此时如果依然有指针指向这块内存，则此指针为野指针；</li>\n<li>当野指针对这块内存进行访问时，如果这块内存已经被重新分配，则会出现系统问题，如果没有被分配，则不会出现系统问题。</li>\n</ul>\n<p>在MRC下，当一个对象被release后，再去访问这个对象的时候，就会出现异常，出现僵尸对象。而在ARC下,Xcode也提供了捕获僵尸对象的选项，供开发者使用。<strong>Zombie Objects选项</strong></p>\n<h3 id=\"处理僵尸对象\"><a href=\"#处理僵尸对象\" class=\"headerlink\" title=\"处理僵尸对象\"></a>处理僵尸对象</h3><p>一般在开发中，僵尸对象一旦出现，大多数情况是代码逻辑的问题，但是如果做到万无一失，避免由于僵尸对象带来应用程序的崩溃呢？</p>\n<p>在OC中，向空指针发送任何消息都是无效的。因此，访问到僵尸对象的根本问题是野指针的问题。在ARC中，使用__weak和__strong修饰的变量指针，在对象释放后被自动置为nil，这就大大减少了野指针的问题。另外一种方式就是使用OC的消息机制来规避所有的僵尸对象问题。</p>\n<h2 id=\"CoreFoundation框架中的内存管理\"><a href=\"#CoreFoundation框架中的内存管理\" class=\"headerlink\" title=\"CoreFoundation框架中的内存管理\"></a>CoreFoundation框架中的内存管理</h2><p>CoreFoundation框架是由C语言实现的一组编程接口，与Foundation框架提供类似的基础功能，不同的是Foundation框架是由OC语言实现的，CoreFoundation也提供了字符串、数组、集合、颜色、时间和URL等对象。</p>\n<p><strong>CoreFoundation框架中依然采用引用计数的方式进行内存管理，但并不支持ARC。</strong></p>\n<p>在CoreFoundation框架中，有几条内存管理法则：</p>\n<ol>\n<li>自己创建的对象要自己负责释放；</li>\n<li>如果使用别人创建的对象，要保证其可用，则需要对对象进行持有；</li>\n<li>如果对对象进行了持有，则当不在需要此对象时，要进行释放。</li>\n</ol>\n<p>在CoreFoundation框架中，使用带有Create、Copy此类字段的函数获取的对象会被认为是自己创建的对象，要负责这些对象的释放。当使用滴啊有Get这样的字段的函数获取对象时，默认并不对此对象进行持有，可以手动调用CFRetain()函数进行持有。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>OC是面向对象的语言，但是对象仅仅是引用层面的一种抽象，抛开其华丽的外衣，底层依然是最为朴素的结构体和指针。</li>\n<li>OC语言采用了引用计数的内存管理模型，对内存进行管理；</li>\n<li>除了用户自建的内存管理池意外，系统在每个线程都维护了一个系统级别的自动释放池；</li>\n<li>OC语言的类型检查都是编译时的特性；</li>\n<li>OC语言的数据传递是运行时决定的。</li>\n</ul>\n","text":"内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"开发知识 iOS","slug":"开发知识-iOS","count":7,"path":"api/tags/开发知识-iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iOS-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">iOS 中的内存管理模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EMRC\"><span class=\"toc-text\">关于MRC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EARC\"><span class=\"toc-text\">关于ARC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">属性修饰符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98\"><span class=\"toc-text\">自动释放内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0\"><span class=\"toc-text\">自动释放池</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%9C%E7%BB%9D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">杜绝内存泄漏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Block%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">Block与循环引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">代理与循环引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">定时器引起的内存泄漏</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%9C%E5%83%B5%E5%B0%B8%E2%80%9D%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">“僵尸”对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">僵尸对象的捕获</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">处理僵尸对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CoreFoundation%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">CoreFoundation框架中的内存管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#20\\ 堆排序（Heap Sort）","uid":"b14270b802509aef1b418b7534f574dc","slug":"2020-02-03-Data-Structures-&-Algorithms-in-Swift-20","date":"2023-05-30T09:56:42.583Z","updated":"2023-05-30T09:56:42.583Z","comments":true,"path":"api/articles/2020-02-03-Data-Structures-&-Algorithms-in-Swift-20.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/20/cover.jpg","text":"**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看\\#15\\ 堆数据结构（The Heap Data Structure）中的介绍。 堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质： 在最...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"Runtime剖析01 --- 基本数据结构：objc_object & objc_class","uid":"6fca2ac91a092d45af749e0779750e56","slug":"2020-06-23-iOS-runtime-basic-structure","date":"2023-05-30T09:56:42.583Z","updated":"2023-05-30T09:56:42.583Z","comments":true,"path":"api/articles/2020-06-23-iOS-runtime-basic-structure.json","keywords":null,"cover":[],"text":"众所周知，Objective-C语言是一门动态性很强的语言，与C、C++等语言有着很大的不同。Objective-C语言的动态性基本上都是由Runtime机制进行支撑和实现的，Runtime的实现，融合了C、C++，以及汇编语言。 什么是Runtime？C、C++等静态语言中的各...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Runtime","slug":"Runtime","count":5,"path":"api/tags/Runtime.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}