{"title":"\\#6\\ Linked List 挑战","uid":"87b78748d49eafbc45cf485f76a0100a","slug":"2019-12-05-Data-Structures-&-Algorithms-in-Swift-06","date":"2023-05-13T14:55:49.795Z","updated":"2023-05-13T14:55:49.795Z","comments":true,"path":"api/articles/2019-12-05-Data-Structures-&-Algorithms-in-Swift-06.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/6/cover.jpg","content":"<p>本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。</p>\n<h2 id=\"Challenge-1：创建按照反向顺序打印链表元素的函数。\"><a href=\"#Challenge-1：创建按照反向顺序打印链表元素的函数。\" class=\"headerlink\" title=\"Challenge 1：创建按照反向顺序打印链表元素的函数。\"></a>Challenge 1：创建按照反向顺序打印链表元素的函数。</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; LinkedList\n1 -&gt; 2 -&gt; 3 -&gt; nil\n\n&#x2F;&#x2F; outut\n3\n2\n1</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 解决此问题最简单直接的方式就是使用<strong>递归</strong>。由于递归允许构建回调堆栈，因此我们可以在递归的回调中调用<strong>print</strong>打印节点元素值。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; 递归调用\nprivate func printInReverse&lt;T&gt;(_ node: Node&lt;T&gt;?) &#123;\n    guard let node &#x3D; node else &#123;\n        return\n    &#125;\n    printInReverse(node.next)\n    print(node.value)\n&#125;\n\n\nfunc printInReverse&lt;T&gt;(_ list: LinkedList&lt;T&gt;) &#123;\n    printInReverse(list.head)\n&#125;</code></pre>\n<p>测试和结果检查：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;printing in reverse&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Original list: \\(list)&quot;)\n    print(&quot;Printing in reverse: &quot;)\n    printInReverse(list)\n&#125;\n\n&#x2F;&#x2F; ---Example of printing in reverse---\n&#x2F;&#x2F; Original list: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; Printing in reverse: \n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 1</code></pre>\n\n<p>该算法的核心在于递归调用的部分，当节点存在的情况下，继续遍历当前节点的下一个节点，否则就是已经到了末尾节点，在递归的过程回调堆栈中打印节点值。该算法时间复杂度为**O(n)**。</p>\n<h2 id=\"Challenge-2：创建返回链表中间节点值的函数。\"><a href=\"#Challenge-2：创建返回链表中间节点值的函数。\" class=\"headerlink\" title=\"Challenge 2：创建返回链表中间节点值的函数。\"></a>Challenge 2：创建返回链表中间节点值的函数。</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; LinkedList\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nil\n&#x2F;&#x2F; middle is 3\n\n1 -&gt; 2 -&gt; 3 -&gt; nil\n&#x2F;&#x2F; middle is 2</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 该问题的解决思路是利用<strong>双指针位移的偏移量</strong>的方式来进行求解，也就是说分别定义两个初始位置相同的指针，然后对链表进行遍历，遍历的过程中，其中一个针对每次位移两个位置，另一个位移一个位置，位移快的那个移动到链表末尾时，慢的那个正好是链表的中间位置。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func getMiddle&lt;T&gt;(_ list: LinkedList&lt;T&gt;) -&gt; Node&lt;T&gt;? &#123;\n    var fast &#x3D; list.head\n    var slow &#x3D; list.head\n    \n    while let nextFast &#x3D; fast?.next &#123;\n        fast &#x3D; nextFast.next\n        slow &#x3D; slow?.next\n    &#125;\n    return slow\n&#125;</code></pre>\n\n\n<p>测试和结果检查：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;getting the middle node&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    list.push(3)\n    list.push(2)\n    list.push(1)\n       \n    print(&quot;Original list: \\(list)&quot;)\n    if let middleNode &#x3D; getMiddle(list) &#123;\n        print(middleNode.value)\n    &#125;\n&#125;\n\n&#x2F;&#x2F; ---Example of getting the middle node---\n&#x2F;&#x2F; Original list: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; 2</code></pre>\n\n<p>该算法的时间复杂度是**O(n)<strong>。也可以使用另一种解法，先遍历依次整个链表，记录节点总数，然后取链表节点总数的一半，再次进行遍历，获取中间值，但是这样的解法需要遍历两次，时间复杂度为</strong>O(n^2)**。</p>\n<h2 id=\"Challenge-3：创建反转链表的函数。\"><a href=\"#Challenge-3：创建反转链表的函数。\" class=\"headerlink\" title=\"Challenge 3：创建反转链表的函数。\"></a>Challenge 3：创建反转链表的函数。</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; LinkedList\n&#x2F;&#x2F; Before\n1 -&gt; 2 -&gt; 3 -&gt; nil\n\n&#x2F;&#x2F; After\n3 -&gt; 2 -&gt; 1 -&gt; nil</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该问题简单的解决方案是，新建一个LinkedList，然后遍历原LinkedList，将节点一个一个的push到新的LinkedList，最后更新原LinkedList的头节点即可。但是这样的方式会有一个性能问题，就是每次调用push方法的时候，都需要分配新的节点，造成了绝大的资源成本。另一种代码较为复杂，但是性能上却相当好的方案是，构建两个变量，分别指向当前节点和上一个节点，然后遍历LinkedList，依次向后交换当前节点和上一个节点的指向，直到当前节点为nil时结束，这样就完全避免了每次新建节点的资源消耗问题。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; Reverse solution 1\nmutating func reverseSolutionOne() &#123;\n    var tempList &#x3D; LinkedList&lt;Value&gt;()\n    for value in self &#123;\n        tempList.push(value)\n    &#125;\n    head &#x3D; tempList.head\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">&#x2F;&#x2F; Reverse solution 2\npublic mutating func reverseSolutionTwo() &#123;\n    tail &#x3D; head\n    var prev &#x3D; head\n    var current &#x3D; head?.next\n    prev?.next &#x3D; nil\n        \n    while current !&#x3D; nil &#123;\n        let next &#x3D; current?.next\n        current?.next &#x3D; prev\n        prev &#x3D; current\n        current &#x3D; next\n    &#125;\n    head &#x3D; prev\n&#125;</code></pre>\n\n<p>虽然两种解决方案都是完整该挑战，但是在时间复杂度相同的情况下，空间复杂度更好的解决方案2，是应该遵循且掌握的方式。算法2的思路图示如下：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/6/reversed-list.png\"></p>\n<p>测试算法及检验结果：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;reverse the list solution 2&quot;) &#123;\n    var list &#x3D; LinkedList&lt;Int&gt;()\n    list.push(3)\n    list.push(2)\n    list.push(1)\n    \n    print(&quot;Original list: \\(list)&quot;)\n    list.reverseSolutionTwo()\n    print(&quot;Reversed list: \\(list)&quot;)\n&#125;\n\n&#x2F;&#x2F; ---Example of reverse the list solution 2---\n&#x2F;&#x2F; Original list: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; Reversed list: 3 -&gt;2 -&gt;1 </code></pre>\n\n<h2 id=\"Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。\"><a href=\"#Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。\" class=\"headerlink\" title=\"Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。\"></a>Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; list1\n1 -&gt; 4 -&gt; 10 -&gt; 11\n\n&#x2F;&#x2F; list2\n-1 -&gt; 2 -&gt; 3 -&gt; 6\n\n&#x2F;&#x2F; merged list\n-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 10 -&gt; 11</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>此问题的解决方案是不断从两个已排序的列表中摘取节点，并将它们添加到新列表中。由于两个列表已经排序，因此可以比较两个列表的下一个节点，以查看哪个节点应该是要添加到新列表的下一个节点。</p></blockquote>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func mergeSort&lt;T: Comparable&gt;(_ left: LinkedList&lt;T&gt;, _ right:LinkedList&lt;T&gt;) -&gt; LinkedList&lt;T&gt; &#123;\n    &#x2F;&#x2F; 检查输入的两个链表是否为空，如果其中一个为空，则直接返回另一个\n    guard !left.isEmpty else &#123;\n        return right\n    &#125;\n    guard !right.isEmpty else &#123;\n        return left\n    &#125;\n    \n    &#x2F;&#x2F; 结果链表的head、tail定义\n    var newHead: Node&lt;T&gt;?\n    var tail: Node&lt;T&gt;?\n    \n    var currentLeft &#x3D; left.head\n    var currentRight &#x3D; right.head\n    &#x2F;&#x2F; 检查left、right的首个节点，并将小的节点赋值给newHead\n    if let leftNode &#x3D; currentLeft, let rightNode &#x3D; currentRight &#123;\n        if leftNode.value &lt; rightNode.value &#123;\n            newHead &#x3D; leftNode\n            currentLeft &#x3D; leftNode.next\n        &#125; else &#123;\n            newHead &#x3D; rightNode\n            currentRight &#x3D; rightNode.next\n        &#125;\n        tail &#x3D; newHead\n    &#125;\n    &#x2F;&#x2F; 合并\n    &#x2F;&#x2F; 遍历left、right，尝试挑选能够加入新链表的节点，直到其中一个链表到达末尾节点\n    while let leftNode &#x3D; currentLeft, let rightNode &#x3D; currentRight &#123;\n        &#x2F;&#x2F; 比较节点值大小，并将小的链接到tail.next\n        if leftNode.value &lt; rightNode.value &#123;\n            tail?.next &#x3D; leftNode\n            currentLeft &#x3D; leftNode.next\n        &#125; else &#123;\n            tail?.next &#x3D; rightNode\n            currentRight &#x3D; rightNode.next\n        &#125;\n        tail &#x3D; tail?.next\n    &#125;\n    &#x2F;&#x2F; 上个while循环同时以来currentLeft和currentRight，因此即使链表中还有节点，循坏也可能提前终止。需要将剩余的节点链接到处理单元中\n    if let leftNodes &#x3D; currentLeft &#123;\n        tail?.next &#x3D; leftNodes\n    &#125;\n    \n    if let rightNodes &#x3D; currentRight &#123;\n        tail?.next &#x3D; rightNodes\n    &#125;\n    \n    &#x2F;&#x2F; 创建结果链表，这里不使用push或者append的方式，而是直接指定链表的head、tail\n    &#x2F;&#x2F; head只有一个节点，直接复制，tail包含了很多节点，需要一个一个地进行链接\n    var list &#x3D; LinkedList&lt;T&gt;()\n    list.head &#x3D; newHead\n    list.tail &#x3D; &#123;\n        while let next &#x3D; tail?.next &#123;\n            tail &#x3D; next\n        &#125;\n        return tail\n    &#125;()\n    return list\n&#125;</code></pre>\n\n<p>算法求解过程的图示：</p>\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/6/MergeTwolinkedLists.png\"></p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;merging two sorted list&quot;) &#123;\n    var list1 &#x3D; LinkedList&lt;Int&gt;()\n    list1.push(3)\n    list1.push(2)\n    list1.push(1)\n    \n    var list2 &#x3D; LinkedList&lt;Int&gt;()\n    list2.push(-1)\n    list2.push(-2)\n    list2.push(-3)\n    \n    print(&quot;First list: \\(list1)&quot;)\n    print(&quot;Second list: \\(list2)&quot;)\n    let mergedList &#x3D; mergeSort(list1, list2)\n    print(&quot;Merged list: \\(mergedList)&quot;)\n&#125;\n\n&#x2F;&#x2F; ---Example of merging two sorted list---\n&#x2F;&#x2F; First list: 1 -&gt;2 -&gt;3  \n&#x2F;&#x2F; Second list: -3 -&gt;-2 -&gt;-1  \n&#x2F;&#x2F; Merged list: -3 -&gt;-2 -&gt;-1 -&gt;1 -&gt;2 -&gt;3 </code></pre>\n\n<h2 id=\"Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。\"><a href=\"#Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。\" class=\"headerlink\" title=\"Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。\"></a>Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">&#x2F;&#x2F; original list\n1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 4\n\n&#x2F;&#x2F; list after removing all occurrences of 3\n1 -&gt; 4</code></pre>\n\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension LinkedList where Value: Equatable &#123;\n    public mutating func removeAll(_ value: Value) &#123;\n        while let head &#x3D; self.head, head.value &#x3D;&#x3D; value &#123;\n            self.head &#x3D; head.next\n        &#125;\n        \n        var prev &#x3D; head\n        var current &#x3D; head?.next\n        while let currentNode &#x3D; current &#123;\n            guard currentNode.value !&#x3D; value else &#123;\n                prev?.next &#x3D; currentNode.next\n                current &#x3D; prev?.next\n                continue\n            &#125;\n            prev &#x3D; current\n            current &#x3D; current?.next\n        &#125;\n        \n        tail &#x3D; prev\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"/images/Data-Structures-&-Algorithms-in-Swift/6/delete-duplicate.png\"></p>\n<p>测试算法及检验结果：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;deleting duplicate nodes&quot;) &#123;\n    var list1 &#x3D; LinkedList&lt;Int&gt;()\n    list1.push(3)\n    list1.push(2)\n    list1.push(2)\n    list1.push(2)\n    list1.push(1)\n    list1.push(1)\n    \n    print(&quot;Origin list: \\(list1)&quot;)\n    list1.removeAll(2)\n    print(&quot;Delete duplicate list: \\(list1)&quot;)\n&#125;\n\n&#x2F;&#x2F; ---Example of deleting duplicate nodes---\n&#x2F;&#x2F; Origin list: 1 -&gt;1 -&gt;2 -&gt;2 -&gt;2 -&gt;3     \n&#x2F;&#x2F; Delete duplicate list: 1 -&gt;1 -&gt;3 </code></pre>\n\n","text":"本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。 Challenge 1：创建按照反向顺序打印链表元素的函数。&#x2F;&#x2F; LinkedList 1 -&gt; 2 -&...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-1%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%8C%89%E7%85%A7%E5%8F%8D%E5%90%91%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">Challenge 1：创建按照反向顺序打印链表元素的函数。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-2%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">Challenge 2：创建返回链表中间节点值的函数。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-3%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">Challenge 3：创建反转链表的函数。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-4%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E6%8E%A5%E6%94%B6%E4%B8%A4%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%B0%E5%8D%95%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E4%B8%AD%E3%80%82\"><span class=\"toc-text\">Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Challenge-5%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%80%E6%9C%89%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#5\\ Linked List && Swift Collection Protocol","uid":"e7521306a70b406b8e5f7047760055b6","slug":"2019-12-04-Data-Structures-&-Algorithms-in-Swift-05","date":"2023-05-13T14:55:49.795Z","updated":"2023-05-13T14:55:49.795Z","comments":true,"path":"api/articles/2019-12-04-Data-Structures-&-Algorithms-in-Swift-05.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/5/cover.jpg","text":"在Swift标准库（Swift standard library）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#7\\ Stack & Stack Simple Challenges","uid":"d2a03c6015acad9ab2a35a4a08b03676","slug":"2019-12-08-Data-Structures-&-Algorithms-in-Swift-07","date":"2023-05-13T14:55:49.795Z","updated":"2023-05-13T14:55:49.795Z","comments":true,"path":"api/articles/2019-12-08-Data-Structures-&-Algorithms-in-Swift-07.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/7/cover.jpeg","text":"栈（Stack）是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}