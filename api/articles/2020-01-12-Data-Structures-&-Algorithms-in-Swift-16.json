{"title":"\\#16\\ 优先级队列","uid":"5d749126a5c6ef9bea973d557d834975","slug":"2020-01-12-Data-Structures-&-Algorithms-in-Swift-16","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-01-12-Data-Structures-&-Algorithms-in-Swift-16.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/16/cover.png","content":"<p>队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是：</p>\n<ol>\n<li><strong>最大优先级队列：</strong>队列中最前面的元素具有最高优先级；</li>\n<li><strong>最小优先级队列：</strong>队列中最前面的元素具有最低优先级。</li>\n</ol>\n<p>当需要在给定的元素列表中取标定最大元素和最小元素时，优先级队列将是非常合适的一种数据结构。</p>\n<h2 id=\"优先级队列的典型应用\"><a href=\"#优先级队列的典型应用\" class=\"headerlink\" title=\"优先级队列的典型应用\"></a>优先级队列的典型应用</h2><ul>\n<li><strong>迪克斯特拉的算法（Dijkstra’s algorithm）</strong>，使用优先级队列计算最小代价。</li>\n<li><strong>A*路径寻找算法</strong>，使用优先级队列跟踪对位置路径进行探索的最短路径。</li>\n<li><strong>堆排序</strong>，可以使用优先级队列实现。</li>\n<li><strong>哈夫曼编码</strong>会构建一个压缩树。最小优先级队列用于重复查找两个频率最小的节点，这些节点未具有父节点。</li>\n</ul>\n<p>优先级队列的应用范围很广，远不止上述列举的部分。</p>\n<h2 id=\"一般操作\"><a href=\"#一般操作\" class=\"headerlink\" title=\"一般操作\"></a>一般操作</h2><p>在 <a href=\"https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-08/\">#8\\ 队列的Swift实现与操作定义</a>中我们为队列定义了如下的一个协议：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public protocol Queue &#123;\n    associatedtype  Element\n    mutating func enqueue(_ element: Element) -&gt; Bool\n    mutating func dequeue() -&gt; Element?\n    var isEmpty: Bool &#123; get &#125;\n    var peek: Element? &#123; get &#125;\n&#125;</code></pre>\n\n<p>优先级队列和普通队列同样有着相同的操作，只是具体的实现会有所不同。</p>\n<p>对于优先级队列而言，同样对遵循协议<strong>Queue</strong>，并实现一些一般性的操作如下：</p>\n<ul>\n<li><strong>enqueue：</strong>插入一个元素到队列，如果操作成功，则返回<em>true</em>；</li>\n<li><strong>dequeue：</strong>移除具有最高优先级的元素，并返回它，如果队列为空，则返回<em>nil</em>；</li>\n<li><strong>isEmpty：</strong>检查队列是否为空；</li>\n<li><strong>peek：</strong>返回具有最高优先级的队列，但并不进行删除，如果队列为空，则返回<em>nil</em>。</li>\n</ul>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><p>构建优先级队列的方式有以下几种：</p>\n<ol>\n<li><strong>已排序数组</strong>：在获取最大值或最小值的时间复杂度均为O(1)，使用此数据构建优先级队列非常有效，但是其插入算法却比较慢，会达到O(n)的时间复杂度。</li>\n<li><strong>平衡二叉搜索树</strong>：在创建双端优先级队列时，使用平衡二叉搜索树最为有利，此时获取最小值和最大值的时间复杂度均在_O(log n)，插入算法比排序的数组会更好，在O(log n)。</li>\n<li><strong>堆</strong>：优先级队列最佳的选择，堆结构比排序的数组更为有效，因为堆只需要部分排序，除了从最小堆中获取最小值和从最大堆中获取最大值为O(1)的快速外，其他的操作均为O(log n)的时间复杂度。</li>\n</ol>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">struct PriorityQueue&lt;Element: Equatable&gt;: Queue &#123;\n    private var heap: Heap&lt;Element&gt;\n    \n    init(sort: @escaping (Element, Element) -&gt; Bool, elements: [Element] &#x3D; []) &#123;\n        heap &#x3D; Heap(sort: sort, elements: elements)\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li><em>PriorityQueue</em> 遵循队列协议<em>Queue</em>。泛型参数元素必须遵循<em>Equatable</em>，因为在元素的操作中需要能够进行元素间的比较。</li>\n<li>使用堆数据结构实现优先级队列；</li>\n<li>传递合适的参数到初始化构造函数，<em>PriorityQueue</em>可根据参数构建最小和最大优先级队列。</li>\n</ol>\n<p>为了遵循<em>Queue</em>协议，需要增加如下的协议方法：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">public var isEmpty: Bool &#123;\n    return heap.isEmpty\n&#125;\n\npublic var peek: Element? &#123;\n    return heap.peek()\n&#125;\n\npublic mutating func enqueue(_ element: Element) -&gt; Bool &#123;\n    heap.insert(element)\n    return true\n&#125;\n\npublic mutating func dequeue() -&gt; Element? &#123;\n    return heap.remove()\n&#125;</code></pre>\n\n<p>在实践中优先级队列上，堆是最为完美的选择，只需要调用堆的各种方法即可实现优先级队列的各种操作。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">example(of: &quot;priorityQueue&quot;) &#123;\n    var priorityQueue &#x3D; PriorityQueue(sort: &gt;, elements: [1, 12, 3, 4, 1, 6, 8, 7])\n    while !priorityQueue.isEmpty &#123;\n        print(priorityQueue.dequeue()!)\n    &#125;\n&#125;\n\n&#x2F;*\n---Example of priorityQueue---\n12\n8\n7\n6\n4\n3\n1\n1\n*&#x2F;</code></pre>\n\n<h2 id=\"关键点总结\"><a href=\"#关键点总结\" class=\"headerlink\" title=\"关键点总结\"></a>关键点总结</h2><ul>\n<li>一个优先级队列通常使用<strong>优先级顺序</strong>进行元素的查找；</li>\n<li>能够通过关注队列的关键操作而排除堆数据结构提供的其他功能，从而创建抽象层。</li>\n<li>使得优先级队列的意图清晰而简洁。唯一的工作是排队和取消排队元素。</li>\n</ul>\n","text":"队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是： 最大优先级队列：队列中最前面的元素具有最高优先级； 最小优先级队列：队列中最前面的元素具有最低优先级。 当需要在给定的元素...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">优先级队列的典型应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">一般操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">算法实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">测试</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关键点总结</span></a></li></ol>","author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}},"mapped":true,"prev_post":{"title":"\\#15\\ 堆数据结构（The Heap Data Structure）","uid":"4a00ba60db357b4d5652c54beb6b2091","slug":"2020-01-10-Data-Structures-&-Algorithms-in-Swift-15","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-01-10-Data-Structures-&-Algorithms-in-Swift-15.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/15/cover.jpg","text":"想必抓娃娃机如今没有人不知道其实什么了，抓娃娃机的爪子总是那么的难以控制，总是看起来容易的机会却难以如愿。抓抓机的爪子其实就工作在一个堆数据结构之上，爪子每次抓的几乎都是那边一堆玩具最上面的那一个，只有这样机会才会更大一些。 在本文中将学习关于堆（Heap）的基础知识，包含如何创...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}},"next_post":{"title":"\\#17\\ 排序算法O(n^2)","uid":"8ac62db54bf242691e8bc332c52f0b5b","slug":"2020-01-15-Data-Structures-&-Algorithms-in-Swift-17","date":"2023-05-13T11:29:06.795Z","updated":"2023-05-13T11:29:06.795Z","comments":true,"path":"api/articles/2020-01-15-Data-Structures-&-Algorithms-in-Swift-17.json","keywords":null,"cover":"/images/Data-Structures-&-Algorithms-in-Swift/17/cover.jpg","text":"**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。 在本文中，将学习饿三种不同的、O(n^2)时间...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"Data Structures & Algorithms in Swift","slug":"Data-Structures-Algorithms-in-Swift","count":20,"path":"api/categories/Data-Structures-Algorithms-in-Swift.json"}],"tags":[{"name":"Swift中的数据结构与算法","slug":"Swift中的数据结构与算法","count":20,"path":"api/tags/Swift中的数据结构与算法.json"}],"author":{"slug":"undefined","avatar":"/img/avatar.jpg","link":"https://github.com/zycslog","description":"","socials":{}}}}